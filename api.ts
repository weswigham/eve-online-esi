/**
 * EVE Swagger Interface
 * An OpenAPI for EVE Online
 *
 * OpenAPI spec version: 0.7.5
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://esi.tech.ccp.is/latest';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

/**
* Unprocessable entity
*/
export class DeleteCharactersCharacterIdMailLabelsLabelIdUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error': string;
}

/**
* Not found
*/
export class DeleteFleetsFleetIdMembersMemberIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* Not found
*/
export class DeleteFleetsFleetIdSquadsSquadIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* Not found
*/
export class DeleteFleetsFleetIdWingsWingIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* Forbidden model
*/
export class Forbidden {
    /**
    * Forbidden message
    */
    'error': string;
    /**
    * Status code received from SSO
    */
    'ssoStatus': number;
}

/**
* 200 ok object
*/
export class GetAlliancesAllianceIdContacts200Ok {
    /**
    * Standing of the contact
    */
    'standing': number;
    /**
    * contact_type string
    */
    'contactType': GetAlliancesAllianceIdContacts200Ok.ContactTypeEnum;
    /**
    * contact_id integer
    */
    'contactId': number;
    /**
    * Custom label of the contact
    */
    'labelId': number;
}

export namespace GetAlliancesAllianceIdContacts200Ok {
    export enum ContactTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction'
    }
}
/**
* No image server for this datasource
*/
export class GetAlliancesAllianceIdIconsNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetAlliancesAllianceIdIconsOk {
    /**
    * px64x64 string
    */
    'px64x64': string;
    /**
    * px128x128 string
    */
    'px128x128': string;
}

/**
* Not found
*/
export class GetAlliancesAllianceIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetAlliancesAllianceIdOk {
    /**
    * the full name of the alliance
    */
    'name': string;
    /**
    * ID of the character that created the alliance
    */
    'creatorId': number;
    /**
    * ID of the corporation that created the alliance
    */
    'creatorCorporationId': number;
    /**
    * the short name of the alliance
    */
    'ticker': string;
    /**
    * the executor corporation ID, if this alliance is not closed
    */
    'executorCorporationId': number;
    /**
    * date_founded string
    */
    'dateFounded': Date;
    /**
    * Faction ID this alliance is fighting for, if this alliance is enlisted in factional warfare
    */
    'factionId': number;
}

/**
* 200 ok object
*/
export class GetAlliancesNames200Ok {
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * alliance_name string
    */
    'allianceName': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdAgentsResearch200Ok {
    /**
    * agent_id integer
    */
    'agentId': number;
    /**
    * skill_type_id integer
    */
    'skillTypeId': number;
    /**
    * started_at string
    */
    'startedAt': Date;
    /**
    * points_per_day number
    */
    'pointsPerDay': number;
    /**
    * remainder_points number
    */
    'remainderPoints': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdAssets200Ok {
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * location_type string
    */
    'locationType': GetCharactersCharacterIdAssets200Ok.LocationTypeEnum;
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * location_flag string
    */
    'locationFlag': GetCharactersCharacterIdAssets200Ok.LocationFlagEnum;
    /**
    * is_singleton boolean
    */
    'isSingleton': boolean;
}

export namespace GetCharactersCharacterIdAssets200Ok {
    export enum LocationTypeEnum {
        Station = <any> 'station',
        SolarSystem = <any> 'solar_system',
        Other = <any> 'other'
    }
    export enum LocationFlagEnum {
        AssetSafety = <any> 'AssetSafety',
        AutoFit = <any> 'AutoFit',
        Cargo = <any> 'Cargo',
        CorpseBay = <any> 'CorpseBay',
        Deliveries = <any> 'Deliveries',
        DroneBay = <any> 'DroneBay',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        FleetHangar = <any> 'FleetHangar',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        HiddenModifiers = <any> 'HiddenModifiers',
        Implant = <any> 'Implant',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        Locked = <any> 'Locked',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        QuafeBay = <any> 'QuafeBay',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        ShipHangar = <any> 'ShipHangar',
        Skill = <any> 'Skill',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        SubSystemBay = <any> 'SubSystemBay',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        Unlocked = <any> 'Unlocked',
        Wardrobe = <any> 'Wardrobe'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdAttributesOk {
    /**
    * charisma integer
    */
    'charisma': number;
    /**
    * intelligence integer
    */
    'intelligence': number;
    /**
    * memory integer
    */
    'memory': number;
    /**
    * perception integer
    */
    'perception': number;
    /**
    * willpower integer
    */
    'willpower': number;
    /**
    * Number of available bonus character neural remaps
    */
    'bonusRemaps': number;
    /**
    * Datetime of last neural remap, including usage of bonus remaps
    */
    'lastRemapDate': Date;
    /**
    * Neural remapping cooldown after a character uses remap accrued over time
    */
    'accruedRemapCooldownDate': Date;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdBlueprints200Ok {
    /**
    * Unique ID for this item.
    */
    'itemId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * References a solar system, station or item_id if this blueprint is located within a container. If the return value is an item_id, then the Character AssetList API must be queried to find the container using the given item_id to determine the correct location of the Blueprint.
    */
    'locationId': number;
    /**
    * Type of the location_id
    */
    'locationFlag': GetCharactersCharacterIdBlueprints200Ok.LocationFlagEnum;
    /**
    * A range of numbers with a minimum of -2 and no maximum value where -1 is an original and -2 is a copy. It can be a positive integer if it is a stack of blueprint originals fresh from the market (e.g. no activities performed on them yet).
    */
    'quantity': number;
    /**
    * Time Efficiency Level of the blueprint.
    */
    'timeEfficiency': number;
    /**
    * Material Efficiency Level of the blueprint.
    */
    'materialEfficiency': number;
    /**
    * Number of runs remaining if the blueprint is a copy, -1 if it is an original.
    */
    'runs': number;
}

export namespace GetCharactersCharacterIdBlueprints200Ok {
    export enum LocationFlagEnum {
        AutoFit = <any> 'AutoFit',
        Cargo = <any> 'Cargo',
        CorpseBay = <any> 'CorpseBay',
        DroneBay = <any> 'DroneBay',
        FleetHangar = <any> 'FleetHangar',
        Deliveries = <any> 'Deliveries',
        HiddenModifiers = <any> 'HiddenModifiers',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        AssetSafety = <any> 'AssetSafety',
        Locked = <any> 'Locked',
        Unlocked = <any> 'Unlocked',
        Implant = <any> 'Implant',
        QuafeBay = <any> 'QuafeBay',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        ShipHangar = <any> 'ShipHangar',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        Module = <any> 'Module'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdBookmarks200Ok {
    /**
    * bookmark_id integer
    */
    'bookmarkId': number;
    /**
    * folder_id integer
    */
    'folderId': number;
    /**
    * created string
    */
    'created': Date;
    /**
    * label string
    */
    'label': string;
    /**
    * notes string
    */
    'notes': string;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * creator_id integer
    */
    'creatorId': number;
    'item': GetCharactersCharacterIdBookmarksItem;
    'coordinates': GetCharactersCharacterIdBookmarksCoordinates;
}

/**
* Optional object that is returned if a bookmark was made on a planet or a random location in space.
*/
export class GetCharactersCharacterIdBookmarksCoordinates {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdBookmarksFolders200Ok {
    /**
    * folder_id integer
    */
    'folderId': number;
    /**
    * name string
    */
    'name': string;
}

/**
* Optional object that is returned if a bookmark was made on a particular item.
*/
export class GetCharactersCharacterIdBookmarksItem {
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * type_id integer
    */
    'typeId': number;
}

/**
* event
*/
export class GetCharactersCharacterIdCalendar200Ok {
    /**
    * event_id integer
    */
    'eventId': number;
    /**
    * event_date string
    */
    'eventDate': Date;
    /**
    * title string
    */
    'title': string;
    /**
    * importance integer
    */
    'importance': number;
    /**
    * event_response string
    */
    'eventResponse': GetCharactersCharacterIdCalendar200Ok.EventResponseEnum;
}

export namespace GetCharactersCharacterIdCalendar200Ok {
    export enum EventResponseEnum {
        Declined = <any> 'declined',
        NotResponded = <any> 'not_responded',
        Accepted = <any> 'accepted',
        Tentative = <any> 'tentative'
    }
}
/**
* character_id and response of an attendee
*/
export class GetCharactersCharacterIdCalendarEventIdAttendees200Ok {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * event_response string
    */
    'eventResponse': GetCharactersCharacterIdCalendarEventIdAttendees200Ok.EventResponseEnum;
}

export namespace GetCharactersCharacterIdCalendarEventIdAttendees200Ok {
    export enum EventResponseEnum {
        Declined = <any> 'declined',
        NotResponded = <any> 'not_responded',
        Accepted = <any> 'accepted',
        Tentative = <any> 'tentative'
    }
}
/**
* Full details of a specific event
*/
export class GetCharactersCharacterIdCalendarEventIdOk {
    /**
    * event_id integer
    */
    'eventId': number;
    /**
    * owner_id integer
    */
    'ownerId': number;
    /**
    * owner_name string
    */
    'ownerName': string;
    /**
    * date string
    */
    'date': Date;
    /**
    * title string
    */
    'title': string;
    /**
    * Length in minutes
    */
    'duration': number;
    /**
    * importance integer
    */
    'importance': number;
    /**
    * response string
    */
    'response': string;
    /**
    * text string
    */
    'text': string;
    /**
    * owner_type string
    */
    'ownerType': GetCharactersCharacterIdCalendarEventIdOk.OwnerTypeEnum;
}

export namespace GetCharactersCharacterIdCalendarEventIdOk {
    export enum OwnerTypeEnum {
        EveServer = <any> 'eve_server',
        Corporation = <any> 'corporation',
        Faction = <any> 'faction',
        Character = <any> 'character',
        Alliance = <any> 'alliance'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdChatChannels200Ok {
    /**
    * Unique channel ID. Always negative for player-created channels. Permanent (CCP created) channels have a positive ID, but don't appear in the API
    */
    'channelId': number;
    /**
    * Displayed name of channel
    */
    'name': string;
    /**
    * owner_id integer
    */
    'ownerId': number;
    /**
    * Normalized, unique string used to compare channel names
    */
    'comparisonKey': string;
    /**
    * If this is a password protected channel
    */
    'hasPassword': boolean;
    /**
    * Message of the day for this channel
    */
    'motd': string;
    /**
    * allowed array
    */
    'allowed': Array<GetCharactersCharacterIdChatChannelsAllowed>;
    /**
    * operators array
    */
    'operators': Array<GetCharactersCharacterIdChatChannelsOperator>;
    /**
    * blocked array
    */
    'blocked': Array<GetCharactersCharacterIdChatChannelsBlocked>;
    /**
    * muted array
    */
    'muted': Array<GetCharactersCharacterIdChatChannelsMuted>;
}

/**
* allowed object
*/
export class GetCharactersCharacterIdChatChannelsAllowed {
    /**
    * ID of an allowed channel member
    */
    'accessorId': number;
    /**
    * accessor_type string
    */
    'accessorType': GetCharactersCharacterIdChatChannelsAllowed.AccessorTypeEnum;
}

export namespace GetCharactersCharacterIdChatChannelsAllowed {
    export enum AccessorTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance'
    }
}
/**
* blocked object
*/
export class GetCharactersCharacterIdChatChannelsBlocked {
    /**
    * ID of a blocked channel member
    */
    'accessorId': number;
    /**
    * accessor_type string
    */
    'accessorType': GetCharactersCharacterIdChatChannelsBlocked.AccessorTypeEnum;
    /**
    * Reason this accessor is blocked
    */
    'reason': string;
    /**
    * Time at which this accessor will no longer be blocked
    */
    'endAt': Date;
}

export namespace GetCharactersCharacterIdChatChannelsBlocked {
    export enum AccessorTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance'
    }
}
/**
* muted object
*/
export class GetCharactersCharacterIdChatChannelsMuted {
    /**
    * ID of a muted channel member
    */
    'accessorId': number;
    /**
    * accessor_type string
    */
    'accessorType': GetCharactersCharacterIdChatChannelsMuted.AccessorTypeEnum;
    /**
    * Reason this accessor is muted
    */
    'reason': string;
    /**
    * Time at which this accessor will no longer be muted
    */
    'endAt': Date;
}

export namespace GetCharactersCharacterIdChatChannelsMuted {
    export enum AccessorTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance'
    }
}
/**
* operator object
*/
export class GetCharactersCharacterIdChatChannelsOperator {
    /**
    * ID of a channel operator
    */
    'accessorId': number;
    /**
    * accessor_type string
    */
    'accessorType': GetCharactersCharacterIdChatChannelsOperator.AccessorTypeEnum;
}

export namespace GetCharactersCharacterIdChatChannelsOperator {
    export enum AccessorTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance'
    }
}
/**
* home_location object
*/
export class GetCharactersCharacterIdClonesHomeLocation {
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * location_type string
    */
    'locationType': GetCharactersCharacterIdClonesHomeLocation.LocationTypeEnum;
}

export namespace GetCharactersCharacterIdClonesHomeLocation {
    export enum LocationTypeEnum {
        Station = <any> 'station',
        Structure = <any> 'structure'
    }
}
/**
* jump_clone object
*/
export class GetCharactersCharacterIdClonesJumpClone {
    /**
    * jump_clone_id integer
    */
    'jumpCloneId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * location_type string
    */
    'locationType': GetCharactersCharacterIdClonesJumpClone.LocationTypeEnum;
    /**
    * implants array
    */
    'implants': Array<number>;
}

export namespace GetCharactersCharacterIdClonesJumpClone {
    export enum LocationTypeEnum {
        Station = <any> 'station',
        Structure = <any> 'structure'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdClonesOk {
    /**
    * last_clone_jump_date string
    */
    'lastCloneJumpDate': Date;
    'homeLocation': GetCharactersCharacterIdClonesHomeLocation;
    /**
    * last_station_change_date string
    */
    'lastStationChangeDate': Date;
    /**
    * jump_clones array
    */
    'jumpClones': Array<GetCharactersCharacterIdClonesJumpClone>;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdContacts200Ok {
    /**
    * Standing of the contact
    */
    'standing': number;
    /**
    * contact_type string
    */
    'contactType': GetCharactersCharacterIdContacts200Ok.ContactTypeEnum;
    /**
    * contact_id integer
    */
    'contactId': number;
    /**
    * Whether this contact is being watched
    */
    'isWatched': boolean;
    /**
    * Whether this contact is in the blocked list. Note a missing value denotes unknown, not true or false
    */
    'isBlocked': boolean;
    /**
    * Custom label of the contact
    */
    'labelId': number;
}

export namespace GetCharactersCharacterIdContacts200Ok {
    export enum ContactTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdContactsLabels200Ok {
    /**
    * label_id integer
    */
    'labelId': number;
    /**
    * label_name string
    */
    'labelName': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdContracts200Ok {
    /**
    * contract_id integer
    */
    'contractId': number;
    /**
    * Character ID for the issuer
    */
    'issuerId': number;
    /**
    * Character's corporation ID for the issuer
    */
    'issuerCorporationId': number;
    /**
    * ID to whom the contract is assigned, can be corporation or character ID
    */
    'assigneeId': number;
    /**
    * Who will accept the contract
    */
    'acceptorId': number;
    /**
    * Start location ID (for Couriers contract)
    */
    'startLocationId': number;
    /**
    * End location ID (for Couriers contract)
    */
    'endLocationId': number;
    /**
    * Type of the contract
    */
    'type': GetCharactersCharacterIdContracts200Ok.TypeEnum;
    /**
    * Status of the the contract
    */
    'status': GetCharactersCharacterIdContracts200Ok.StatusEnum;
    /**
    * Title of the contract
    */
    'title': string;
    /**
    * true if the contract was issued on behalf of the issuer's corporation
    */
    'forCorporation': boolean;
    /**
    * To whom the contract is available
    */
    'availability': GetCharactersCharacterIdContracts200Ok.AvailabilityEnum;
    /**
    * Сreation date of the contract
    */
    'dateIssued': Date;
    /**
    * Expiration date of the contract
    */
    'dateExpired': Date;
    /**
    * Date of confirmation of contract
    */
    'dateAccepted': Date;
    /**
    * Number of days to perform the contract
    */
    'daysToComplete': number;
    /**
    * Date of completed of contract
    */
    'dateCompleted': Date;
    /**
    * Price of contract (for ItemsExchange and Auctions)
    */
    'price': number;
    /**
    * Remuneration for contract (for Couriers only)
    */
    'reward': number;
    /**
    * Collateral price (for Couriers only)
    */
    'collateral': number;
    /**
    * Buyout price (for Auctions only)
    */
    'buyout': number;
    /**
    * Volume of items in the contract
    */
    'volume': number;
}

export namespace GetCharactersCharacterIdContracts200Ok {
    export enum TypeEnum {
        Unknown = <any> 'unknown',
        ItemExchange = <any> 'item_exchange',
        Auction = <any> 'auction',
        Courier = <any> 'courier',
        Loan = <any> 'loan'
    }
    export enum StatusEnum {
        Outstanding = <any> 'outstanding',
        InProgress = <any> 'in_progress',
        FinishedIssuer = <any> 'finished_issuer',
        FinishedContractor = <any> 'finished_contractor',
        Finished = <any> 'finished',
        Cancelled = <any> 'cancelled',
        Rejected = <any> 'rejected',
        Failed = <any> 'failed',
        Deleted = <any> 'deleted',
        Reversed = <any> 'reversed'
    }
    export enum AvailabilityEnum {
        Public = <any> 'public',
        Personal = <any> 'personal',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdContractsContractIdBids200Ok {
    /**
    * Unique ID for the bid
    */
    'bidId': number;
    /**
    * Character ID of the bidder
    */
    'bidderId': number;
    /**
    * Datetime when the bid was placed
    */
    'dateBid': Date;
    /**
    * The amount bid, in ISK
    */
    'amount': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdContractsContractIdItems200Ok {
    /**
    * Unique ID for the item
    */
    'recordId': number;
    /**
    * Type ID for item
    */
    'typeId': number;
    /**
    * Number of items in the stack
    */
    'quantity': number;
    /**
    * -1 indicates that the item is a singleton (non-stackable). If the item happens to be a Blueprint, -1 is an Original and -2 is a Blueprint Copy
    */
    'rawQuantity': number;
    /**
    * is_singleton boolean
    */
    'isSingleton': boolean;
    /**
    * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract.
    */
    'isIncluded': boolean;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdCorporationhistory200Ok {
    /**
    * start_date string
    */
    'startDate': Date;
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * True if the corporation has been deleted
    */
    'isDeleted': boolean;
    /**
    * An incrementing ID that can be used to canonically establish order of records in cases where dates may be ambiguous
    */
    'recordId': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdFatigueOk {
    /**
    * Character's last jump activation
    */
    'lastJumpDate': Date;
    /**
    * Character's jump fatigue expiry
    */
    'jumpFatigueExpireDate': Date;
    /**
    * Character's last jump update
    */
    'lastUpdateDate': Date;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdFittings200Ok {
    /**
    * fitting_id integer
    */
    'fittingId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * description string
    */
    'description': string;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;
    /**
    * items array
    */
    'items': Array<GetCharactersCharacterIdFittingsItem>;
}

/**
* item object
*/
export class GetCharactersCharacterIdFittingsItem {
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * flag integer
    */
    'flag': number;
    /**
    * quantity integer
    */
    'quantity': number;
}

/**
* Not found
*/
export class GetCharactersCharacterIdFleetNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdFleetOk {
    /**
    * The character's current fleet ID
    */
    'fleetId': number;
    /**
    * ID of the wing the member is in. If not applicable, will be set to -1
    */
    'wingId': number;
    /**
    * ID of the squad the member is in. If not applicable, will be set to -1
    */
    'squadId': number;
    /**
    * Member’s role in fleet
    */
    'role': GetCharactersCharacterIdFleetOk.RoleEnum;
}

export namespace GetCharactersCharacterIdFleetOk {
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member',
        WingCommander = <any> 'wing_commander'
    }
}
/**
* Summary of kills done by the given character against enemy factions
*/
export class GetCharactersCharacterIdFwStatsKills {
    /**
    * Yesterday's total number of kills by a given character against enemy factions
    */
    'yesterday': number;
    /**
    * Last week's total number of kills by a given character against enemy factions
    */
    'lastWeek': number;
    /**
    * Total number of kills by a given character against enemy factions since the character enlisted
    */
    'total': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdFwStatsOk {
    /**
    * The faction the given character is enlisted to fight for. Will not be included if character is not enlisted in faction warfare
    */
    'factionId': number;
    /**
    * The enlistment date of the given character into faction warfare. Will not be included if character is not enlisted in faction warfare
    */
    'enlistedOn': Date;
    /**
    * The given character's current faction rank
    */
    'currentRank': number;
    /**
    * The given character's highest faction rank achieved
    */
    'highestRank': number;
    'kills': GetCharactersCharacterIdFwStatsKills;
    'victoryPoints': GetCharactersCharacterIdFwStatsVictoryPoints;
}

/**
* Summary of victory points gained by the given character for the enlisted faction
*/
export class GetCharactersCharacterIdFwStatsVictoryPoints {
    /**
    * Yesterday's victory points gained by the given character
    */
    'yesterday': number;
    /**
    * Last week's victory points gained by the given character
    */
    'lastWeek': number;
    /**
    * Total victory points gained since the given character enlisted
    */
    'total': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdIndustryJobs200Ok {
    /**
    * Unique job ID
    */
    'jobId': number;
    /**
    * ID of the character which installed this job
    */
    'installerId': number;
    /**
    * ID of the facility where this job is running
    */
    'facilityId': number;
    /**
    * ID of the station where industry facility is located
    */
    'stationId': number;
    /**
    * Job activity ID
    */
    'activityId': number;
    /**
    * blueprint_id integer
    */
    'blueprintId': number;
    /**
    * blueprint_type_id integer
    */
    'blueprintTypeId': number;
    /**
    * Location ID of the location from which the blueprint was installed. Normally a station ID, but can also be an asset (e.g. container) or corporation facility
    */
    'blueprintLocationId': number;
    /**
    * Location ID of the location to which the output of the job will be delivered. Normally a station ID, but can also be a corporation facility
    */
    'outputLocationId': number;
    /**
    * Number of runs for a manufacturing job, or number of copies to make for a blueprint copy
    */
    'runs': number;
    /**
    * The sume of job installation fee and industry facility tax
    */
    'cost': number;
    /**
    * Number of runs blueprint is licensed for
    */
    'licensedRuns': number;
    /**
    * Chance of success for invention
    */
    'probability': number;
    /**
    * Type ID of product (manufactured, copied or invented)
    */
    'productTypeId': number;
    /**
    * status string
    */
    'status': GetCharactersCharacterIdIndustryJobs200Ok.StatusEnum;
    /**
    * Job duration in seconds
    */
    'duration': number;
    /**
    * Date and time when this job started
    */
    'startDate': Date;
    /**
    * Date and time when this job finished
    */
    'endDate': Date;
    /**
    * Date and time when this job was paused (i.e. time when the facility where this job was installed went offline)
    */
    'pauseDate': Date;
    /**
    * Date and time when this job was completed
    */
    'completedDate': Date;
    /**
    * ID of the character which completed this job
    */
    'completedCharacterId': number;
    /**
    * Number of successful runs for this job. Equal to runs unless this is an invention job
    */
    'successfulRuns': number;
}

export namespace GetCharactersCharacterIdIndustryJobs200Ok {
    export enum StatusEnum {
        Active = <any> 'active',
        Cancelled = <any> 'cancelled',
        Delivered = <any> 'delivered',
        Paused = <any> 'paused',
        Ready = <any> 'ready',
        Reverted = <any> 'reverted'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdKillmailsRecent200Ok {
    /**
    * ID of this killmail
    */
    'killmailId': number;
    /**
    * A hash of this killmail
    */
    'killmailHash': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdLocationOk {
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * station_id integer
    */
    'stationId': number;
    /**
    * structure_id integer
    */
    'structureId': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdLoyaltyPoints200Ok {
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * loyalty_points integer
    */
    'loyaltyPoints': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdMail200Ok {
    /**
    * mail_id integer
    */
    'mailId': number;
    /**
    * Mail subject
    */
    'subject': string;
    /**
    * From whom the mail was sent
    */
    'from': number;
    /**
    * When the mail was sent
    */
    'timestamp': Date;
    /**
    * labels array
    */
    'labels': Array<number>;
    /**
    * Recipients of the mail
    */
    'recipients': Array<GetCharactersCharacterIdMailRecipient>;
    /**
    * is_read boolean
    */
    'isRead': boolean;
}

/**
* label object
*/
export class GetCharactersCharacterIdMailLabelsLabel {
    /**
    * unread_count integer
    */
    'unreadCount': number;
    /**
    * label_id integer
    */
    'labelId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * color string
    */
    'color': GetCharactersCharacterIdMailLabelsLabel.ColorEnum;
}

export namespace GetCharactersCharacterIdMailLabelsLabel {
    export enum ColorEnum {
        _0000fe = <any> '#0000fe',
        _006634 = <any> '#006634',
        _0099ff = <any> '#0099ff',
        _00ff33 = <any> '#00ff33',
        _01ffff = <any> '#01ffff',
        _349800 = <any> '#349800',
        _660066 = <any> '#660066',
        _666666 = <any> '#666666',
        _999999 = <any> '#999999',
        _99ffff = <any> '#99ffff',
        _9a0000 = <any> '#9a0000',
        Ccff9a = <any> '#ccff9a',
        E6e6e6 = <any> '#e6e6e6',
        Fe0000 = <any> '#fe0000',
        Ff6600 = <any> '#ff6600',
        Ffff01 = <any> '#ffff01',
        Ffffcd = <any> '#ffffcd',
        Ffffff = <any> '#ffffff'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdMailLabelsOk {
    /**
    * total_unread_count integer
    */
    'totalUnreadCount': number;
    /**
    * labels array
    */
    'labels': Array<GetCharactersCharacterIdMailLabelsLabel>;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdMailLists200Ok {
    /**
    * Mailing list ID
    */
    'mailingListId': number;
    /**
    * name string
    */
    'name': string;
}

/**
* Not found
*/
export class GetCharactersCharacterIdMailMailIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdMailMailIdOk {
    /**
    * Mail subject
    */
    'subject': string;
    /**
    * From whom the mail was sent
    */
    'from': number;
    /**
    * When the mail was sent
    */
    'timestamp': Date;
    /**
    * Recipients of the mail
    */
    'recipients': Array<GetCharactersCharacterIdMailMailIdRecipient>;
    /**
    * Mail's body
    */
    'body': string;
    /**
    * Labels attached to the mail
    */
    'labels': Array<number>;
    /**
    * Whether the mail is flagged as read
    */
    'read': boolean;
}

/**
* recipient object
*/
export class GetCharactersCharacterIdMailMailIdRecipient {
    /**
    * recipient_type string
    */
    'recipientType': GetCharactersCharacterIdMailMailIdRecipient.RecipientTypeEnum;
    /**
    * recipient_id integer
    */
    'recipientId': number;
}

export namespace GetCharactersCharacterIdMailMailIdRecipient {
    export enum RecipientTypeEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        MailingList = <any> 'mailing_list'
    }
}
/**
* recipient object
*/
export class GetCharactersCharacterIdMailRecipient {
    /**
    * recipient_type string
    */
    'recipientType': GetCharactersCharacterIdMailRecipient.RecipientTypeEnum;
    /**
    * recipient_id integer
    */
    'recipientId': number;
}

export namespace GetCharactersCharacterIdMailRecipient {
    export enum RecipientTypeEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        MailingList = <any> 'mailing_list'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdMedals200Ok {
    /**
    * medal_id integer
    */
    'medalId': number;
    /**
    * title string
    */
    'title': string;
    /**
    * description string
    */
    'description': string;
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * issuer_id integer
    */
    'issuerId': number;
    /**
    * date string
    */
    'date': Date;
    /**
    * reason string
    */
    'reason': string;
    /**
    * status string
    */
    'status': GetCharactersCharacterIdMedals200Ok.StatusEnum;
    /**
    * graphics array
    */
    'graphics': Array<GetCharactersCharacterIdMedalsGraphic>;
}

export namespace GetCharactersCharacterIdMedals200Ok {
    export enum StatusEnum {
        Public = <any> 'public',
        Private = <any> 'private'
    }
}
/**
* graphic object
*/
export class GetCharactersCharacterIdMedalsGraphic {
    /**
    * part integer
    */
    'part': number;
    /**
    * layer integer
    */
    'layer': number;
    /**
    * graphic string
    */
    'graphic': string;
    /**
    * color integer
    */
    'color': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdMining200Ok {
    /**
    * date string
    */
    'date': Date;
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * quantity integer
    */
    'quantity': number;
}

/**
* Not found
*/
export class GetCharactersCharacterIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdNotifications200Ok {
    /**
    * notification_id integer
    */
    'notificationId': number;
    /**
    * type string
    */
    'type': GetCharactersCharacterIdNotifications200Ok.TypeEnum;
    /**
    * sender_id integer
    */
    'senderId': number;
    /**
    * sender_type string
    */
    'senderType': GetCharactersCharacterIdNotifications200Ok.SenderTypeEnum;
    /**
    * timestamp string
    */
    'timestamp': Date;
    /**
    * is_read boolean
    */
    'isRead': boolean;
    /**
    * text string
    */
    'text': string;
}

export namespace GetCharactersCharacterIdNotifications200Ok {
    export enum TypeEnum {
        AcceptedAlly = <any> 'AcceptedAlly',
        AcceptedSurrender = <any> 'AcceptedSurrender',
        AllAnchoringMsg = <any> 'AllAnchoringMsg',
        AllMaintenanceBillMsg = <any> 'AllMaintenanceBillMsg',
        AllStrucInvulnerableMsg = <any> 'AllStrucInvulnerableMsg',
        AllStructVulnerableMsg = <any> 'AllStructVulnerableMsg',
        AllWarCorpJoinedAllianceMsg = <any> 'AllWarCorpJoinedAllianceMsg',
        AllWarDeclaredMsg = <any> 'AllWarDeclaredMsg',
        AllWarInvalidatedMsg = <any> 'AllWarInvalidatedMsg',
        AllWarRetractedMsg = <any> 'AllWarRetractedMsg',
        AllWarSurrenderMsg = <any> 'AllWarSurrenderMsg',
        AllianceCapitalChanged = <any> 'AllianceCapitalChanged',
        AllyContractCancelled = <any> 'AllyContractCancelled',
        AllyJoinedWarAggressorMsg = <any> 'AllyJoinedWarAggressorMsg',
        AllyJoinedWarAllyMsg = <any> 'AllyJoinedWarAllyMsg',
        AllyJoinedWarDefenderMsg = <any> 'AllyJoinedWarDefenderMsg',
        BattlePunishFriendlyFire = <any> 'BattlePunishFriendlyFire',
        BillOutOfMoneyMsg = <any> 'BillOutOfMoneyMsg',
        BillPaidCorpAllMsg = <any> 'BillPaidCorpAllMsg',
        BountyClaimMsg = <any> 'BountyClaimMsg',
        BountyESSShared = <any> 'BountyESSShared',
        BountyESSTaken = <any> 'BountyESSTaken',
        BountyPlacedAlliance = <any> 'BountyPlacedAlliance',
        BountyPlacedChar = <any> 'BountyPlacedChar',
        BountyPlacedCorp = <any> 'BountyPlacedCorp',
        BountyYourBountyClaimed = <any> 'BountyYourBountyClaimed',
        BuddyConnectContactAdd = <any> 'BuddyConnectContactAdd',
        CharAppAcceptMsg = <any> 'CharAppAcceptMsg',
        CharAppRejectMsg = <any> 'CharAppRejectMsg',
        CharAppWithdrawMsg = <any> 'CharAppWithdrawMsg',
        CharLeftCorpMsg = <any> 'CharLeftCorpMsg',
        CharMedalMsg = <any> 'CharMedalMsg',
        CharTerminationMsg = <any> 'CharTerminationMsg',
        CloneActivationMsg = <any> 'CloneActivationMsg',
        CloneActivationMsg2 = <any> 'CloneActivationMsg2',
        CloneMovedMsg = <any> 'CloneMovedMsg',
        CloneRevokedMsg1 = <any> 'CloneRevokedMsg1',
        CloneRevokedMsg2 = <any> 'CloneRevokedMsg2',
        ContactAdd = <any> 'ContactAdd',
        ContactEdit = <any> 'ContactEdit',
        ContainerPasswordMsg = <any> 'ContainerPasswordMsg',
        CorpAllBillMsg = <any> 'CorpAllBillMsg',
        CorpAppAcceptMsg = <any> 'CorpAppAcceptMsg',
        CorpAppInvitedMsg = <any> 'CorpAppInvitedMsg',
        CorpAppNewMsg = <any> 'CorpAppNewMsg',
        CorpAppRejectCustomMsg = <any> 'CorpAppRejectCustomMsg',
        CorpAppRejectMsg = <any> 'CorpAppRejectMsg',
        CorpDividendMsg = <any> 'CorpDividendMsg',
        CorpFriendlyFireDisableTimerCompleted = <any> 'CorpFriendlyFireDisableTimerCompleted',
        CorpFriendlyFireDisableTimerStarted = <any> 'CorpFriendlyFireDisableTimerStarted',
        CorpFriendlyFireEnableTimerCompleted = <any> 'CorpFriendlyFireEnableTimerCompleted',
        CorpFriendlyFireEnableTimerStarted = <any> 'CorpFriendlyFireEnableTimerStarted',
        CorpKicked = <any> 'CorpKicked',
        CorpLiquidationMsg = <any> 'CorpLiquidationMsg',
        CorpNewCEOMsg = <any> 'CorpNewCEOMsg',
        CorpNewsMsg = <any> 'CorpNewsMsg',
        CorpOfficeExpirationMsg = <any> 'CorpOfficeExpirationMsg',
        CorpStructLostMsg = <any> 'CorpStructLostMsg',
        CorpTaxChangeMsg = <any> 'CorpTaxChangeMsg',
        CorpVoteCEORevokedMsg = <any> 'CorpVoteCEORevokedMsg',
        CorpVoteMsg = <any> 'CorpVoteMsg',
        CorpWarDeclaredMsg = <any> 'CorpWarDeclaredMsg',
        CorpWarFightingLegalMsg = <any> 'CorpWarFightingLegalMsg',
        CorpWarInvalidatedMsg = <any> 'CorpWarInvalidatedMsg',
        CorpWarRetractedMsg = <any> 'CorpWarRetractedMsg',
        CorpWarSurrenderMsg = <any> 'CorpWarSurrenderMsg',
        CustomsMsg = <any> 'CustomsMsg',
        DeclareWar = <any> 'DeclareWar',
        DistrictAttacked = <any> 'DistrictAttacked',
        DustAppAcceptedMsg = <any> 'DustAppAcceptedMsg',
        EntosisCaptureStarted = <any> 'EntosisCaptureStarted',
        FWAllianceKickMsg = <any> 'FWAllianceKickMsg',
        FWAllianceWarningMsg = <any> 'FWAllianceWarningMsg',
        FWCharKickMsg = <any> 'FWCharKickMsg',
        FWCharRankGainMsg = <any> 'FWCharRankGainMsg',
        FWCharRankLossMsg = <any> 'FWCharRankLossMsg',
        FWCharWarningMsg = <any> 'FWCharWarningMsg',
        FWCorpJoinMsg = <any> 'FWCorpJoinMsg',
        FWCorpKickMsg = <any> 'FWCorpKickMsg',
        FWCorpLeaveMsg = <any> 'FWCorpLeaveMsg',
        FWCorpWarningMsg = <any> 'FWCorpWarningMsg',
        FacWarCorpJoinRequestMsg = <any> 'FacWarCorpJoinRequestMsg',
        FacWarCorpJoinWithdrawMsg = <any> 'FacWarCorpJoinWithdrawMsg',
        FacWarCorpLeaveRequestMsg = <any> 'FacWarCorpLeaveRequestMsg',
        FacWarCorpLeaveWithdrawMsg = <any> 'FacWarCorpLeaveWithdrawMsg',
        FacWarLPDisqualifiedEvent = <any> 'FacWarLPDisqualifiedEvent',
        FacWarLPDisqualifiedKill = <any> 'FacWarLPDisqualifiedKill',
        FacWarLPPayoutEvent = <any> 'FacWarLPPayoutEvent',
        FacWarLPPayoutKill = <any> 'FacWarLPPayoutKill',
        GameTimeAdded = <any> 'GameTimeAdded',
        GameTimeReceived = <any> 'GameTimeReceived',
        GameTimeSent = <any> 'GameTimeSent',
        GiftReceived = <any> 'GiftReceived',
        IHubDestroyedByBillFailure = <any> 'IHubDestroyedByBillFailure',
        IncursionCompletedMsg = <any> 'IncursionCompletedMsg',
        IndustryTeamAuctionLost = <any> 'IndustryTeamAuctionLost',
        IndustryTeamAuctionWon = <any> 'IndustryTeamAuctionWon',
        InfrastructureHubBillAboutToExpire = <any> 'InfrastructureHubBillAboutToExpire',
        InsuranceExpirationMsg = <any> 'InsuranceExpirationMsg',
        InsuranceFirstShipMsg = <any> 'InsuranceFirstShipMsg',
        InsuranceInvalidatedMsg = <any> 'InsuranceInvalidatedMsg',
        InsuranceIssuedMsg = <any> 'InsuranceIssuedMsg',
        InsurancePayoutMsg = <any> 'InsurancePayoutMsg',
        JumpCloneDeletedMsg1 = <any> 'JumpCloneDeletedMsg1',
        JumpCloneDeletedMsg2 = <any> 'JumpCloneDeletedMsg2',
        KillReportFinalBlow = <any> 'KillReportFinalBlow',
        KillReportVictim = <any> 'KillReportVictim',
        KillRightAvailable = <any> 'KillRightAvailable',
        KillRightAvailableOpen = <any> 'KillRightAvailableOpen',
        KillRightEarned = <any> 'KillRightEarned',
        KillRightUnavailable = <any> 'KillRightUnavailable',
        KillRightUnavailableOpen = <any> 'KillRightUnavailableOpen',
        KillRightUsed = <any> 'KillRightUsed',
        LocateCharMsg = <any> 'LocateCharMsg',
        MadeWarMutual = <any> 'MadeWarMutual',
        MercOfferedNegotiationMsg = <any> 'MercOfferedNegotiationMsg',
        MissionOfferExpirationMsg = <any> 'MissionOfferExpirationMsg',
        MissionTimeoutMsg = <any> 'MissionTimeoutMsg',
        MoonminingAutomaticFracture = <any> 'MoonminingAutomaticFracture',
        MoonminingExtractionCancelled = <any> 'MoonminingExtractionCancelled',
        MoonminingExtractionFinished = <any> 'MoonminingExtractionFinished',
        MoonminingLaserFired = <any> 'MoonminingLaserFired',
        NPCStandingsGained = <any> 'NPCStandingsGained',
        NPCStandingsLost = <any> 'NPCStandingsLost',
        OfferedSurrender = <any> 'OfferedSurrender',
        OfferedToAlly = <any> 'OfferedToAlly',
        OldLscMessages = <any> 'OldLscMessages',
        OperationFinished = <any> 'OperationFinished',
        OrbitalAttacked = <any> 'OrbitalAttacked',
        OrbitalReinforced = <any> 'OrbitalReinforced',
        OwnershipTransferred = <any> 'OwnershipTransferred',
        ReimbursementMsg = <any> 'ReimbursementMsg',
        ResearchMissionAvailableMsg = <any> 'ResearchMissionAvailableMsg',
        RetractsWar = <any> 'RetractsWar',
        SeasonalChallengeCompleted = <any> 'SeasonalChallengeCompleted',
        SovAllClaimAquiredMsg = <any> 'SovAllClaimAquiredMsg',
        SovAllClaimLostMsg = <any> 'SovAllClaimLostMsg',
        SovCommandNodeEventStarted = <any> 'SovCommandNodeEventStarted',
        SovCorpBillLateMsg = <any> 'SovCorpBillLateMsg',
        SovCorpClaimFailMsg = <any> 'SovCorpClaimFailMsg',
        SovDisruptorMsg = <any> 'SovDisruptorMsg',
        SovStationEnteredFreeport = <any> 'SovStationEnteredFreeport',
        SovStructureDestroyed = <any> 'SovStructureDestroyed',
        SovStructureReinforced = <any> 'SovStructureReinforced',
        SovStructureSelfDestructCancel = <any> 'SovStructureSelfDestructCancel',
        SovStructureSelfDestructFinished = <any> 'SovStructureSelfDestructFinished',
        SovStructureSelfDestructRequested = <any> 'SovStructureSelfDestructRequested',
        SovereigntyIHDamageMsg = <any> 'SovereigntyIHDamageMsg',
        SovereigntySBUDamageMsg = <any> 'SovereigntySBUDamageMsg',
        SovereigntyTCUDamageMsg = <any> 'SovereigntyTCUDamageMsg',
        StationAggressionMsg1 = <any> 'StationAggressionMsg1',
        StationAggressionMsg2 = <any> 'StationAggressionMsg2',
        StationConquerMsg = <any> 'StationConquerMsg',
        StationServiceDisabled = <any> 'StationServiceDisabled',
        StationServiceEnabled = <any> 'StationServiceEnabled',
        StationStateChangeMsg = <any> 'StationStateChangeMsg',
        StoryLineMissionAvailableMsg = <any> 'StoryLineMissionAvailableMsg',
        StructureAnchoring = <any> 'StructureAnchoring',
        StructureCourierContractChanged = <any> 'StructureCourierContractChanged',
        StructureDestroyed = <any> 'StructureDestroyed',
        StructureFuelAlert = <any> 'StructureFuelAlert',
        StructureItemsDelivered = <any> 'StructureItemsDelivered',
        StructureLostArmor = <any> 'StructureLostArmor',
        StructureLostShields = <any> 'StructureLostShields',
        StructureOnline = <any> 'StructureOnline',
        StructureServicesOffline = <any> 'StructureServicesOffline',
        StructureUnanchoring = <any> 'StructureUnanchoring',
        StructureUnderAttack = <any> 'StructureUnderAttack',
        TowerAlertMsg = <any> 'TowerAlertMsg',
        TowerResourceAlertMsg = <any> 'TowerResourceAlertMsg',
        TransactionReversalMsg = <any> 'TransactionReversalMsg',
        TutorialMsg = <any> 'TutorialMsg',
        WarAllyOfferDeclinedMsg = <any> 'WarAllyOfferDeclinedMsg',
        WarSurrenderDeclinedMsg = <any> 'WarSurrenderDeclinedMsg',
        WarSurrenderOfferMsg = <any> 'WarSurrenderOfferMsg',
        NotificationTypeMoonminingExtractionStarted = <any> 'notificationTypeMoonminingExtractionStarted'
    }
    export enum SenderTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction',
        Other = <any> 'other'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdNotificationsContacts200Ok {
    /**
    * notification_id integer
    */
    'notificationId': number;
    /**
    * send_date string
    */
    'sendDate': Date;
    /**
    * A number representing the standing level the receiver has been added at by the sender. The standing levels are as follows: -10 -> Terrible | -5 -> Bad |  0 -> Neutral |  5 -> Good |  10 -> Excellent
    */
    'standingLevel': number;
    /**
    * message string
    */
    'message': string;
    /**
    * sender_character_id integer
    */
    'senderCharacterId': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdOk {
    /**
    * name string
    */
    'name': string;
    /**
    * description string
    */
    'description': string;
    /**
    * The character's corporation ID
    */
    'corporationId': number;
    /**
    * The character's alliance ID
    */
    'allianceId': number;
    /**
    * Creation date of the character
    */
    'birthday': Date;
    /**
    * gender string
    */
    'gender': GetCharactersCharacterIdOk.GenderEnum;
    /**
    * race_id integer
    */
    'raceId': number;
    /**
    * bloodline_id integer
    */
    'bloodlineId': number;
    /**
    * ancestry_id integer
    */
    'ancestryId': number;
    /**
    * security_status number
    */
    'securityStatus': number;
    /**
    * ID of the faction the character is fighting for, if the character is enlisted in Factional Warfare
    */
    'factionId': number;
}

export namespace GetCharactersCharacterIdOk {
    export enum GenderEnum {
        Female = <any> 'female',
        Male = <any> 'male'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdOnlineOk {
    /**
    * If the character is online
    */
    'online': boolean;
    /**
    * Timestamp of the last login
    */
    'lastLogin': Date;
    /**
    * Timestamp of the last logout
    */
    'lastLogout': Date;
    /**
    * Total number of times the character has logged in
    */
    'logins': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdOpportunities200Ok {
    /**
    * task_id integer
    */
    'taskId': number;
    /**
    * completed_at string
    */
    'completedAt': Date;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdOrders200Ok {
    /**
    * Unique order ID
    */
    'orderId': number;
    /**
    * The type ID of the item transacted in this order
    */
    'typeId': number;
    /**
    * ID of the region where order was placed
    */
    'regionId': number;
    /**
    * ID of the location where order was placed
    */
    'locationId': number;
    /**
    * Valid order range, numbers are ranges in jumps
    */
    'range': GetCharactersCharacterIdOrders200Ok.RangeEnum;
    /**
    * True for a bid (buy) order. False for an offer (sell) order
    */
    'isBuyOrder': boolean;
    /**
    * Cost per unit for this order
    */
    'price': number;
    /**
    * Quantity of items required or offered at time order was placed
    */
    'volumeTotal': number;
    /**
    * Quantity of items still required or offered
    */
    'volumeRemain': number;
    /**
    * Date and time when this order was issued
    */
    'issued': Date;
    /**
    * Current order state
    */
    'state': GetCharactersCharacterIdOrders200Ok.StateEnum;
    /**
    * For bids (buy orders), the minimum quantity that will be accepted in a matching offer (sell order)
    */
    'minVolume': number;
    /**
    * Wallet division for the buyer or seller of this order. Always 1000 for characters. Currently 1000 through 1006 for corporations
    */
    'accountId': number;
    /**
    * Numer of days for which order is valid (starting from the issued date). An order expires at time issued + duration
    */
    'duration': number;
    /**
    * is_corp boolean
    */
    'isCorp': boolean;
    /**
    * For buy orders, the amount of ISK in escrow
    */
    'escrow': number;
}

export namespace GetCharactersCharacterIdOrders200Ok {
    export enum RangeEnum {
        _1 = <any> '1',
        _10 = <any> '10',
        _2 = <any> '2',
        _20 = <any> '20',
        _3 = <any> '3',
        _30 = <any> '30',
        _4 = <any> '4',
        _40 = <any> '40',
        _5 = <any> '5',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        Station = <any> 'station'
    }
    export enum StateEnum {
        Cancelled = <any> 'cancelled',
        CharacterDeleted = <any> 'character_deleted',
        Closed = <any> 'closed',
        Expired = <any> 'expired',
        Open = <any> 'open',
        Pending = <any> 'pending'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdPlanets200Ok {
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * planet_id integer
    */
    'planetId': number;
    /**
    * owner_id integer
    */
    'ownerId': number;
    /**
    * upgrade_level integer
    */
    'upgradeLevel': number;
    /**
    * num_pins integer
    */
    'numPins': number;
    /**
    * last_update string
    */
    'lastUpdate': Date;
    /**
    * planet_type string
    */
    'planetType': GetCharactersCharacterIdPlanets200Ok.PlanetTypeEnum;
}

export namespace GetCharactersCharacterIdPlanets200Ok {
    export enum PlanetTypeEnum {
        Temperate = <any> 'temperate',
        Barren = <any> 'barren',
        Oceanic = <any> 'oceanic',
        Ice = <any> 'ice',
        Gas = <any> 'gas',
        Lava = <any> 'lava',
        Storm = <any> 'storm',
        Plasma = <any> 'plasma'
    }
}
/**
* content object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdContent {
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * amount integer
    */
    'amount': number;
}

/**
* extractor_details object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails {
    /**
    * heads array
    */
    'heads': Array<GetCharactersCharacterIdPlanetsPlanetIdHead>;
    /**
    * product_type_id integer
    */
    'productTypeId': number;
    /**
    * in seconds
    */
    'cycleTime': number;
    /**
    * head_radius number
    */
    'headRadius': number;
    /**
    * qty_per_cycle integer
    */
    'qtyPerCycle': number;
}

/**
* factory_details object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails {
    /**
    * schematic_id integer
    */
    'schematicId': number;
}

/**
* head object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdHead {
    /**
    * head_id integer
    */
    'headId': number;
    /**
    * latitude number
    */
    'latitude': number;
    /**
    * longitude number
    */
    'longitude': number;
}

/**
* link object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdLink {
    /**
    * source_pin_id integer
    */
    'sourcePinId': number;
    /**
    * destination_pin_id integer
    */
    'destinationPinId': number;
    /**
    * link_level integer
    */
    'linkLevel': number;
}

/**
* Colony not found
*/
export class GetCharactersCharacterIdPlanetsPlanetIdNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdOk {
    /**
    * links array
    */
    'links': Array<GetCharactersCharacterIdPlanetsPlanetIdLink>;
    /**
    * pins array
    */
    'pins': Array<GetCharactersCharacterIdPlanetsPlanetIdPin>;
    /**
    * routes array
    */
    'routes': Array<GetCharactersCharacterIdPlanetsPlanetIdRoute>;
}

/**
* pin object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdPin {
    /**
    * latitude number
    */
    'latitude': number;
    /**
    * longitude number
    */
    'longitude': number;
    /**
    * pin_id integer
    */
    'pinId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * schematic_id integer
    */
    'schematicId': number;
    'extractorDetails': GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails;
    'factoryDetails': GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails;
    /**
    * contents array
    */
    'contents': Array<GetCharactersCharacterIdPlanetsPlanetIdContent>;
    /**
    * install_time string
    */
    'installTime': Date;
    /**
    * expiry_time string
    */
    'expiryTime': Date;
    /**
    * last_cycle_start string
    */
    'lastCycleStart': Date;
}

/**
* route object
*/
export class GetCharactersCharacterIdPlanetsPlanetIdRoute {
    /**
    * route_id integer
    */
    'routeId': number;
    /**
    * source_pin_id integer
    */
    'sourcePinId': number;
    /**
    * destination_pin_id integer
    */
    'destinationPinId': number;
    /**
    * content_type_id integer
    */
    'contentTypeId': number;
    /**
    * quantity number
    */
    'quantity': number;
    /**
    * list of pin ID waypoints
    */
    'waypoints': Array<number>;
}

/**
* No image server for this datasource
*/
export class GetCharactersCharacterIdPortraitNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdPortraitOk {
    /**
    * px64x64 string
    */
    'px64x64': string;
    /**
    * px128x128 string
    */
    'px128x128': string;
    /**
    * px256x256 string
    */
    'px256x256': string;
    /**
    * px512x512 string
    */
    'px512x512': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdRolesOk {
    /**
    * roles array
    */
    'roles': Array<GetCharactersCharacterIdRolesOk.RolesEnum>;
    /**
    * roles_at_hq array
    */
    'rolesAtHq': Array<GetCharactersCharacterIdRolesOk.RolesAtHqEnum>;
    /**
    * roles_at_base array
    */
    'rolesAtBase': Array<GetCharactersCharacterIdRolesOk.RolesAtBaseEnum>;
    /**
    * roles_at_other array
    */
    'rolesAtOther': Array<GetCharactersCharacterIdRolesOk.RolesAtOtherEnum>;
}

export namespace GetCharactersCharacterIdRolesOk {
    export enum RolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum RolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum RolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum RolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
}
/**
* 200 ok object
*/
export class GetCharactersCharacterIdSearchOk {
    /**
    * agent array
    */
    'agent': Array<number>;
    /**
    * alliance array
    */
    'alliance': Array<number>;
    /**
    * character array
    */
    'character': Array<number>;
    /**
    * constellation array
    */
    'constellation': Array<number>;
    /**
    * corporation array
    */
    'corporation': Array<number>;
    /**
    * faction array
    */
    'faction': Array<number>;
    /**
    * inventory_type array
    */
    'inventoryType': Array<number>;
    /**
    * region array
    */
    'region': Array<number>;
    /**
    * solar_system array
    */
    'solarSystem': Array<number>;
    /**
    * station array
    */
    'station': Array<number>;
    /**
    * structure array
    */
    'structure': Array<number>;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdShipOk {
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;
    /**
    * Item id's are unique to a ship and persist until it is repackaged. This value can be used to track repeated uses of a ship, or detect when a pilot changes into a different instance of the same ship type.
    */
    'shipItemId': number;
    /**
    * ship_name string
    */
    'shipName': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdSkillqueue200Ok {
    /**
    * skill_id integer
    */
    'skillId': number;
    /**
    * finish_date string
    */
    'finishDate': Date;
    /**
    * start_date string
    */
    'startDate': Date;
    /**
    * finished_level integer
    */
    'finishedLevel': number;
    /**
    * queue_position integer
    */
    'queuePosition': number;
    /**
    * training_start_sp integer
    */
    'trainingStartSp': number;
    /**
    * level_end_sp integer
    */
    'levelEndSp': number;
    /**
    * Amount of SP that was in the skill when it started training it's current level. Used to calculate % of current level complete.
    */
    'levelStartSp': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdSkillsOk {
    /**
    * skills array
    */
    'skills': Array<GetCharactersCharacterIdSkillsSkill>;
    /**
    * total_sp integer
    */
    'totalSp': number;
    /**
    * Skill points available to be assigned
    */
    'unallocatedSp': number;
}

/**
* skill object
*/
export class GetCharactersCharacterIdSkillsSkill {
    /**
    * skill_id integer
    */
    'skillId': number;
    /**
    * skillpoints_in_skill integer
    */
    'skillpointsInSkill': number;
    /**
    * trained_skill_level integer
    */
    'trainedSkillLevel': number;
    /**
    * active_skill_level integer
    */
    'activeSkillLevel': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdStandings200Ok {
    /**
    * from_id integer
    */
    'fromId': number;
    /**
    * from_type string
    */
    'fromType': GetCharactersCharacterIdStandings200Ok.FromTypeEnum;
    /**
    * standing number
    */
    'standing': number;
}

export namespace GetCharactersCharacterIdStandings200Ok {
    export enum FromTypeEnum {
        Agent = <any> 'agent',
        NpcCorp = <any> 'npc_corp',
        Faction = <any> 'faction'
    }
}
/**
* Aggregate stats for a year
*/
export class GetCharactersCharacterIdStats200Ok {
    /**
    * Gregorian year for this set of aggregates
    */
    'year': number;
    'character': GetCharactersCharacterIdStatsCharacter;
    'combat': GetCharactersCharacterIdStatsCombat;
    'industry': GetCharactersCharacterIdStatsIndustry;
    'inventory': GetCharactersCharacterIdStatsInventory;
    'isk': GetCharactersCharacterIdStatsIsk;
    'market': GetCharactersCharacterIdStatsMarket;
    'mining': GetCharactersCharacterIdStatsMining;
    'module': GetCharactersCharacterIdStatsModule;
    'orbital': GetCharactersCharacterIdStatsOrbital;
    'pve': GetCharactersCharacterIdStatsPve;
    'social': GetCharactersCharacterIdStatsSocial;
    'travel': GetCharactersCharacterIdStatsTravel;
}

/**
* character object
*/
export class GetCharactersCharacterIdStatsCharacter {
    /**
    * days_of_activity integer
    */
    'daysOfActivity': number;
    /**
    * minutes integer
    */
    'minutes': number;
    /**
    * sessions_started integer
    */
    'sessionsStarted': number;
}

/**
* combat object
*/
export class GetCharactersCharacterIdStatsCombat {
    /**
    * cap_drainedby_npc integer
    */
    'capDrainedbyNpc': number;
    /**
    * cap_drainedby_pc integer
    */
    'capDrainedbyPc': number;
    /**
    * cap_draining_pc integer
    */
    'capDrainingPc': number;
    /**
    * criminal_flag_set integer
    */
    'criminalFlagSet': number;
    /**
    * damage_from_np_cs_amount integer
    */
    'damageFromNpCsAmount': number;
    /**
    * damage_from_np_cs_num_shots integer
    */
    'damageFromNpCsNumShots': number;
    /**
    * damage_from_players_bomb_amount integer
    */
    'damageFromPlayersBombAmount': number;
    /**
    * damage_from_players_bomb_num_shots integer
    */
    'damageFromPlayersBombNumShots': number;
    /**
    * damage_from_players_combat_drone_amount integer
    */
    'damageFromPlayersCombatDroneAmount': number;
    /**
    * damage_from_players_combat_drone_num_shots integer
    */
    'damageFromPlayersCombatDroneNumShots': number;
    /**
    * damage_from_players_energy_amount integer
    */
    'damageFromPlayersEnergyAmount': number;
    /**
    * damage_from_players_energy_num_shots integer
    */
    'damageFromPlayersEnergyNumShots': number;
    /**
    * damage_from_players_fighter_bomber_amount integer
    */
    'damageFromPlayersFighterBomberAmount': number;
    /**
    * damage_from_players_fighter_bomber_num_shots integer
    */
    'damageFromPlayersFighterBomberNumShots': number;
    /**
    * damage_from_players_fighter_drone_amount integer
    */
    'damageFromPlayersFighterDroneAmount': number;
    /**
    * damage_from_players_fighter_drone_num_shots integer
    */
    'damageFromPlayersFighterDroneNumShots': number;
    /**
    * damage_from_players_hybrid_amount integer
    */
    'damageFromPlayersHybridAmount': number;
    /**
    * damage_from_players_hybrid_num_shots integer
    */
    'damageFromPlayersHybridNumShots': number;
    /**
    * damage_from_players_missile_amount integer
    */
    'damageFromPlayersMissileAmount': number;
    /**
    * damage_from_players_missile_num_shots integer
    */
    'damageFromPlayersMissileNumShots': number;
    /**
    * damage_from_players_projectile_amount integer
    */
    'damageFromPlayersProjectileAmount': number;
    /**
    * damage_from_players_projectile_num_shots integer
    */
    'damageFromPlayersProjectileNumShots': number;
    /**
    * damage_from_players_smart_bomb_amount integer
    */
    'damageFromPlayersSmartBombAmount': number;
    /**
    * damage_from_players_smart_bomb_num_shots integer
    */
    'damageFromPlayersSmartBombNumShots': number;
    /**
    * damage_from_players_super_amount integer
    */
    'damageFromPlayersSuperAmount': number;
    /**
    * damage_from_players_super_num_shots integer
    */
    'damageFromPlayersSuperNumShots': number;
    /**
    * damage_from_structures_total_amount integer
    */
    'damageFromStructuresTotalAmount': number;
    /**
    * damage_from_structures_total_num_shots integer
    */
    'damageFromStructuresTotalNumShots': number;
    /**
    * damage_to_players_bomb_amount integer
    */
    'damageToPlayersBombAmount': number;
    /**
    * damage_to_players_bomb_num_shots integer
    */
    'damageToPlayersBombNumShots': number;
    /**
    * damage_to_players_combat_drone_amount integer
    */
    'damageToPlayersCombatDroneAmount': number;
    /**
    * damage_to_players_combat_drone_num_shots integer
    */
    'damageToPlayersCombatDroneNumShots': number;
    /**
    * damage_to_players_energy_amount integer
    */
    'damageToPlayersEnergyAmount': number;
    /**
    * damage_to_players_energy_num_shots integer
    */
    'damageToPlayersEnergyNumShots': number;
    /**
    * damage_to_players_fighter_bomber_amount integer
    */
    'damageToPlayersFighterBomberAmount': number;
    /**
    * damage_to_players_fighter_bomber_num_shots integer
    */
    'damageToPlayersFighterBomberNumShots': number;
    /**
    * damage_to_players_fighter_drone_amount integer
    */
    'damageToPlayersFighterDroneAmount': number;
    /**
    * damage_to_players_fighter_drone_num_shots integer
    */
    'damageToPlayersFighterDroneNumShots': number;
    /**
    * damage_to_players_hybrid_amount integer
    */
    'damageToPlayersHybridAmount': number;
    /**
    * damage_to_players_hybrid_num_shots integer
    */
    'damageToPlayersHybridNumShots': number;
    /**
    * damage_to_players_missile_amount integer
    */
    'damageToPlayersMissileAmount': number;
    /**
    * damage_to_players_missile_num_shots integer
    */
    'damageToPlayersMissileNumShots': number;
    /**
    * damage_to_players_projectile_amount integer
    */
    'damageToPlayersProjectileAmount': number;
    /**
    * damage_to_players_projectile_num_shots integer
    */
    'damageToPlayersProjectileNumShots': number;
    /**
    * damage_to_players_smart_bomb_amount integer
    */
    'damageToPlayersSmartBombAmount': number;
    /**
    * damage_to_players_smart_bomb_num_shots integer
    */
    'damageToPlayersSmartBombNumShots': number;
    /**
    * damage_to_players_super_amount integer
    */
    'damageToPlayersSuperAmount': number;
    /**
    * damage_to_players_super_num_shots integer
    */
    'damageToPlayersSuperNumShots': number;
    /**
    * damage_to_structures_total_amount integer
    */
    'damageToStructuresTotalAmount': number;
    /**
    * damage_to_structures_total_num_shots integer
    */
    'damageToStructuresTotalNumShots': number;
    /**
    * deaths_high_sec integer
    */
    'deathsHighSec': number;
    /**
    * deaths_low_sec integer
    */
    'deathsLowSec': number;
    /**
    * deaths_null_sec integer
    */
    'deathsNullSec': number;
    /**
    * deaths_pod_high_sec integer
    */
    'deathsPodHighSec': number;
    /**
    * deaths_pod_low_sec integer
    */
    'deathsPodLowSec': number;
    /**
    * deaths_pod_null_sec integer
    */
    'deathsPodNullSec': number;
    /**
    * deaths_pod_wormhole integer
    */
    'deathsPodWormhole': number;
    /**
    * deaths_wormhole integer
    */
    'deathsWormhole': number;
    /**
    * drone_engage integer
    */
    'droneEngage': number;
    /**
    * dscans integer
    */
    'dscans': number;
    /**
    * duel_requested integer
    */
    'duelRequested': number;
    /**
    * engagement_register integer
    */
    'engagementRegister': number;
    /**
    * kills_assists integer
    */
    'killsAssists': number;
    /**
    * kills_high_sec integer
    */
    'killsHighSec': number;
    /**
    * kills_low_sec integer
    */
    'killsLowSec': number;
    /**
    * kills_null_sec integer
    */
    'killsNullSec': number;
    /**
    * kills_pod_high_sec integer
    */
    'killsPodHighSec': number;
    /**
    * kills_pod_low_sec integer
    */
    'killsPodLowSec': number;
    /**
    * kills_pod_null_sec integer
    */
    'killsPodNullSec': number;
    /**
    * kills_pod_wormhole integer
    */
    'killsPodWormhole': number;
    /**
    * kills_wormhole integer
    */
    'killsWormhole': number;
    /**
    * npc_flag_set integer
    */
    'npcFlagSet': number;
    /**
    * probe_scans integer
    */
    'probeScans': number;
    /**
    * pvp_flag_set integer
    */
    'pvpFlagSet': number;
    /**
    * repair_armor_by_remote_amount integer
    */
    'repairArmorByRemoteAmount': number;
    /**
    * repair_armor_remote_amount integer
    */
    'repairArmorRemoteAmount': number;
    /**
    * repair_armor_self_amount integer
    */
    'repairArmorSelfAmount': number;
    /**
    * repair_capacitor_by_remote_amount integer
    */
    'repairCapacitorByRemoteAmount': number;
    /**
    * repair_capacitor_remote_amount integer
    */
    'repairCapacitorRemoteAmount': number;
    /**
    * repair_capacitor_self_amount integer
    */
    'repairCapacitorSelfAmount': number;
    /**
    * repair_hull_by_remote_amount integer
    */
    'repairHullByRemoteAmount': number;
    /**
    * repair_hull_remote_amount integer
    */
    'repairHullRemoteAmount': number;
    /**
    * repair_hull_self_amount integer
    */
    'repairHullSelfAmount': number;
    /**
    * repair_shield_by_remote_amount integer
    */
    'repairShieldByRemoteAmount': number;
    /**
    * repair_shield_remote_amount integer
    */
    'repairShieldRemoteAmount': number;
    /**
    * repair_shield_self_amount integer
    */
    'repairShieldSelfAmount': number;
    /**
    * self_destructs integer
    */
    'selfDestructs': number;
    /**
    * warp_scramble_pc integer
    */
    'warpScramblePc': number;
    /**
    * warp_scrambledby_npc integer
    */
    'warpScrambledbyNpc': number;
    /**
    * warp_scrambledby_pc integer
    */
    'warpScrambledbyPc': number;
    /**
    * weapon_flag_set integer
    */
    'weaponFlagSet': number;
    /**
    * webifiedby_npc integer
    */
    'webifiedbyNpc': number;
    /**
    * webifiedby_pc integer
    */
    'webifiedbyPc': number;
    /**
    * webifying_pc integer
    */
    'webifyingPc': number;
}

/**
* industry object
*/
export class GetCharactersCharacterIdStatsIndustry {
    /**
    * hacking_successes integer
    */
    'hackingSuccesses': number;
    /**
    * jobs_cancelled integer
    */
    'jobsCancelled': number;
    /**
    * jobs_completed_copy_blueprint integer
    */
    'jobsCompletedCopyBlueprint': number;
    /**
    * jobs_completed_invention integer
    */
    'jobsCompletedInvention': number;
    /**
    * jobs_completed_manufacture integer
    */
    'jobsCompletedManufacture': number;
    /**
    * jobs_completed_manufacture_asteroid integer
    */
    'jobsCompletedManufactureAsteroid': number;
    /**
    * jobs_completed_manufacture_asteroid_quantity integer
    */
    'jobsCompletedManufactureAsteroidQuantity': number;
    /**
    * jobs_completed_manufacture_charge integer
    */
    'jobsCompletedManufactureCharge': number;
    /**
    * jobs_completed_manufacture_charge_quantity integer
    */
    'jobsCompletedManufactureChargeQuantity': number;
    /**
    * jobs_completed_manufacture_commodity integer
    */
    'jobsCompletedManufactureCommodity': number;
    /**
    * jobs_completed_manufacture_commodity_quantity integer
    */
    'jobsCompletedManufactureCommodityQuantity': number;
    /**
    * jobs_completed_manufacture_deployable integer
    */
    'jobsCompletedManufactureDeployable': number;
    /**
    * jobs_completed_manufacture_deployable_quantity integer
    */
    'jobsCompletedManufactureDeployableQuantity': number;
    /**
    * jobs_completed_manufacture_drone integer
    */
    'jobsCompletedManufactureDrone': number;
    /**
    * jobs_completed_manufacture_drone_quantity integer
    */
    'jobsCompletedManufactureDroneQuantity': number;
    /**
    * jobs_completed_manufacture_implant integer
    */
    'jobsCompletedManufactureImplant': number;
    /**
    * jobs_completed_manufacture_implant_quantity integer
    */
    'jobsCompletedManufactureImplantQuantity': number;
    /**
    * jobs_completed_manufacture_module integer
    */
    'jobsCompletedManufactureModule': number;
    /**
    * jobs_completed_manufacture_module_quantity integer
    */
    'jobsCompletedManufactureModuleQuantity': number;
    /**
    * jobs_completed_manufacture_other integer
    */
    'jobsCompletedManufactureOther': number;
    /**
    * jobs_completed_manufacture_other_quantity integer
    */
    'jobsCompletedManufactureOtherQuantity': number;
    /**
    * jobs_completed_manufacture_ship integer
    */
    'jobsCompletedManufactureShip': number;
    /**
    * jobs_completed_manufacture_ship_quantity integer
    */
    'jobsCompletedManufactureShipQuantity': number;
    /**
    * jobs_completed_manufacture_structure integer
    */
    'jobsCompletedManufactureStructure': number;
    /**
    * jobs_completed_manufacture_structure_quantity integer
    */
    'jobsCompletedManufactureStructureQuantity': number;
    /**
    * jobs_completed_manufacture_subsystem integer
    */
    'jobsCompletedManufactureSubsystem': number;
    /**
    * jobs_completed_manufacture_subsystem_quantity integer
    */
    'jobsCompletedManufactureSubsystemQuantity': number;
    /**
    * jobs_completed_material_productivity integer
    */
    'jobsCompletedMaterialProductivity': number;
    /**
    * jobs_completed_time_productivity integer
    */
    'jobsCompletedTimeProductivity': number;
    /**
    * jobs_started_copy_blueprint integer
    */
    'jobsStartedCopyBlueprint': number;
    /**
    * jobs_started_invention integer
    */
    'jobsStartedInvention': number;
    /**
    * jobs_started_manufacture integer
    */
    'jobsStartedManufacture': number;
    /**
    * jobs_started_material_productivity integer
    */
    'jobsStartedMaterialProductivity': number;
    /**
    * jobs_started_time_productivity integer
    */
    'jobsStartedTimeProductivity': number;
    /**
    * reprocess_item integer
    */
    'reprocessItem': number;
    /**
    * reprocess_item_quantity integer
    */
    'reprocessItemQuantity': number;
}

/**
* inventory object
*/
export class GetCharactersCharacterIdStatsInventory {
    /**
    * abandon_loot_quantity integer
    */
    'abandonLootQuantity': number;
    /**
    * trash_item_quantity integer
    */
    'trashItemQuantity': number;
}

/**
* isk object
*/
export class GetCharactersCharacterIdStatsIsk {
    /**
    * in integer
    */
    'in': number;
    /**
    * out integer
    */
    'out': number;
}

/**
* market object
*/
export class GetCharactersCharacterIdStatsMarket {
    /**
    * accept_contracts_courier integer
    */
    'acceptContractsCourier': number;
    /**
    * accept_contracts_item_exchange integer
    */
    'acceptContractsItemExchange': number;
    /**
    * buy_orders_placed integer
    */
    'buyOrdersPlaced': number;
    /**
    * cancel_market_order integer
    */
    'cancelMarketOrder': number;
    /**
    * create_contracts_auction integer
    */
    'createContractsAuction': number;
    /**
    * create_contracts_courier integer
    */
    'createContractsCourier': number;
    /**
    * create_contracts_item_exchange integer
    */
    'createContractsItemExchange': number;
    /**
    * deliver_courier_contract integer
    */
    'deliverCourierContract': number;
    /**
    * isk_gained integer
    */
    'iskGained': number;
    /**
    * isk_spent integer
    */
    'iskSpent': number;
    /**
    * modify_market_order integer
    */
    'modifyMarketOrder': number;
    /**
    * search_contracts integer
    */
    'searchContracts': number;
    /**
    * sell_orders_placed integer
    */
    'sellOrdersPlaced': number;
}

/**
* mining object
*/
export class GetCharactersCharacterIdStatsMining {
    /**
    * drone_mine integer
    */
    'droneMine': number;
    /**
    * ore_arkonor integer
    */
    'oreArkonor': number;
    /**
    * ore_bistot integer
    */
    'oreBistot': number;
    /**
    * ore_crokite integer
    */
    'oreCrokite': number;
    /**
    * ore_dark_ochre integer
    */
    'oreDarkOchre': number;
    /**
    * ore_gneiss integer
    */
    'oreGneiss': number;
    /**
    * ore_harvestable_cloud integer
    */
    'oreHarvestableCloud': number;
    /**
    * ore_hedbergite integer
    */
    'oreHedbergite': number;
    /**
    * ore_hemorphite integer
    */
    'oreHemorphite': number;
    /**
    * ore_ice integer
    */
    'oreIce': number;
    /**
    * ore_jaspet integer
    */
    'oreJaspet': number;
    /**
    * ore_kernite integer
    */
    'oreKernite': number;
    /**
    * ore_mercoxit integer
    */
    'oreMercoxit': number;
    /**
    * ore_omber integer
    */
    'oreOmber': number;
    /**
    * ore_plagioclase integer
    */
    'orePlagioclase': number;
    /**
    * ore_pyroxeres integer
    */
    'orePyroxeres': number;
    /**
    * ore_scordite integer
    */
    'oreScordite': number;
    /**
    * ore_spodumain integer
    */
    'oreSpodumain': number;
    /**
    * ore_veldspar integer
    */
    'oreVeldspar': number;
}

/**
* module object
*/
export class GetCharactersCharacterIdStatsModule {
    /**
    * activations_armor_hardener integer
    */
    'activationsArmorHardener': number;
    /**
    * activations_armor_repair_unit integer
    */
    'activationsArmorRepairUnit': number;
    /**
    * activations_armor_resistance_shift_hardener integer
    */
    'activationsArmorResistanceShiftHardener': number;
    /**
    * activations_automated_targeting_system integer
    */
    'activationsAutomatedTargetingSystem': number;
    /**
    * activations_bastion integer
    */
    'activationsBastion': number;
    /**
    * activations_bomb_launcher integer
    */
    'activationsBombLauncher': number;
    /**
    * activations_capacitor_booster integer
    */
    'activationsCapacitorBooster': number;
    /**
    * activations_cargo_scanner integer
    */
    'activationsCargoScanner': number;
    /**
    * activations_cloaking_device integer
    */
    'activationsCloakingDevice': number;
    /**
    * activations_clone_vat_bay integer
    */
    'activationsCloneVatBay': number;
    /**
    * activations_cynosural_field integer
    */
    'activationsCynosuralField': number;
    /**
    * activations_damage_control integer
    */
    'activationsDamageControl': number;
    /**
    * activations_data_miners integer
    */
    'activationsDataMiners': number;
    /**
    * activations_drone_control_unit integer
    */
    'activationsDroneControlUnit': number;
    /**
    * activations_drone_tracking_modules integer
    */
    'activationsDroneTrackingModules': number;
    /**
    * activations_eccm integer
    */
    'activationsEccm': number;
    /**
    * activations_ecm integer
    */
    'activationsEcm': number;
    /**
    * activations_ecm_burst integer
    */
    'activationsEcmBurst': number;
    /**
    * activations_energy_destabilizer integer
    */
    'activationsEnergyDestabilizer': number;
    /**
    * activations_energy_vampire integer
    */
    'activationsEnergyVampire': number;
    /**
    * activations_energy_weapon integer
    */
    'activationsEnergyWeapon': number;
    /**
    * activations_festival_launcher integer
    */
    'activationsFestivalLauncher': number;
    /**
    * activations_frequency_mining_laser integer
    */
    'activationsFrequencyMiningLaser': number;
    /**
    * activations_fueled_armor_repairer integer
    */
    'activationsFueledArmorRepairer': number;
    /**
    * activations_fueled_shield_booster integer
    */
    'activationsFueledShieldBooster': number;
    /**
    * activations_gang_coordinator integer
    */
    'activationsGangCoordinator': number;
    /**
    * activations_gas_cloud_harvester integer
    */
    'activationsGasCloudHarvester': number;
    /**
    * activations_hull_repair_unit integer
    */
    'activationsHullRepairUnit': number;
    /**
    * activations_hybrid_weapon integer
    */
    'activationsHybridWeapon': number;
    /**
    * activations_industrial_core integer
    */
    'activationsIndustrialCore': number;
    /**
    * activations_interdiction_sphere_launcher integer
    */
    'activationsInterdictionSphereLauncher': number;
    /**
    * activations_micro_jump_drive integer
    */
    'activationsMicroJumpDrive': number;
    /**
    * activations_mining_laser integer
    */
    'activationsMiningLaser': number;
    /**
    * activations_missile_launcher integer
    */
    'activationsMissileLauncher': number;
    /**
    * activations_passive_targeting_system integer
    */
    'activationsPassiveTargetingSystem': number;
    /**
    * activations_probe_launcher integer
    */
    'activationsProbeLauncher': number;
    /**
    * activations_projected_eccm integer
    */
    'activationsProjectedEccm': number;
    /**
    * activations_projectile_weapon integer
    */
    'activationsProjectileWeapon': number;
    /**
    * activations_propulsion_module integer
    */
    'activationsPropulsionModule': number;
    /**
    * activations_remote_armor_repairer integer
    */
    'activationsRemoteArmorRepairer': number;
    /**
    * activations_remote_capacitor_transmitter integer
    */
    'activationsRemoteCapacitorTransmitter': number;
    /**
    * activations_remote_ecm_burst integer
    */
    'activationsRemoteEcmBurst': number;
    /**
    * activations_remote_hull_repairer integer
    */
    'activationsRemoteHullRepairer': number;
    /**
    * activations_remote_sensor_booster integer
    */
    'activationsRemoteSensorBooster': number;
    /**
    * activations_remote_sensor_damper integer
    */
    'activationsRemoteSensorDamper': number;
    /**
    * activations_remote_shield_booster integer
    */
    'activationsRemoteShieldBooster': number;
    /**
    * activations_remote_tracking_computer integer
    */
    'activationsRemoteTrackingComputer': number;
    /**
    * activations_salvager integer
    */
    'activationsSalvager': number;
    /**
    * activations_sensor_booster integer
    */
    'activationsSensorBooster': number;
    /**
    * activations_shield_booster integer
    */
    'activationsShieldBooster': number;
    /**
    * activations_shield_hardener integer
    */
    'activationsShieldHardener': number;
    /**
    * activations_ship_scanner integer
    */
    'activationsShipScanner': number;
    /**
    * activations_siege integer
    */
    'activationsSiege': number;
    /**
    * activations_smart_bomb integer
    */
    'activationsSmartBomb': number;
    /**
    * activations_stasis_web integer
    */
    'activationsStasisWeb': number;
    /**
    * activations_strip_miner integer
    */
    'activationsStripMiner': number;
    /**
    * activations_super_weapon integer
    */
    'activationsSuperWeapon': number;
    /**
    * activations_survey_scanner integer
    */
    'activationsSurveyScanner': number;
    /**
    * activations_target_breaker integer
    */
    'activationsTargetBreaker': number;
    /**
    * activations_target_painter integer
    */
    'activationsTargetPainter': number;
    /**
    * activations_tracking_computer integer
    */
    'activationsTrackingComputer': number;
    /**
    * activations_tracking_disruptor integer
    */
    'activationsTrackingDisruptor': number;
    /**
    * activations_tractor_beam integer
    */
    'activationsTractorBeam': number;
    /**
    * activations_triage integer
    */
    'activationsTriage': number;
    /**
    * activations_warp_disrupt_field_generator integer
    */
    'activationsWarpDisruptFieldGenerator': number;
    /**
    * activations_warp_scrambler integer
    */
    'activationsWarpScrambler': number;
    /**
    * link_weapons integer
    */
    'linkWeapons': number;
    /**
    * overload integer
    */
    'overload': number;
    /**
    * repairs integer
    */
    'repairs': number;
}

/**
* orbital object
*/
export class GetCharactersCharacterIdStatsOrbital {
    /**
    * strike_characters_killed integer
    */
    'strikeCharactersKilled': number;
    /**
    * strike_damage_to_players_armor_amount integer
    */
    'strikeDamageToPlayersArmorAmount': number;
    /**
    * strike_damage_to_players_shield_amount integer
    */
    'strikeDamageToPlayersShieldAmount': number;
}

/**
* pve object
*/
export class GetCharactersCharacterIdStatsPve {
    /**
    * dungeons_completed_agent integer
    */
    'dungeonsCompletedAgent': number;
    /**
    * dungeons_completed_distribution integer
    */
    'dungeonsCompletedDistribution': number;
    /**
    * missions_succeeded integer
    */
    'missionsSucceeded': number;
    /**
    * missions_succeeded_epic_arc integer
    */
    'missionsSucceededEpicArc': number;
}

/**
* social object
*/
export class GetCharactersCharacterIdStatsSocial {
    /**
    * add_contact_bad integer
    */
    'addContactBad': number;
    /**
    * add_contact_good integer
    */
    'addContactGood': number;
    /**
    * add_contact_high integer
    */
    'addContactHigh': number;
    /**
    * add_contact_horrible integer
    */
    'addContactHorrible': number;
    /**
    * add_contact_neutral integer
    */
    'addContactNeutral': number;
    /**
    * add_note integer
    */
    'addNote': number;
    /**
    * added_as_contact_bad integer
    */
    'addedAsContactBad': number;
    /**
    * added_as_contact_good integer
    */
    'addedAsContactGood': number;
    /**
    * added_as_contact_high integer
    */
    'addedAsContactHigh': number;
    /**
    * added_as_contact_horrible integer
    */
    'addedAsContactHorrible': number;
    /**
    * added_as_contact_neutral integer
    */
    'addedAsContactNeutral': number;
    /**
    * calendar_event_created integer
    */
    'calendarEventCreated': number;
    /**
    * chat_messages_alliance integer
    */
    'chatMessagesAlliance': number;
    /**
    * chat_messages_constellation integer
    */
    'chatMessagesConstellation': number;
    /**
    * chat_messages_corporation integer
    */
    'chatMessagesCorporation': number;
    /**
    * chat_messages_fleet integer
    */
    'chatMessagesFleet': number;
    /**
    * chat_messages_region integer
    */
    'chatMessagesRegion': number;
    /**
    * chat_messages_solarsystem integer
    */
    'chatMessagesSolarsystem': number;
    /**
    * chat_messages_warfaction integer
    */
    'chatMessagesWarfaction': number;
    /**
    * chat_total_message_length integer
    */
    'chatTotalMessageLength': number;
    /**
    * direct_trades integer
    */
    'directTrades': number;
    /**
    * fleet_broadcasts integer
    */
    'fleetBroadcasts': number;
    /**
    * fleet_joins integer
    */
    'fleetJoins': number;
    /**
    * mails_received integer
    */
    'mailsReceived': number;
    /**
    * mails_sent integer
    */
    'mailsSent': number;
}

/**
* travel object
*/
export class GetCharactersCharacterIdStatsTravel {
    /**
    * acceleration_gate_activations integer
    */
    'accelerationGateActivations': number;
    /**
    * align_to integer
    */
    'alignTo': number;
    /**
    * distance_warped_high_sec integer
    */
    'distanceWarpedHighSec': number;
    /**
    * distance_warped_low_sec integer
    */
    'distanceWarpedLowSec': number;
    /**
    * distance_warped_null_sec integer
    */
    'distanceWarpedNullSec': number;
    /**
    * distance_warped_wormhole integer
    */
    'distanceWarpedWormhole': number;
    /**
    * docks_high_sec integer
    */
    'docksHighSec': number;
    /**
    * docks_low_sec integer
    */
    'docksLowSec': number;
    /**
    * docks_null_sec integer
    */
    'docksNullSec': number;
    /**
    * jumps_stargate_high_sec integer
    */
    'jumpsStargateHighSec': number;
    /**
    * jumps_stargate_low_sec integer
    */
    'jumpsStargateLowSec': number;
    /**
    * jumps_stargate_null_sec integer
    */
    'jumpsStargateNullSec': number;
    /**
    * jumps_wormhole integer
    */
    'jumpsWormhole': number;
    /**
    * warps_high_sec integer
    */
    'warpsHighSec': number;
    /**
    * warps_low_sec integer
    */
    'warpsLowSec': number;
    /**
    * warps_null_sec integer
    */
    'warpsNullSec': number;
    /**
    * warps_to_bookmark integer
    */
    'warpsToBookmark': number;
    /**
    * warps_to_celestial integer
    */
    'warpsToCelestial': number;
    /**
    * warps_to_fleet_member integer
    */
    'warpsToFleetMember': number;
    /**
    * warps_to_scan_result integer
    */
    'warpsToScanResult': number;
    /**
    * warps_wormhole integer
    */
    'warpsWormhole': number;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdTitles200Ok {
    /**
    * title_id integer
    */
    'titleId': number;
    /**
    * name string
    */
    'name': string;
}

/**
* 200 ok object
*/
export class GetCharactersCharacterIdWalletJournal200Ok {
    /**
    * Date and time of transaction
    */
    'date': Date;
    /**
    * Unique journal reference ID
    */
    'refId': number;
    /**
    * Transaction type, different type of transaction will populate different fields in `extra_info` Note: If you have an existing XML API application that is using ref_types, you will need to know which string ESI ref_type maps to which integer. You can use the following gist to see string->int mappings: https://gist.github.com/ccp-zoetrope/c03db66d90c2148724c06171bc52e0ec
    */
    'refType': GetCharactersCharacterIdWalletJournal200Ok.RefTypeEnum;
    /**
    * first_party_id integer
    */
    'firstPartyId': number;
    /**
    * first_party_type string
    */
    'firstPartyType': GetCharactersCharacterIdWalletJournal200Ok.FirstPartyTypeEnum;
    /**
    * second_party_id integer
    */
    'secondPartyId': number;
    /**
    * second_party_type string
    */
    'secondPartyType': GetCharactersCharacterIdWalletJournal200Ok.SecondPartyTypeEnum;
    /**
    * Transaction amount. Positive when value transferred to the first party. Negative otherwise
    */
    'amount': number;
    /**
    * Wallet balance after transaction occurred
    */
    'balance': number;
    /**
    * reason string
    */
    'reason': string;
    /**
    * the corporation ID receiving any tax paid
    */
    'taxReceiverId': number;
    /**
    * Tax amount received for tax related transactions
    */
    'tax': number;
    'extraInfo': GetCharactersCharacterIdWalletJournalExtraInfo;
}

export namespace GetCharactersCharacterIdWalletJournal200Ok {
    export enum RefTypeEnum {
        AccelerationGateFee = <any> 'acceleration_gate_fee',
        AdvertisementListingFee = <any> 'advertisement_listing_fee',
        AgentDonation = <any> 'agent_donation',
        AgentLocationServices = <any> 'agent_location_services',
        AgentMiscellaneous = <any> 'agent_miscellaneous',
        AgentMissionCollateralPaid = <any> 'agent_mission_collateral_paid',
        AgentMissionCollateralRefunded = <any> 'agent_mission_collateral_refunded',
        AgentMissionReward = <any> 'agent_mission_reward',
        AgentMissionRewardCorporationTax = <any> 'agent_mission_reward_corporation_tax',
        AgentMissionTimeBonusReward = <any> 'agent_mission_time_bonus_reward',
        AgentMissionTimeBonusRewardCorporationTax = <any> 'agent_mission_time_bonus_reward_corporation_tax',
        AgentSecurityServices = <any> 'agent_security_services',
        AgentServicesRendered = <any> 'agent_services_rendered',
        AgentsPreward = <any> 'agents_preward',
        AllianceMaintainanceFee = <any> 'alliance_maintainance_fee',
        AllianceRegistrationFee = <any> 'alliance_registration_fee',
        AssetSafetyRecoveryTax = <any> 'asset_safety_recovery_tax',
        Bounty = <any> 'bounty',
        BountyPrize = <any> 'bounty_prize',
        BountyPrizeCorporationTax = <any> 'bounty_prize_corporation_tax',
        BountyPrizes = <any> 'bounty_prizes',
        BountyReimbursement = <any> 'bounty_reimbursement',
        BountySurcharge = <any> 'bounty_surcharge',
        BrokersFee = <any> 'brokers_fee',
        CloneActivation = <any> 'clone_activation',
        CloneTransfer = <any> 'clone_transfer',
        ContrabandFine = <any> 'contraband_fine',
        ContractAuctionBid = <any> 'contract_auction_bid',
        ContractAuctionBidCorp = <any> 'contract_auction_bid_corp',
        ContractAuctionBidRefund = <any> 'contract_auction_bid_refund',
        ContractAuctionSold = <any> 'contract_auction_sold',
        ContractBrokersFee = <any> 'contract_brokers_fee',
        ContractBrokersFeeCorp = <any> 'contract_brokers_fee_corp',
        ContractCollateral = <any> 'contract_collateral',
        ContractCollateralDepositedCorp = <any> 'contract_collateral_deposited_corp',
        ContractCollateralPayout = <any> 'contract_collateral_payout',
        ContractCollateralRefund = <any> 'contract_collateral_refund',
        ContractDeposit = <any> 'contract_deposit',
        ContractDepositCorp = <any> 'contract_deposit_corp',
        ContractDepositRefund = <any> 'contract_deposit_refund',
        ContractDepositSalesTax = <any> 'contract_deposit_sales_tax',
        ContractPrice = <any> 'contract_price',
        ContractPricePaymentCorp = <any> 'contract_price_payment_corp',
        ContractReversal = <any> 'contract_reversal',
        ContractReward = <any> 'contract_reward',
        ContractRewardDeposited = <any> 'contract_reward_deposited',
        ContractRewardDepositedCorp = <any> 'contract_reward_deposited_corp',
        ContractRewardRefund = <any> 'contract_reward_refund',
        ContractSalesTax = <any> 'contract_sales_tax',
        Copying = <any> 'copying',
        CorporateRewardPayout = <any> 'corporate_reward_payout',
        CorporateRewardTax = <any> 'corporate_reward_tax',
        CorporationAccountWithdrawal = <any> 'corporation_account_withdrawal',
        CorporationBulkPayment = <any> 'corporation_bulk_payment',
        CorporationDividendPayment = <any> 'corporation_dividend_payment',
        CorporationLiquidation = <any> 'corporation_liquidation',
        CorporationLogoChangeCost = <any> 'corporation_logo_change_cost',
        CorporationPayment = <any> 'corporation_payment',
        CorporationRegistrationFee = <any> 'corporation_registration_fee',
        CourierMissionEscrow = <any> 'courier_mission_escrow',
        Cspa = <any> 'cspa',
        Cspaofflinerefund = <any> 'cspaofflinerefund',
        DatacoreFee = <any> 'datacore_fee',
        DnaModificationFee = <any> 'dna_modification_fee',
        DockingFee = <any> 'docking_fee',
        DuelWagerEscrow = <any> 'duel_wager_escrow',
        DuelWagerPayment = <any> 'duel_wager_payment',
        DuelWagerRefund = <any> 'duel_wager_refund',
        FactorySlotRentalFee = <any> 'factory_slot_rental_fee',
        GmCashTransfer = <any> 'gm_cash_transfer',
        IndustryJobTax = <any> 'industry_job_tax',
        InfrastructureHubMaintenance = <any> 'infrastructure_hub_maintenance',
        Inheritance = <any> 'inheritance',
        Insurance = <any> 'insurance',
        JumpCloneActivationFee = <any> 'jump_clone_activation_fee',
        JumpCloneInstallationFee = <any> 'jump_clone_installation_fee',
        KillRightFee = <any> 'kill_right_fee',
        LpStore = <any> 'lp_store',
        Manufacturing = <any> 'manufacturing',
        MarketEscrow = <any> 'market_escrow',
        MarketFinePaid = <any> 'market_fine_paid',
        MarketTransaction = <any> 'market_transaction',
        MedalCreation = <any> 'medal_creation',
        MedalIssued = <any> 'medal_issued',
        MissionCompletion = <any> 'mission_completion',
        MissionCost = <any> 'mission_cost',
        MissionExpiration = <any> 'mission_expiration',
        MissionReward = <any> 'mission_reward',
        OfficeRentalFee = <any> 'office_rental_fee',
        OperationBonus = <any> 'operation_bonus',
        OpportunityReward = <any> 'opportunity_reward',
        PlanetaryConstruction = <any> 'planetary_construction',
        PlanetaryExportTax = <any> 'planetary_export_tax',
        PlanetaryImportTax = <any> 'planetary_import_tax',
        PlayerDonation = <any> 'player_donation',
        PlayerTrading = <any> 'player_trading',
        ProjectDiscoveryReward = <any> 'project_discovery_reward',
        ProjectDiscoveryTax = <any> 'project_discovery_tax',
        Reaction = <any> 'reaction',
        ReleaseOfImpoundedProperty = <any> 'release_of_impounded_property',
        RepairBill = <any> 'repair_bill',
        ReprocessingTax = <any> 'reprocessing_tax',
        ResearchingMaterialProductivity = <any> 'researching_material_productivity',
        ResearchingTechnology = <any> 'researching_technology',
        ResearchingTimeProductivity = <any> 'researching_time_productivity',
        ResourceWarsReward = <any> 'resource_wars_reward',
        ReverseEngineering = <any> 'reverse_engineering',
        SecurityProcessingFee = <any> 'security_processing_fee',
        Shares = <any> 'shares',
        SovereignityBill = <any> 'sovereignity_bill',
        StorePurchase = <any> 'store_purchase',
        StorePurchaseRefund = <any> 'store_purchase_refund',
        TransactionTax = <any> 'transaction_tax',
        UpkeepAdjustmentFee = <any> 'upkeep_adjustment_fee',
        WarAllyContract = <any> 'war_ally_contract',
        WarFee = <any> 'war_fee',
        WarFeeSurrender = <any> 'war_fee_surrender'
    }
    export enum FirstPartyTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction',
        System = <any> 'system'
    }
    export enum SecondPartyTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction',
        System = <any> 'system'
    }
}
/**
* Extra information for different type of transaction
*/
export class GetCharactersCharacterIdWalletJournalExtraInfo {
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * transaction_id integer
    */
    'transactionId': number;
    /**
    * npc_name string
    */
    'npcName': string;
    /**
    * npc_id integer
    */
    'npcId': number;
    /**
    * destroyed_ship_type_id integer
    */
    'destroyedShipTypeId': number;
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * job_id integer
    */
    'jobId': number;
    /**
    * contract_id integer
    */
    'contractId': number;
    /**
    * system_id integer
    */
    'systemId': number;
    /**
    * planet_id integer
    */
    'planetId': number;
}

/**
* wallet transaction
*/
export class GetCharactersCharacterIdWalletTransactions200Ok {
    /**
    * Unique transaction ID
    */
    'transactionId': number;
    /**
    * Date and time of transaction
    */
    'date': Date;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * Amount paid per unit
    */
    'unitPrice': number;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * client_id integer
    */
    'clientId': number;
    /**
    * is_buy boolean
    */
    'isBuy': boolean;
    /**
    * is_personal boolean
    */
    'isPersonal': boolean;
    /**
    * journal_ref_id integer
    */
    'journalRefId': number;
}

/**
* 200 ok object
*/
export class GetCharactersNames200Ok {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * character_name string
    */
    'characterName': string;
}

/**
* 200 ok object
*/
export class GetCorporationCorporationIdMiningExtractions200Ok {
    /**
    * structure_id integer
    */
    'structureId': number;
    /**
    * moon_id integer
    */
    'moonId': number;
    /**
    * The time at which the current extraction was initiated. 
    */
    'extractionStartTime': Date;
    /**
    * The time at which the chunk being extracted will arrive and can be fractured by the moon mining drill. 
    */
    'chunkArrivalTime': Date;
    /**
    * The time at which the chunk being extracted will naturally fracture if it is not first fractured by the moon mining drill. 
    */
    'naturalDecayTime': Date;
}

/**
* 200 ok object
*/
export class GetCorporationCorporationIdMiningObservers200Ok {
    /**
    * last_updated string
    */
    'lastUpdated': Date;
    /**
    * The entity that was observing the asteroid field when it was mined. 
    */
    'observerId': number;
    /**
    * The category of the observing entity
    */
    'observerType': GetCorporationCorporationIdMiningObservers200Ok.ObserverTypeEnum;
}

export namespace GetCorporationCorporationIdMiningObservers200Ok {
    export enum ObserverTypeEnum {
        Structure = <any> 'structure'
    }
}
/**
* 200 ok object
*/
export class GetCorporationCorporationIdMiningObserversObserverId200Ok {
    /**
    * last_updated string
    */
    'lastUpdated': Date;
    /**
    * The character that did the mining 
    */
    'characterId': number;
    /**
    * The corporation id of the character at the time data was recorded. 
    */
    'recordedCorporationId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * quantity integer
    */
    'quantity': number;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdAlliancehistory200Ok {
    /**
    * start_date string
    */
    'startDate': Date;
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * True if the alliance has been closed
    */
    'isDeleted': boolean;
    /**
    * An incrementing ID that can be used to canonically establish order of records in cases where dates may be ambiguous
    */
    'recordId': number;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdAssets200Ok {
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * location_type string
    */
    'locationType': GetCorporationsCorporationIdAssets200Ok.LocationTypeEnum;
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * location_flag string
    */
    'locationFlag': GetCorporationsCorporationIdAssets200Ok.LocationFlagEnum;
    /**
    * is_singleton boolean
    */
    'isSingleton': boolean;
}

export namespace GetCorporationsCorporationIdAssets200Ok {
    export enum LocationTypeEnum {
        Station = <any> 'station',
        SolarSystem = <any> 'solar_system',
        Other = <any> 'other'
    }
    export enum LocationFlagEnum {
        AssetSafety = <any> 'AssetSafety',
        AutoFit = <any> 'AutoFit',
        Bonus = <any> 'Bonus',
        Booster = <any> 'Booster',
        BoosterBay = <any> 'BoosterBay',
        Capsule = <any> 'Capsule',
        Cargo = <any> 'Cargo',
        CorpDeliveries = <any> 'CorpDeliveries',
        CorpSAG1 = <any> 'CorpSAG1',
        CorpSAG2 = <any> 'CorpSAG2',
        CorpSAG3 = <any> 'CorpSAG3',
        CorpSAG4 = <any> 'CorpSAG4',
        CorpSAG5 = <any> 'CorpSAG5',
        CorpSAG6 = <any> 'CorpSAG6',
        CorpSAG7 = <any> 'CorpSAG7',
        CrateLoot = <any> 'CrateLoot',
        Deliveries = <any> 'Deliveries',
        DroneBay = <any> 'DroneBay',
        DustBattle = <any> 'DustBattle',
        DustDatabank = <any> 'DustDatabank',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        FleetHangar = <any> 'FleetHangar',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        HiddenModifers = <any> 'HiddenModifers',
        Implant = <any> 'Implant',
        Impounded = <any> 'Impounded',
        JunkyardReprocessed = <any> 'JunkyardReprocessed',
        JunkyardTrashed = <any> 'JunkyardTrashed',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        Locked = <any> 'Locked',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        OfficeFolder = <any> 'OfficeFolder',
        Pilot = <any> 'Pilot',
        PlanetSurface = <any> 'PlanetSurface',
        QuafeBay = <any> 'QuafeBay',
        Reward = <any> 'Reward',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        SecondaryStorage = <any> 'SecondaryStorage',
        ServiceSlot0 = <any> 'ServiceSlot0',
        ServiceSlot1 = <any> 'ServiceSlot1',
        ServiceSlot2 = <any> 'ServiceSlot2',
        ServiceSlot3 = <any> 'ServiceSlot3',
        ServiceSlot4 = <any> 'ServiceSlot4',
        ServiceSlot5 = <any> 'ServiceSlot5',
        ServiceSlot6 = <any> 'ServiceSlot6',
        ServiceSlot7 = <any> 'ServiceSlot7',
        ShipHangar = <any> 'ShipHangar',
        ShipOffline = <any> 'ShipOffline',
        Skill = <any> 'Skill',
        SkillInTraining = <any> 'SkillInTraining',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        StructureActive = <any> 'StructureActive',
        StructureFuel = <any> 'StructureFuel',
        StructureInactive = <any> 'StructureInactive',
        StructureOffline = <any> 'StructureOffline',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        SubsystemBay = <any> 'SubsystemBay',
        Unlocked = <any> 'Unlocked',
        Wallet = <any> 'Wallet',
        Wardrobe = <any> 'Wardrobe'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdBlueprints200Ok {
    /**
    * Unique ID for this item.
    */
    'itemId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * References a solar system, station or item_id if this blueprint is located within a container.
    */
    'locationId': number;
    /**
    * Type of the location_id
    */
    'locationFlag': GetCorporationsCorporationIdBlueprints200Ok.LocationFlagEnum;
    /**
    * A range of numbers with a minimum of -2 and no maximum value where -1 is an original and -2 is a copy. It can be a positive integer if it is a stack of blueprint originals fresh from the market (e.g. no activities performed on them yet).
    */
    'quantity': number;
    /**
    * Time Efficiency Level of the blueprint.
    */
    'timeEfficiency': number;
    /**
    * Material Efficiency Level of the blueprint.
    */
    'materialEfficiency': number;
    /**
    * Number of runs remaining if the blueprint is a copy, -1 if it is an original.
    */
    'runs': number;
}

export namespace GetCorporationsCorporationIdBlueprints200Ok {
    export enum LocationFlagEnum {
        AssetSafety = <any> 'AssetSafety',
        AutoFit = <any> 'AutoFit',
        Bonus = <any> 'Bonus',
        Booster = <any> 'Booster',
        BoosterBay = <any> 'BoosterBay',
        Capsule = <any> 'Capsule',
        Cargo = <any> 'Cargo',
        CorpDeliveries = <any> 'CorpDeliveries',
        CorpSAG1 = <any> 'CorpSAG1',
        CorpSAG2 = <any> 'CorpSAG2',
        CorpSAG3 = <any> 'CorpSAG3',
        CorpSAG4 = <any> 'CorpSAG4',
        CorpSAG5 = <any> 'CorpSAG5',
        CorpSAG6 = <any> 'CorpSAG6',
        CorpSAG7 = <any> 'CorpSAG7',
        CrateLoot = <any> 'CrateLoot',
        Deliveries = <any> 'Deliveries',
        DroneBay = <any> 'DroneBay',
        DustBattle = <any> 'DustBattle',
        DustDatabank = <any> 'DustDatabank',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        FleetHangar = <any> 'FleetHangar',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        HiddenModifers = <any> 'HiddenModifers',
        Implant = <any> 'Implant',
        Impounded = <any> 'Impounded',
        JunkyardReprocessed = <any> 'JunkyardReprocessed',
        JunkyardTrashed = <any> 'JunkyardTrashed',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        Locked = <any> 'Locked',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        OfficeFolder = <any> 'OfficeFolder',
        Pilot = <any> 'Pilot',
        PlanetSurface = <any> 'PlanetSurface',
        QuafeBay = <any> 'QuafeBay',
        Reward = <any> 'Reward',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        SecondaryStorage = <any> 'SecondaryStorage',
        ServiceSlot0 = <any> 'ServiceSlot0',
        ServiceSlot1 = <any> 'ServiceSlot1',
        ServiceSlot2 = <any> 'ServiceSlot2',
        ServiceSlot3 = <any> 'ServiceSlot3',
        ServiceSlot4 = <any> 'ServiceSlot4',
        ServiceSlot5 = <any> 'ServiceSlot5',
        ServiceSlot6 = <any> 'ServiceSlot6',
        ServiceSlot7 = <any> 'ServiceSlot7',
        ShipHangar = <any> 'ShipHangar',
        ShipOffline = <any> 'ShipOffline',
        Skill = <any> 'Skill',
        SkillInTraining = <any> 'SkillInTraining',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        StructureActive = <any> 'StructureActive',
        StructureFuel = <any> 'StructureFuel',
        StructureInactive = <any> 'StructureInactive',
        StructureOffline = <any> 'StructureOffline',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        SubsystemBay = <any> 'SubsystemBay',
        Unlocked = <any> 'Unlocked',
        Wallet = <any> 'Wallet',
        Wardrobe = <any> 'Wardrobe'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdBookmarks200Ok {
    /**
    * bookmark_id integer
    */
    'bookmarkId': number;
    /**
    * creator_id integer
    */
    'creatorId': number;
    /**
    * folder_id integer
    */
    'folderId': number;
    /**
    * created string
    */
    'created': Date;
    /**
    * label string
    */
    'label': string;
    /**
    * notes string
    */
    'notes': string;
    /**
    * location_id integer
    */
    'locationId': number;
    'item': GetCorporationsCorporationIdBookmarksItem;
    'coordinates': GetCorporationsCorporationIdBookmarksCoordinates;
}

/**
* Optional object that is returned if a bookmark was made on a planet or a random location in space.
*/
export class GetCorporationsCorporationIdBookmarksCoordinates {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdBookmarksFolders200Ok {
    /**
    * folder_id integer
    */
    'folderId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * creator_id integer
    */
    'creatorId': number;
}

/**
* Optional object that is returned if a bookmark was made on a particular item.
*/
export class GetCorporationsCorporationIdBookmarksItem {
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * type_id integer
    */
    'typeId': number;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdContacts200Ok {
    /**
    * Standing of the contact
    */
    'standing': number;
    /**
    * contact_type string
    */
    'contactType': GetCorporationsCorporationIdContacts200Ok.ContactTypeEnum;
    /**
    * contact_id integer
    */
    'contactId': number;
    /**
    * Whether this contact is being watched
    */
    'isWatched': boolean;
    /**
    * Custom label of the contact
    */
    'labelId': number;
}

export namespace GetCorporationsCorporationIdContacts200Ok {
    export enum ContactTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdContainersLogs200Ok {
    /**
    * Timestamp when this log was created
    */
    'loggedAt': Date;
    /**
    * ID of the container
    */
    'containerId': number;
    /**
    * Type ID of the container
    */
    'containerTypeId': number;
    /**
    * ID of the character who performed the action.
    */
    'characterId': number;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * location_flag string
    */
    'locationFlag': GetCorporationsCorporationIdContainersLogs200Ok.LocationFlagEnum;
    /**
    * action string
    */
    'action': GetCorporationsCorporationIdContainersLogs200Ok.ActionEnum;
    /**
    * Type of password set if action is of type SetPassword or EnterPassword
    */
    'passwordType': GetCorporationsCorporationIdContainersLogs200Ok.PasswordTypeEnum;
    /**
    * Type ID of the item being acted upon
    */
    'typeId': number;
    /**
    * Quantity of the item being acted upon
    */
    'quantity': number;
    /**
    * old_config_bitmask integer
    */
    'oldConfigBitmask': number;
    /**
    * new_config_bitmask integer
    */
    'newConfigBitmask': number;
}

export namespace GetCorporationsCorporationIdContainersLogs200Ok {
    export enum LocationFlagEnum {
        AssetSafety = <any> 'AssetSafety',
        AutoFit = <any> 'AutoFit',
        Bonus = <any> 'Bonus',
        Booster = <any> 'Booster',
        BoosterBay = <any> 'BoosterBay',
        Capsule = <any> 'Capsule',
        Cargo = <any> 'Cargo',
        CorpDeliveries = <any> 'CorpDeliveries',
        CorpSAG1 = <any> 'CorpSAG1',
        CorpSAG2 = <any> 'CorpSAG2',
        CorpSAG3 = <any> 'CorpSAG3',
        CorpSAG4 = <any> 'CorpSAG4',
        CorpSAG5 = <any> 'CorpSAG5',
        CorpSAG6 = <any> 'CorpSAG6',
        CorpSAG7 = <any> 'CorpSAG7',
        CrateLoot = <any> 'CrateLoot',
        Deliveries = <any> 'Deliveries',
        DroneBay = <any> 'DroneBay',
        DustBattle = <any> 'DustBattle',
        DustDatabank = <any> 'DustDatabank',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        FleetHangar = <any> 'FleetHangar',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        HiddenModifers = <any> 'HiddenModifers',
        Implant = <any> 'Implant',
        Impounded = <any> 'Impounded',
        JunkyardReprocessed = <any> 'JunkyardReprocessed',
        JunkyardTrashed = <any> 'JunkyardTrashed',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        Locked = <any> 'Locked',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        OfficeFolder = <any> 'OfficeFolder',
        Pilot = <any> 'Pilot',
        PlanetSurface = <any> 'PlanetSurface',
        QuafeBay = <any> 'QuafeBay',
        Reward = <any> 'Reward',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        SecondaryStorage = <any> 'SecondaryStorage',
        ServiceSlot0 = <any> 'ServiceSlot0',
        ServiceSlot1 = <any> 'ServiceSlot1',
        ServiceSlot2 = <any> 'ServiceSlot2',
        ServiceSlot3 = <any> 'ServiceSlot3',
        ServiceSlot4 = <any> 'ServiceSlot4',
        ServiceSlot5 = <any> 'ServiceSlot5',
        ServiceSlot6 = <any> 'ServiceSlot6',
        ServiceSlot7 = <any> 'ServiceSlot7',
        ShipHangar = <any> 'ShipHangar',
        ShipOffline = <any> 'ShipOffline',
        Skill = <any> 'Skill',
        SkillInTraining = <any> 'SkillInTraining',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        StructureActive = <any> 'StructureActive',
        StructureFuel = <any> 'StructureFuel',
        StructureInactive = <any> 'StructureInactive',
        StructureOffline = <any> 'StructureOffline',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        SubsystemBay = <any> 'SubsystemBay',
        Unlocked = <any> 'Unlocked',
        Wallet = <any> 'Wallet',
        Wardrobe = <any> 'Wardrobe'
    }
    export enum ActionEnum {
        Add = <any> 'add',
        Assemble = <any> 'assemble',
        Configure = <any> 'configure',
        EnterPassword = <any> 'enter_password',
        Lock = <any> 'lock',
        Move = <any> 'move',
        Repackage = <any> 'repackage',
        SetName = <any> 'set_name',
        SetPassword = <any> 'set_password',
        Unlock = <any> 'unlock'
    }
    export enum PasswordTypeEnum {
        Config = <any> 'config',
        General = <any> 'general'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdContracts200Ok {
    /**
    * contract_id integer
    */
    'contractId': number;
    /**
    * Character ID for the issuer
    */
    'issuerId': number;
    /**
    * Character's corporation ID for the issuer
    */
    'issuerCorporationId': number;
    /**
    * ID to whom the contract is assigned, can be corporation or character ID
    */
    'assigneeId': number;
    /**
    * Who will accept the contract
    */
    'acceptorId': number;
    /**
    * Start location ID (for Couriers contract)
    */
    'startLocationId': number;
    /**
    * End location ID (for Couriers contract)
    */
    'endLocationId': number;
    /**
    * Type of the contract
    */
    'type': GetCorporationsCorporationIdContracts200Ok.TypeEnum;
    /**
    * Status of the the contract
    */
    'status': GetCorporationsCorporationIdContracts200Ok.StatusEnum;
    /**
    * Title of the contract
    */
    'title': string;
    /**
    * true if the contract was issued on behalf of the issuer's corporation
    */
    'forCorporation': boolean;
    /**
    * To whom the contract is available
    */
    'availability': GetCorporationsCorporationIdContracts200Ok.AvailabilityEnum;
    /**
    * Сreation date of the contract
    */
    'dateIssued': Date;
    /**
    * Expiration date of the contract
    */
    'dateExpired': Date;
    /**
    * Date of confirmation of contract
    */
    'dateAccepted': Date;
    /**
    * Number of days to perform the contract
    */
    'daysToComplete': number;
    /**
    * Date of completed of contract
    */
    'dateCompleted': Date;
    /**
    * Price of contract (for ItemsExchange and Auctions)
    */
    'price': number;
    /**
    * Remuneration for contract (for Couriers only)
    */
    'reward': number;
    /**
    * Collateral price (for Couriers only)
    */
    'collateral': number;
    /**
    * Buyout price (for Auctions only)
    */
    'buyout': number;
    /**
    * Volume of items in the contract
    */
    'volume': number;
}

export namespace GetCorporationsCorporationIdContracts200Ok {
    export enum TypeEnum {
        Unknown = <any> 'unknown',
        ItemExchange = <any> 'item_exchange',
        Auction = <any> 'auction',
        Courier = <any> 'courier',
        Loan = <any> 'loan'
    }
    export enum StatusEnum {
        Outstanding = <any> 'outstanding',
        InProgress = <any> 'in_progress',
        FinishedIssuer = <any> 'finished_issuer',
        FinishedContractor = <any> 'finished_contractor',
        Finished = <any> 'finished',
        Cancelled = <any> 'cancelled',
        Rejected = <any> 'rejected',
        Failed = <any> 'failed',
        Deleted = <any> 'deleted',
        Reversed = <any> 'reversed'
    }
    export enum AvailabilityEnum {
        Public = <any> 'public',
        Personal = <any> 'personal',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdContractsContractIdBids200Ok {
    /**
    * Unique ID for the bid
    */
    'bidId': number;
    /**
    * Character ID of the bidder
    */
    'bidderId': number;
    /**
    * Datetime when the bid was placed
    */
    'dateBid': Date;
    /**
    * The amount bid, in ISK
    */
    'amount': number;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdContractsContractIdItems200Ok {
    /**
    * Unique ID for the item
    */
    'recordId': number;
    /**
    * Type ID for item
    */
    'typeId': number;
    /**
    * Number of items in the stack
    */
    'quantity': number;
    /**
    * -1 indicates that the item is a singleton (non-stackable). If the item happens to be a Blueprint, -1 is an Original and -2 is a Blueprint Copy
    */
    'rawQuantity': number;
    /**
    * is_singleton boolean
    */
    'isSingleton': boolean;
    /**
    * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract.
    */
    'isIncluded': boolean;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdCustomsOffices200Ok {
    /**
    * unique ID of this customs office
    */
    'officeId': number;
    /**
    * ID of the solar system this customs office is located in
    */
    'systemId': number;
    /**
    * Together with reinforce_exit_end, marks a 2-hour period where this customs office could exit reinforcement mode during the day after initial attack
    */
    'reinforceExitStart': number;
    /**
    * reinforce_exit_end integer
    */
    'reinforceExitEnd': number;
    /**
    * corporation_tax_rate number
    */
    'corporationTaxRate': number;
    /**
    * allow_alliance_access boolean
    */
    'allowAllianceAccess': boolean;
    /**
    * Only present if alliance access is allowed
    */
    'allianceTaxRate': number;
    /**
    * standing_level and any standing related tax rate only present when this is true
    */
    'allowAccessWithStandings': boolean;
    /**
    * Access is allowed only for entities with this level of standing or better
    */
    'standingLevel': GetCorporationsCorporationIdCustomsOffices200Ok.StandingLevelEnum;
    /**
    * Tax rate for entities with excellent level of standing, only present if this level is allowed, same for all other standing related tax rates
    */
    'excellentStandingTaxRate': number;
    /**
    * good_standing_tax_rate number
    */
    'goodStandingTaxRate': number;
    /**
    * neutral_standing_tax_rate number
    */
    'neutralStandingTaxRate': number;
    /**
    * bad_standing_tax_rate number
    */
    'badStandingTaxRate': number;
    /**
    * terrible_standing_tax_rate number
    */
    'terribleStandingTaxRate': number;
}

export namespace GetCorporationsCorporationIdCustomsOffices200Ok {
    export enum StandingLevelEnum {
        Bad = <any> 'bad',
        Excellent = <any> 'excellent',
        Good = <any> 'good',
        Neutral = <any> 'neutral',
        Terrible = <any> 'terrible'
    }
}
/**
* hangar object
*/
export class GetCorporationsCorporationIdDivisionsHangar {
    /**
    * division integer
    */
    'division': number;
    /**
    * name string
    */
    'name': string;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdDivisionsOk {
    /**
    * hangar array
    */
    'hangar': Array<GetCorporationsCorporationIdDivisionsHangar>;
    /**
    * wallet array
    */
    'wallet': Array<GetCorporationsCorporationIdDivisionsWallet>;
}

/**
* wallet object
*/
export class GetCorporationsCorporationIdDivisionsWallet {
    /**
    * division integer
    */
    'division': number;
    /**
    * name string
    */
    'name': string;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdFacilities200Ok {
    /**
    * facility_id integer
    */
    'facilityId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * system_id integer
    */
    'systemId': number;
}

/**
* Summary of kills done by the given corporation against enemy factions
*/
export class GetCorporationsCorporationIdFwStatsKills {
    /**
    * Yesterday's total number of kills by members of the given corporation against enemy factions
    */
    'yesterday': number;
    /**
    * Last week's total number of kills by members of the given corporation against enemy factions
    */
    'lastWeek': number;
    /**
    * Total number of kills by members of the given corporation against enemy factions since the corporation enlisted
    */
    'total': number;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdFwStatsOk {
    /**
    * The faction the given corporation is enlisted to fight for. Will not be included if corporation is not enlisted in faction warfare
    */
    'factionId': number;
    /**
    * The enlistment date of the given corporation into faction warfare. Will not be included if corporation is not enlisted in faction warfare
    */
    'enlistedOn': Date;
    /**
    * How many pilots the enlisted corporation has. Will not be included if corporation is not enlisted in faction warfare
    */
    'pilots': number;
    'kills': GetCorporationsCorporationIdFwStatsKills;
    'victoryPoints': GetCorporationsCorporationIdFwStatsVictoryPoints;
}

/**
* Summary of victory points gained by the given corporation for the enlisted faction
*/
export class GetCorporationsCorporationIdFwStatsVictoryPoints {
    /**
    * Yesterday's victory points gained by members of the given corporation
    */
    'yesterday': number;
    /**
    * Last week's victory points gained by members of the given corporation
    */
    'lastWeek': number;
    /**
    * Total victory points gained since the given corporation enlisted
    */
    'total': number;
}

/**
* No image server for this datasource
*/
export class GetCorporationsCorporationIdIconsNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdIconsOk {
    /**
    * px64x64 string
    */
    'px64x64': string;
    /**
    * px128x128 string
    */
    'px128x128': string;
    /**
    * px256x256 string
    */
    'px256x256': string;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdIndustryJobs200Ok {
    /**
    * Unique job ID
    */
    'jobId': number;
    /**
    * ID of the character which installed this job
    */
    'installerId': number;
    /**
    * ID of the facility where this job is running
    */
    'facilityId': number;
    /**
    * ID of the location for the industry facility
    */
    'locationId': number;
    /**
    * Job activity ID
    */
    'activityId': number;
    /**
    * blueprint_id integer
    */
    'blueprintId': number;
    /**
    * blueprint_type_id integer
    */
    'blueprintTypeId': number;
    /**
    * Location ID of the location from which the blueprint was installed. Normally a station ID, but can also be an asset (e.g. container) or corporation facility
    */
    'blueprintLocationId': number;
    /**
    * Location ID of the location to which the output of the job will be delivered. Normally a station ID, but can also be a corporation facility
    */
    'outputLocationId': number;
    /**
    * Number of runs for a manufacturing job, or number of copies to make for a blueprint copy
    */
    'runs': number;
    /**
    * The sume of job installation fee and industry facility tax
    */
    'cost': number;
    /**
    * Number of runs blueprint is licensed for
    */
    'licensedRuns': number;
    /**
    * Chance of success for invention
    */
    'probability': number;
    /**
    * Type ID of product (manufactured, copied or invented)
    */
    'productTypeId': number;
    /**
    * status string
    */
    'status': GetCorporationsCorporationIdIndustryJobs200Ok.StatusEnum;
    /**
    * Job duration in seconds
    */
    'duration': number;
    /**
    * Date and time when this job started
    */
    'startDate': Date;
    /**
    * Date and time when this job finished
    */
    'endDate': Date;
    /**
    * Date and time when this job was paused (i.e. time when the facility where this job was installed went offline)
    */
    'pauseDate': Date;
    /**
    * Date and time when this job was completed
    */
    'completedDate': Date;
    /**
    * ID of the character which completed this job
    */
    'completedCharacterId': number;
    /**
    * Number of successful runs for this job. Equal to runs unless this is an invention job
    */
    'successfulRuns': number;
}

export namespace GetCorporationsCorporationIdIndustryJobs200Ok {
    export enum StatusEnum {
        Active = <any> 'active',
        Cancelled = <any> 'cancelled',
        Delivered = <any> 'delivered',
        Paused = <any> 'paused',
        Ready = <any> 'ready',
        Reverted = <any> 'reverted'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdKillmailsRecent200Ok {
    /**
    * ID of this killmail
    */
    'killmailId': number;
    /**
    * A hash of this killmail
    */
    'killmailHash': string;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdMedals200Ok {
    /**
    * medal_id integer
    */
    'medalId': number;
    /**
    * title string
    */
    'title': string;
    /**
    * description string
    */
    'description': string;
    /**
    * ID of the character who created this medal
    */
    'creatorId': number;
    /**
    * created_at string
    */
    'createdAt': Date;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdMedalsIssued200Ok {
    /**
    * medal_id integer
    */
    'medalId': number;
    /**
    * ID of the character who was rewarded this medal
    */
    'characterId': number;
    /**
    * reason string
    */
    'reason': string;
    /**
    * status string
    */
    'status': GetCorporationsCorporationIdMedalsIssued200Ok.StatusEnum;
    /**
    * ID of the character who issued the medal
    */
    'issuerId': number;
    /**
    * issued_at string
    */
    'issuedAt': Date;
}

export namespace GetCorporationsCorporationIdMedalsIssued200Ok {
    export enum StatusEnum {
        Private = <any> 'private',
        Public = <any> 'public'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdMembersTitles200Ok {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * A list of title_id
    */
    'titles': Array<number>;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdMembertracking200Ok {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * start_date string
    */
    'startDate': Date;
    /**
    * base_id integer
    */
    'baseId': number;
    /**
    * logon_date string
    */
    'logonDate': Date;
    /**
    * logoff_date string
    */
    'logoffDate': Date;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;
}

/**
* Not found
*/
export class GetCorporationsCorporationIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdOk {
    /**
    * the full name of the corporation
    */
    'name': string;
    /**
    * the short name of the corporation
    */
    'ticker': string;
    /**
    * member_count integer
    */
    'memberCount': number;
    /**
    * ceo_id integer
    */
    'ceoId': number;
    /**
    * ID of the alliance that corporation is a member of, if any
    */
    'allianceId': number;
    /**
    * description string
    */
    'description': string;
    /**
    * tax_rate number
    */
    'taxRate': number;
    /**
    * date_founded string
    */
    'dateFounded': Date;
    /**
    * creator_id integer
    */
    'creatorId': number;
    /**
    * url string
    */
    'url': string;
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * home_station_id integer
    */
    'homeStationId': number;
    /**
    * shares integer
    */
    'shares': number;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdOrders200Ok {
    /**
    * Unique order ID
    */
    'orderId': number;
    /**
    * The type ID of the item transacted in this order
    */
    'typeId': number;
    /**
    * ID of the region where order was placed
    */
    'regionId': number;
    /**
    * ID of the location where order was placed
    */
    'locationId': number;
    /**
    * Valid order range, numbers are ranges in jumps
    */
    'range': GetCorporationsCorporationIdOrders200Ok.RangeEnum;
    /**
    * True for a bid (buy) order. False for an offer (sell) order
    */
    'isBuyOrder': boolean;
    /**
    * Cost per unit for this order
    */
    'price': number;
    /**
    * Quantity of items required or offered at time order was placed
    */
    'volumeTotal': number;
    /**
    * Quantity of items still required or offered
    */
    'volumeRemain': number;
    /**
    * Date and time when this order was issued
    */
    'issued': Date;
    /**
    * Current order state
    */
    'state': GetCorporationsCorporationIdOrders200Ok.StateEnum;
    /**
    * For bids (buy orders), the minimum quantity that will be accepted in a matching offer (sell order)
    */
    'minVolume': number;
    /**
    * Wallet division of which this order used
    */
    'walletDivision': number;
    /**
    * Numer of days for which order is valid (starting from the issued date). An order expires at time issued + duration
    */
    'duration': number;
    /**
    * For buy orders, the amount of ISK in escrow
    */
    'escrow': number;
}

export namespace GetCorporationsCorporationIdOrders200Ok {
    export enum RangeEnum {
        _1 = <any> '1',
        _10 = <any> '10',
        _2 = <any> '2',
        _20 = <any> '20',
        _3 = <any> '3',
        _30 = <any> '30',
        _4 = <any> '4',
        _40 = <any> '40',
        _5 = <any> '5',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        Station = <any> 'station'
    }
    export enum StateEnum {
        Cancelled = <any> 'cancelled',
        CharacterDeleted = <any> 'character_deleted',
        Closed = <any> 'closed',
        Expired = <any> 'expired',
        Open = <any> 'open',
        Pending = <any> 'pending'
    }
}
/**
* coordinates object
*/
export class GetCorporationsCorporationIdOutpostsOutpostIdCoordinates {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdOutpostsOutpostIdOk {
    /**
    * The entity that owns the station (e.g. the entity whose logo is on the station services bar)
    */
    'ownerId': number;
    /**
    * The ID of the solar system the outpost rests in
    */
    'systemId': number;
    /**
    * docking_cost_per_ship_volume number
    */
    'dockingCostPerShipVolume': number;
    /**
    * office_rental_cost integer
    */
    'officeRentalCost': number;
    /**
    * The type ID of the given outpost
    */
    'typeId': number;
    /**
    * reprocessing_efficiency number
    */
    'reprocessingEfficiency': number;
    /**
    * reprocessing_station_take number
    */
    'reprocessingStationTake': number;
    /**
    * The owner ID that sets the ability for someone to dock based on standings.
    */
    'standingOwnerId': number;
    'coordinates': GetCorporationsCorporationIdOutpostsOutpostIdCoordinates;
    /**
    * A list of services the given outpost provides
    */
    'services': Array<GetCorporationsCorporationIdOutpostsOutpostIdService>;
}

/**
* service object
*/
export class GetCorporationsCorporationIdOutpostsOutpostIdService {
    /**
    * service_name string
    */
    'serviceName': GetCorporationsCorporationIdOutpostsOutpostIdService.ServiceNameEnum;
    /**
    * minimum_standing number
    */
    'minimumStanding': number;
    /**
    * surcharge_per_bad_standing number
    */
    'surchargePerBadStanding': number;
    /**
    * discount_per_good_standing number
    */
    'discountPerGoodStanding': number;
}

export namespace GetCorporationsCorporationIdOutpostsOutpostIdService {
    export enum ServiceNameEnum {
        BountyMissions = <any> 'Bounty Missions',
        AssassinationMissions = <any> 'Assassination Missions',
        CourierMissions = <any> 'Courier Missions',
        Interbus = <any> 'Interbus',
        ReprocessingPlant = <any> 'Reprocessing Plant',
        Refinery = <any> 'Refinery',
        Market = <any> 'Market',
        BlackMarket = <any> 'Black Market',
        StockExchange = <any> 'Stock Exchange',
        Cloning = <any> 'Cloning',
        Surgery = <any> 'Surgery',
        DNATherapy = <any> 'DNA Therapy',
        RepairFacilities = <any> 'Repair Facilities',
        Factory = <any> 'Factory',
        Laboratory = <any> 'Laboratory',
        Gambling = <any> 'Gambling',
        Fitting = <any> 'Fitting',
        Paintshop = <any> 'Paintshop',
        News = <any> 'News',
        Storage = <any> 'Storage',
        Insurance = <any> 'Insurance',
        Docking = <any> 'Docking',
        OfficeRental = <any> 'Office Rental',
        JumpCloneFacility = <any> 'Jump Clone Facility',
        LoyaltyPointStore = <any> 'Loyalty Point Store',
        NavyOffices = <any> 'Navy Offices',
        SecurityOffice = <any> 'Security Office'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdRoles200Ok {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * roles array
    */
    'roles': Array<GetCorporationsCorporationIdRoles200Ok.RolesEnum>;
    /**
    * grantable_roles array
    */
    'grantableRoles': Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesEnum>;
    /**
    * roles_at_hq array
    */
    'rolesAtHq': Array<GetCorporationsCorporationIdRoles200Ok.RolesAtHqEnum>;
    /**
    * grantable_roles_at_hq array
    */
    'grantableRolesAtHq': Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtHqEnum>;
    /**
    * roles_at_base array
    */
    'rolesAtBase': Array<GetCorporationsCorporationIdRoles200Ok.RolesAtBaseEnum>;
    /**
    * grantable_roles_at_base array
    */
    'grantableRolesAtBase': Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtBaseEnum>;
    /**
    * roles_at_other array
    */
    'rolesAtOther': Array<GetCorporationsCorporationIdRoles200Ok.RolesAtOtherEnum>;
    /**
    * grantable_roles_at_other array
    */
    'grantableRolesAtOther': Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtOtherEnum>;
}

export namespace GetCorporationsCorporationIdRoles200Ok {
    export enum RolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum RolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum RolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum RolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdRolesHistory200Ok {
    /**
    * The character whose roles are changed
    */
    'characterId': number;
    /**
    * changed_at string
    */
    'changedAt': Date;
    /**
    * ID of the character who issued this change
    */
    'issuerId': number;
    /**
    * role_type string
    */
    'roleType': GetCorporationsCorporationIdRolesHistory200Ok.RoleTypeEnum;
    /**
    * old_roles array
    */
    'oldRoles': Array<GetCorporationsCorporationIdRolesHistory200Ok.OldRolesEnum>;
    /**
    * new_roles array
    */
    'newRoles': Array<GetCorporationsCorporationIdRolesHistory200Ok.NewRolesEnum>;
}

export namespace GetCorporationsCorporationIdRolesHistory200Ok {
    export enum RoleTypeEnum {
        GrantableRoles = <any> 'grantable_roles',
        GrantableRolesAtBase = <any> 'grantable_roles_at_base',
        GrantableRolesAtHq = <any> 'grantable_roles_at_hq',
        GrantableRolesAtOther = <any> 'grantable_roles_at_other',
        Roles = <any> 'roles',
        RolesAtBase = <any> 'roles_at_base',
        RolesAtHq = <any> 'roles_at_hq',
        RolesAtOther = <any> 'roles_at_other'
    }
    export enum OldRolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum NewRolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdShareholders200Ok {
    /**
    * shareholder_id integer
    */
    'shareholderId': number;
    /**
    * shareholder_type string
    */
    'shareholderType': GetCorporationsCorporationIdShareholders200Ok.ShareholderTypeEnum;
    /**
    * share_count integer
    */
    'shareCount': number;
}

export namespace GetCorporationsCorporationIdShareholders200Ok {
    export enum ShareholderTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdStandings200Ok {
    /**
    * from_id integer
    */
    'fromId': number;
    /**
    * from_type string
    */
    'fromType': GetCorporationsCorporationIdStandings200Ok.FromTypeEnum;
    /**
    * standing number
    */
    'standing': number;
}

export namespace GetCorporationsCorporationIdStandings200Ok {
    export enum FromTypeEnum {
        Agent = <any> 'agent',
        NpcCorp = <any> 'npc_corp',
        Faction = <any> 'faction'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdStarbases200Ok {
    /**
    * Unique ID for this starbase (POS)
    */
    'starbaseId': number;
    /**
    * Starbase (POS) type
    */
    'typeId': number;
    /**
    * The solar system this starbase (POS) is in, unanchored POSes have this information
    */
    'systemId': number;
    /**
    * The moon this starbase (POS) is anchored on, unanchored POSes do not have this information
    */
    'moonId': number;
    /**
    * state string
    */
    'state': GetCorporationsCorporationIdStarbases200Ok.StateEnum;
    /**
    * When the POS started unanchoring, for starbases (POSes) in unanchoring state
    */
    'unanchorAt': Date;
    /**
    * When the POS will be out of reinforcement, for starbases (POSes) in reinforced state
    */
    'reinforcedUntil': Date;
    /**
    * When the POS onlined, for starbases (POSes) in online state
    */
    'onlinedSince': Date;
}

export namespace GetCorporationsCorporationIdStarbases200Ok {
    export enum StateEnum {
        Offline = <any> 'offline',
        Online = <any> 'online',
        Onlining = <any> 'onlining',
        Reinforced = <any> 'reinforced',
        Unanchoring = <any> 'unanchoring'
    }
}
/**
* fuel object
*/
export class GetCorporationsCorporationIdStarbasesStarbaseIdFuel {
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * quantity integer
    */
    'quantity': number;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdStarbasesStarbaseIdOk {
    /**
    * Who can view the starbase (POS)'s fule bay. Characters either need to have required role or belong to the starbase (POS) owner's corporation or alliance, as described by the enum, all other access settings follows the same scheme
    */
    'fuelBayView': GetCorporationsCorporationIdStarbasesStarbaseIdOk.FuelBayViewEnum;
    /**
    * Who can take fuel blocks out of the starbase (POS)'s fuel bay
    */
    'fuelBayTake': GetCorporationsCorporationIdStarbasesStarbaseIdOk.FuelBayTakeEnum;
    /**
    * Who can anchor starbase (POS) and its structures
    */
    'anchor': GetCorporationsCorporationIdStarbasesStarbaseIdOk.AnchorEnum;
    /**
    * Who can unanchor starbase (POS) and its structures
    */
    'unanchor': GetCorporationsCorporationIdStarbasesStarbaseIdOk.UnanchorEnum;
    /**
    * Who can online starbase (POS) and its structures
    */
    'online': GetCorporationsCorporationIdStarbasesStarbaseIdOk.OnlineEnum;
    /**
    * Who can offline starbase (POS) and its structures
    */
    'offline': GetCorporationsCorporationIdStarbasesStarbaseIdOk.OfflineEnum;
    /**
    * allow_corporation_members boolean
    */
    'allowCorporationMembers': boolean;
    /**
    * allow_alliance_members boolean
    */
    'allowAllianceMembers': boolean;
    /**
    * True if the starbase (POS) is using alliance standings, otherwise using corporation's
    */
    'useAllianceStandings': boolean;
    /**
    * Starbase (POS) will attack if target's standing is lower than this value
    */
    'attackStandingThreshold': number;
    /**
    * Starbase (POS) will attack if target's security standing is lower than this value
    */
    'attackSecurityStatusThreshold': number;
    /**
    * attack_if_other_security_status_dropping boolean
    */
    'attackIfOtherSecurityStatusDropping': boolean;
    /**
    * attack_if_at_war boolean
    */
    'attackIfAtWar': boolean;
    /**
    * Fuel blocks and other things that will be consumed when operating a starbase (POS)
    */
    'fuels': Array<GetCorporationsCorporationIdStarbasesStarbaseIdFuel>;
}

export namespace GetCorporationsCorporationIdStarbasesStarbaseIdOk {
    export enum FuelBayViewEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    export enum FuelBayTakeEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    export enum AnchorEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    export enum UnanchorEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    export enum OnlineEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    export enum OfflineEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdStructures200Ok {
    /**
    * The Item ID of the structure
    */
    'structureId': number;
    /**
    * The type id of the structure
    */
    'typeId': number;
    /**
    * ID of the corporation that owns the structure
    */
    'corporationId': number;
    /**
    * The solar system the structure is in
    */
    'systemId': number;
    /**
    * The id of the ACL profile for this citadel
    */
    'profileId': number;
    /**
    * This week's vulnerability windows, Monday is day 0
    */
    'currentVul': Array<GetCorporationsCorporationIdStructuresCurrentVul>;
    /**
    * Next week's vulnerability windows, Monday is day 0
    */
    'nextVul': Array<GetCorporationsCorporationIdStructuresNextVul>;
    /**
    * Date on which the structure will run out of fuel
    */
    'fuelExpires': Date;
    /**
    * Contains a list of service upgrades, and their state
    */
    'services': Array<GetCorporationsCorporationIdStructuresService>;
    /**
    * Date at which the structure entered it's current state
    */
    'stateTimerStart': Date;
    /**
    * Date at which the structure will move to it's next state
    */
    'stateTimerEnd': Date;
    /**
    * Date at which the structure will unanchor
    */
    'unanchorsAt': Date;
}

/**
* current_vul object
*/
export class GetCorporationsCorporationIdStructuresCurrentVul {
    /**
    * day integer
    */
    'day': number;
    /**
    * hour integer
    */
    'hour': number;
}

/**
* next_vul object
*/
export class GetCorporationsCorporationIdStructuresNextVul {
    /**
    * day integer
    */
    'day': number;
    /**
    * hour integer
    */
    'hour': number;
}

/**
* service object
*/
export class GetCorporationsCorporationIdStructuresService {
    /**
    * name string
    */
    'name': string;
    /**
    * state string
    */
    'state': GetCorporationsCorporationIdStructuresService.StateEnum;
}

export namespace GetCorporationsCorporationIdStructuresService {
    export enum StateEnum {
        Online = <any> 'online',
        Offline = <any> 'offline',
        Cleanup = <any> 'cleanup'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdTitles200Ok {
    /**
    * title_id integer
    */
    'titleId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * roles array
    */
    'roles': Array<GetCorporationsCorporationIdTitles200Ok.RolesEnum>;
    /**
    * grantable_roles array
    */
    'grantableRoles': Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesEnum>;
    /**
    * roles_at_hq array
    */
    'rolesAtHq': Array<GetCorporationsCorporationIdTitles200Ok.RolesAtHqEnum>;
    /**
    * grantable_roles_at_hq array
    */
    'grantableRolesAtHq': Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtHqEnum>;
    /**
    * roles_at_base array
    */
    'rolesAtBase': Array<GetCorporationsCorporationIdTitles200Ok.RolesAtBaseEnum>;
    /**
    * grantable_roles_at_base array
    */
    'grantableRolesAtBase': Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtBaseEnum>;
    /**
    * roles_at_other array
    */
    'rolesAtOther': Array<GetCorporationsCorporationIdTitles200Ok.RolesAtOtherEnum>;
    /**
    * grantable_roles_at_other array
    */
    'grantableRolesAtOther': Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtOtherEnum>;
}

export namespace GetCorporationsCorporationIdTitles200Ok {
    export enum RolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum RolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum RolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum RolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
    export enum GrantableRolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        TerrestrialCombatOfficer = <any> 'Terrestrial_Combat_Officer',
        TerrestrialLogisticsOfficer = <any> 'Terrestrial_Logistics_Officer',
        Trader = <any> 'Trader'
    }
}
/**
* 200 ok object
*/
export class GetCorporationsCorporationIdWallets200Ok {
    /**
    * division integer
    */
    'division': number;
    /**
    * balance number
    */
    'balance': number;
}

/**
* 200 ok object
*/
export class GetCorporationsCorporationIdWalletsDivisionJournal200Ok {
    /**
    * Date and time of transaction
    */
    'date': Date;
    /**
    * Unique journal reference ID
    */
    'refId': number;
    /**
    * Transaction type, different type of transaction will populate different fields in `extra_info` Note: If you have an existing XML API application that is using ref_types, you will need to know which string ESI ref_type maps to which integer. You can use the following gist to see string->int mappings: https://gist.github.com/ccp-zoetrope/c03db66d90c2148724c06171bc52e0ec
    */
    'refType': GetCorporationsCorporationIdWalletsDivisionJournal200Ok.RefTypeEnum;
    /**
    * first_party_id integer
    */
    'firstPartyId': number;
    /**
    * first_party_type string
    */
    'firstPartyType': GetCorporationsCorporationIdWalletsDivisionJournal200Ok.FirstPartyTypeEnum;
    /**
    * second_party_id integer
    */
    'secondPartyId': number;
    /**
    * second_party_type string
    */
    'secondPartyType': GetCorporationsCorporationIdWalletsDivisionJournal200Ok.SecondPartyTypeEnum;
    /**
    * Transaction amount. Positive when value transferred to the first party. Negative otherwise
    */
    'amount': number;
    /**
    * Wallet balance after transaction occurred
    */
    'balance': number;
    /**
    * reason string
    */
    'reason': string;
    /**
    * the corporation ID receiving any tax paid
    */
    'taxReceiverId': number;
    /**
    * Tax amount received for tax related transactions
    */
    'tax': number;
    'extraInfo': GetCorporationsCorporationIdWalletsDivisionJournalExtraInfo;
}

export namespace GetCorporationsCorporationIdWalletsDivisionJournal200Ok {
    export enum RefTypeEnum {
        AccelerationGateFee = <any> 'acceleration_gate_fee',
        AdvertisementListingFee = <any> 'advertisement_listing_fee',
        AgentDonation = <any> 'agent_donation',
        AgentLocationServices = <any> 'agent_location_services',
        AgentMiscellaneous = <any> 'agent_miscellaneous',
        AgentMissionCollateralPaid = <any> 'agent_mission_collateral_paid',
        AgentMissionCollateralRefunded = <any> 'agent_mission_collateral_refunded',
        AgentMissionReward = <any> 'agent_mission_reward',
        AgentMissionRewardCorporationTax = <any> 'agent_mission_reward_corporation_tax',
        AgentMissionTimeBonusReward = <any> 'agent_mission_time_bonus_reward',
        AgentMissionTimeBonusRewardCorporationTax = <any> 'agent_mission_time_bonus_reward_corporation_tax',
        AgentSecurityServices = <any> 'agent_security_services',
        AgentServicesRendered = <any> 'agent_services_rendered',
        AgentsPreward = <any> 'agents_preward',
        AllianceMaintainanceFee = <any> 'alliance_maintainance_fee',
        AllianceRegistrationFee = <any> 'alliance_registration_fee',
        AssetSafetyRecoveryTax = <any> 'asset_safety_recovery_tax',
        Bounty = <any> 'bounty',
        BountyPrize = <any> 'bounty_prize',
        BountyPrizeCorporationTax = <any> 'bounty_prize_corporation_tax',
        BountyPrizes = <any> 'bounty_prizes',
        BountyReimbursement = <any> 'bounty_reimbursement',
        BountySurcharge = <any> 'bounty_surcharge',
        BrokersFee = <any> 'brokers_fee',
        CloneActivation = <any> 'clone_activation',
        CloneTransfer = <any> 'clone_transfer',
        ContrabandFine = <any> 'contraband_fine',
        ContractAuctionBid = <any> 'contract_auction_bid',
        ContractAuctionBidCorp = <any> 'contract_auction_bid_corp',
        ContractAuctionBidRefund = <any> 'contract_auction_bid_refund',
        ContractAuctionSold = <any> 'contract_auction_sold',
        ContractBrokersFee = <any> 'contract_brokers_fee',
        ContractBrokersFeeCorp = <any> 'contract_brokers_fee_corp',
        ContractCollateral = <any> 'contract_collateral',
        ContractCollateralDepositedCorp = <any> 'contract_collateral_deposited_corp',
        ContractCollateralPayout = <any> 'contract_collateral_payout',
        ContractCollateralRefund = <any> 'contract_collateral_refund',
        ContractDeposit = <any> 'contract_deposit',
        ContractDepositCorp = <any> 'contract_deposit_corp',
        ContractDepositRefund = <any> 'contract_deposit_refund',
        ContractDepositSalesTax = <any> 'contract_deposit_sales_tax',
        ContractPrice = <any> 'contract_price',
        ContractPricePaymentCorp = <any> 'contract_price_payment_corp',
        ContractReversal = <any> 'contract_reversal',
        ContractReward = <any> 'contract_reward',
        ContractRewardDeposited = <any> 'contract_reward_deposited',
        ContractRewardDepositedCorp = <any> 'contract_reward_deposited_corp',
        ContractRewardRefund = <any> 'contract_reward_refund',
        ContractSalesTax = <any> 'contract_sales_tax',
        Copying = <any> 'copying',
        CorporateRewardPayout = <any> 'corporate_reward_payout',
        CorporateRewardTax = <any> 'corporate_reward_tax',
        CorporationAccountWithdrawal = <any> 'corporation_account_withdrawal',
        CorporationBulkPayment = <any> 'corporation_bulk_payment',
        CorporationDividendPayment = <any> 'corporation_dividend_payment',
        CorporationLiquidation = <any> 'corporation_liquidation',
        CorporationLogoChangeCost = <any> 'corporation_logo_change_cost',
        CorporationPayment = <any> 'corporation_payment',
        CorporationRegistrationFee = <any> 'corporation_registration_fee',
        CourierMissionEscrow = <any> 'courier_mission_escrow',
        Cspa = <any> 'cspa',
        Cspaofflinerefund = <any> 'cspaofflinerefund',
        DatacoreFee = <any> 'datacore_fee',
        DnaModificationFee = <any> 'dna_modification_fee',
        DockingFee = <any> 'docking_fee',
        DuelWagerEscrow = <any> 'duel_wager_escrow',
        DuelWagerPayment = <any> 'duel_wager_payment',
        DuelWagerRefund = <any> 'duel_wager_refund',
        FactorySlotRentalFee = <any> 'factory_slot_rental_fee',
        GmCashTransfer = <any> 'gm_cash_transfer',
        IndustryJobTax = <any> 'industry_job_tax',
        InfrastructureHubMaintenance = <any> 'infrastructure_hub_maintenance',
        Inheritance = <any> 'inheritance',
        Insurance = <any> 'insurance',
        JumpCloneActivationFee = <any> 'jump_clone_activation_fee',
        JumpCloneInstallationFee = <any> 'jump_clone_installation_fee',
        KillRightFee = <any> 'kill_right_fee',
        LpStore = <any> 'lp_store',
        Manufacturing = <any> 'manufacturing',
        MarketEscrow = <any> 'market_escrow',
        MarketFinePaid = <any> 'market_fine_paid',
        MarketTransaction = <any> 'market_transaction',
        MedalCreation = <any> 'medal_creation',
        MedalIssued = <any> 'medal_issued',
        MissionCompletion = <any> 'mission_completion',
        MissionCost = <any> 'mission_cost',
        MissionExpiration = <any> 'mission_expiration',
        MissionReward = <any> 'mission_reward',
        OfficeRentalFee = <any> 'office_rental_fee',
        OperationBonus = <any> 'operation_bonus',
        OpportunityReward = <any> 'opportunity_reward',
        PlanetaryConstruction = <any> 'planetary_construction',
        PlanetaryExportTax = <any> 'planetary_export_tax',
        PlanetaryImportTax = <any> 'planetary_import_tax',
        PlayerDonation = <any> 'player_donation',
        PlayerTrading = <any> 'player_trading',
        ProjectDiscoveryReward = <any> 'project_discovery_reward',
        ProjectDiscoveryTax = <any> 'project_discovery_tax',
        Reaction = <any> 'reaction',
        ReleaseOfImpoundedProperty = <any> 'release_of_impounded_property',
        RepairBill = <any> 'repair_bill',
        ReprocessingTax = <any> 'reprocessing_tax',
        ResearchingMaterialProductivity = <any> 'researching_material_productivity',
        ResearchingTechnology = <any> 'researching_technology',
        ResearchingTimeProductivity = <any> 'researching_time_productivity',
        ResourceWarsReward = <any> 'resource_wars_reward',
        ReverseEngineering = <any> 'reverse_engineering',
        SecurityProcessingFee = <any> 'security_processing_fee',
        Shares = <any> 'shares',
        SovereignityBill = <any> 'sovereignity_bill',
        StorePurchase = <any> 'store_purchase',
        StorePurchaseRefund = <any> 'store_purchase_refund',
        TransactionTax = <any> 'transaction_tax',
        UpkeepAdjustmentFee = <any> 'upkeep_adjustment_fee',
        WarAllyContract = <any> 'war_ally_contract',
        WarFee = <any> 'war_fee',
        WarFeeSurrender = <any> 'war_fee_surrender'
    }
    export enum FirstPartyTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction',
        System = <any> 'system'
    }
    export enum SecondPartyTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction',
        System = <any> 'system'
    }
}
/**
* Extra information for different type of transaction
*/
export class GetCorporationsCorporationIdWalletsDivisionJournalExtraInfo {
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * transaction_id integer
    */
    'transactionId': number;
    /**
    * npc_name string
    */
    'npcName': string;
    /**
    * npc_id integer
    */
    'npcId': number;
    /**
    * destroyed_ship_type_id integer
    */
    'destroyedShipTypeId': number;
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * job_id integer
    */
    'jobId': number;
    /**
    * contract_id integer
    */
    'contractId': number;
    /**
    * system_id integer
    */
    'systemId': number;
    /**
    * planet_id integer
    */
    'planetId': number;
}

/**
* wallet transaction
*/
export class GetCorporationsCorporationIdWalletsDivisionTransactions200Ok {
    /**
    * Unique transaction ID
    */
    'transactionId': number;
    /**
    * Date and time of transaction
    */
    'date': Date;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * Amount paid per unit
    */
    'unitPrice': number;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * client_id integer
    */
    'clientId': number;
    /**
    * is_buy boolean
    */
    'isBuy': boolean;
    /**
    * journal_ref_id integer
    */
    'journalRefId': number;
}

/**
* 200 ok object
*/
export class GetCorporationsNames200Ok {
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * corporation_name string
    */
    'corporationName': string;
}

/**
* Not found
*/
export class GetDogmaAttributesAttributeIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetDogmaAttributesAttributeIdOk {
    /**
    * attribute_id integer
    */
    'attributeId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * description string
    */
    'description': string;
    /**
    * icon_id integer
    */
    'iconId': number;
    /**
    * default_value number
    */
    'defaultValue': number;
    /**
    * published boolean
    */
    'published': boolean;
    /**
    * display_name string
    */
    'displayName': string;
    /**
    * unit_id integer
    */
    'unitId': number;
    /**
    * stackable boolean
    */
    'stackable': boolean;
    /**
    * high_is_good boolean
    */
    'highIsGood': boolean;
}

/**
* modifier object
*/
export class GetDogmaEffectsEffectIdModifier {
    /**
    * func string
    */
    'func': string;
    /**
    * domain string
    */
    'domain': string;
    /**
    * modified_attribute_id integer
    */
    'modifiedAttributeId': number;
    /**
    * modifying_attribute_id integer
    */
    'modifyingAttributeId': number;
    /**
    * effect_id integer
    */
    'effectId': number;
    /**
    * operator integer
    */
    'operator': number;
}

/**
* Not found
*/
export class GetDogmaEffectsEffectIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetDogmaEffectsEffectIdOk {
    /**
    * effect_id integer
    */
    'effectId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * display_name string
    */
    'displayName': string;
    /**
    * description string
    */
    'description': string;
    /**
    * icon_id integer
    */
    'iconId': number;
    /**
    * effect_category integer
    */
    'effectCategory': number;
    /**
    * pre_expression integer
    */
    'preExpression': number;
    /**
    * post_expression integer
    */
    'postExpression': number;
    /**
    * is_offensive boolean
    */
    'isOffensive': boolean;
    /**
    * is_assistance boolean
    */
    'isAssistance': boolean;
    /**
    * disallow_auto_repeat boolean
    */
    'disallowAutoRepeat': boolean;
    /**
    * published boolean
    */
    'published': boolean;
    /**
    * is_warp_safe boolean
    */
    'isWarpSafe': boolean;
    /**
    * range_chance boolean
    */
    'rangeChance': boolean;
    /**
    * electronic_chance boolean
    */
    'electronicChance': boolean;
    /**
    * duration_attribute_id integer
    */
    'durationAttributeId': number;
    /**
    * tracking_speed_attribute_id integer
    */
    'trackingSpeedAttributeId': number;
    /**
    * discharge_attribute_id integer
    */
    'dischargeAttributeId': number;
    /**
    * range_attribute_id integer
    */
    'rangeAttributeId': number;
    /**
    * falloff_attribute_id integer
    */
    'falloffAttributeId': number;
    /**
    * modifiers array
    */
    'modifiers': Array<GetDogmaEffectsEffectIdModifier>;
}

/**
* 200 ok object
*/
export class GetFleetsFleetIdMembers200Ok {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;
    /**
    * ID of the wing the member is in. If not applicable, will be set to -1
    */
    'wingId': number;
    /**
    * ID of the squad the member is in. If not applicable, will be set to -1
    */
    'squadId': number;
    /**
    * Member’s role in fleet
    */
    'role': GetFleetsFleetIdMembers200Ok.RoleEnum;
    /**
    * Localized role names
    */
    'roleName': string;
    /**
    * join_time string
    */
    'joinTime': Date;
    /**
    * Whether the member take fleet warps
    */
    'takesFleetWarp': boolean;
    /**
    * Solar system the member is located in
    */
    'solarSystemId': number;
    /**
    * Station in which the member is docked in, if applicable
    */
    'stationId': number;
}

export namespace GetFleetsFleetIdMembers200Ok {
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        WingCommander = <any> 'wing_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member'
    }
}
/**
* Not found
*/
export class GetFleetsFleetIdMembersNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* Not found
*/
export class GetFleetsFleetIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetFleetsFleetIdOk {
    /**
    * Fleet MOTD in CCP flavoured HTML
    */
    'motd': string;
    /**
    * Is free-move enabled
    */
    'isFreeMove': boolean;
    /**
    * Does the fleet have an active fleet advertisement
    */
    'isRegistered': boolean;
    /**
    * Is EVE Voice enabled
    */
    'isVoiceEnabled': boolean;
}

/**
* 200 ok object
*/
export class GetFleetsFleetIdWings200Ok {
    /**
    * name string
    */
    'name': string;
    /**
    * id integer
    */
    'id': number;
    /**
    * squads array
    */
    'squads': Array<GetFleetsFleetIdWingsSquad>;
}

/**
* Not found
*/
export class GetFleetsFleetIdWingsNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* squad object
*/
export class GetFleetsFleetIdWingsSquad {
    /**
    * name string
    */
    'name': string;
    /**
    * id integer
    */
    'id': number;
}

/**
* active_total object
*/
export class GetFwLeaderboardsActiveTotal {
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * Amount of kills
    */
    'amount': number;
}

/**
* active_total object
*/
export class GetFwLeaderboardsActiveTotal1 {
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * Amount of victory points
    */
    'amount': number;
}

/**
* active_total object
*/
export class GetFwLeaderboardsCharactersActiveTotal {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * Amount of kills
    */
    'amount': number;
}

/**
* active_total object
*/
export class GetFwLeaderboardsCharactersActiveTotal1 {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * Amount of victory points
    */
    'amount': number;
}

/**
* Top 100 rankings of pilots by number of kills from yesterday, last week and in total.
*/
export class GetFwLeaderboardsCharactersKills {
    /**
    * Top 100 ranking of pilots by kills in the past day
    */
    'yesterday': Array<GetFwLeaderboardsCharactersYesterday>;
    /**
    * Top 100 ranking of pilots by kills in the past week
    */
    'lastWeek': Array<GetFwLeaderboardsCharactersLastWeek>;
    /**
    * Top 100 ranking of pilots active in faction warfare by total kills. A pilot is considered \"active\" if they have participated in faction warfare in the past 14 days.
    */
    'activeTotal': Array<GetFwLeaderboardsCharactersActiveTotal>;
}

/**
* last_week object
*/
export class GetFwLeaderboardsCharactersLastWeek {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * Amount of kills
    */
    'amount': number;
}

/**
* last_week object
*/
export class GetFwLeaderboardsCharactersLastWeek1 {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * Amount of victory points
    */
    'amount': number;
}

/**
* 200 ok object
*/
export class GetFwLeaderboardsCharactersOk {
    'kills': GetFwLeaderboardsCharactersKills;
    'victoryPoints': GetFwLeaderboardsCharactersVictoryPoints;
}

/**
* Top 100 rankings of pilots by victory points from yesterday, last week and in total
*/
export class GetFwLeaderboardsCharactersVictoryPoints {
    /**
    * Top 100 ranking of pilots by victory points in the past day
    */
    'yesterday': Array<GetFwLeaderboardsCharactersYesterday1>;
    /**
    * Top 100 ranking of pilots by victory points in the past week
    */
    'lastWeek': Array<GetFwLeaderboardsCharactersLastWeek1>;
    /**
    * Top 100 ranking of pilots active in faction warfare by total victory points. A pilot is considered \"active\" if they have participated in faction warfare in the past 14 days.
    */
    'activeTotal': Array<GetFwLeaderboardsCharactersActiveTotal1>;
}

/**
* yesterday object
*/
export class GetFwLeaderboardsCharactersYesterday {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * Amount of kills
    */
    'amount': number;
}

/**
* yesterday object
*/
export class GetFwLeaderboardsCharactersYesterday1 {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * Amount of victory points
    */
    'amount': number;
}

/**
* active_total object
*/
export class GetFwLeaderboardsCorporationsActiveTotal {
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * Amount of kills
    */
    'amount': number;
}

/**
* active_total object
*/
export class GetFwLeaderboardsCorporationsActiveTotal1 {
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * Amount of victory points
    */
    'amount': number;
}

/**
* Top 10 rankings of corporations by number of kills from yesterday, last week and in total.
*/
export class GetFwLeaderboardsCorporationsKills {
    /**
    * Top 10 ranking of corporations by kills in the past day
    */
    'yesterday': Array<GetFwLeaderboardsCorporationsYesterday>;
    /**
    * Top 10 ranking of corporations by kills in the past week
    */
    'lastWeek': Array<GetFwLeaderboardsCorporationsLastWeek>;
    /**
    * Top 10 ranking of corporations active in faction warfare by total kills. A corporation is considered \"active\" if they have participated in faction warfare in the past 14 days.
    */
    'activeTotal': Array<GetFwLeaderboardsCorporationsActiveTotal>;
}

/**
* last_week object
*/
export class GetFwLeaderboardsCorporationsLastWeek {
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * Amount of kills
    */
    'amount': number;
}

/**
* last_week object
*/
export class GetFwLeaderboardsCorporationsLastWeek1 {
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * Amount of victory points
    */
    'amount': number;
}

/**
* 200 ok object
*/
export class GetFwLeaderboardsCorporationsOk {
    'kills': GetFwLeaderboardsCorporationsKills;
    'victoryPoints': GetFwLeaderboardsCorporationsVictoryPoints;
}

/**
* Top 10 rankings of corporations by victory points from yesterday, last week and in total
*/
export class GetFwLeaderboardsCorporationsVictoryPoints {
    /**
    * Top 10 ranking of corporations by victory points in the past day
    */
    'yesterday': Array<GetFwLeaderboardsCorporationsYesterday1>;
    /**
    * Top 10 ranking of corporations by victory points in the past week
    */
    'lastWeek': Array<GetFwLeaderboardsCorporationsLastWeek1>;
    /**
    * Top 10 ranking of corporations active in faction warfare by total victory points. A corporation is considered \"active\" if they have participated in faction warfare in the past 14 days.
    */
    'activeTotal': Array<GetFwLeaderboardsCorporationsActiveTotal1>;
}

/**
* yesterday object
*/
export class GetFwLeaderboardsCorporationsYesterday {
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * Amount of kills
    */
    'amount': number;
}

/**
* yesterday object
*/
export class GetFwLeaderboardsCorporationsYesterday1 {
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * Amount of victory points
    */
    'amount': number;
}

/**
* Top 4 rankings of factions by number of kills from yesterday, last week and in total.
*/
export class GetFwLeaderboardsKills {
    /**
    * Top 4 ranking of factions by kills in the past day
    */
    'yesterday': Array<GetFwLeaderboardsYesterday>;
    /**
    * Top 4 ranking of factions by kills in the past week
    */
    'lastWeek': Array<GetFwLeaderboardsLastWeek>;
    /**
    * Top 4 ranking of factions active in faction warfare by total kills. A faction is considered \"active\" if they have participated in faction warfare in the past 14 days.
    */
    'activeTotal': Array<GetFwLeaderboardsActiveTotal>;
}

/**
* last_week object
*/
export class GetFwLeaderboardsLastWeek {
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * Amount of kills
    */
    'amount': number;
}

/**
* last_week object
*/
export class GetFwLeaderboardsLastWeek1 {
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * Amount of victory points
    */
    'amount': number;
}

/**
* 200 ok object
*/
export class GetFwLeaderboardsOk {
    'kills': GetFwLeaderboardsKills;
    'victoryPoints': GetFwLeaderboardsVictoryPoints;
}

/**
* Top 4 rankings of factions by victory points from yesterday, last week and in total
*/
export class GetFwLeaderboardsVictoryPoints {
    /**
    * Top 4 ranking of factions by victory points in the past day
    */
    'yesterday': Array<GetFwLeaderboardsYesterday1>;
    /**
    * Top 4 ranking of factions by victory points in the past week
    */
    'lastWeek': Array<GetFwLeaderboardsLastWeek1>;
    /**
    * Top 4 ranking of factions active in faction warfare by total victory points. A faction is considered \"active\" if they have participated in faction warfare in the past 14 days.
    */
    'activeTotal': Array<GetFwLeaderboardsActiveTotal1>;
}

/**
* yesterday object
*/
export class GetFwLeaderboardsYesterday {
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * Amount of kills
    */
    'amount': number;
}

/**
* yesterday object
*/
export class GetFwLeaderboardsYesterday1 {
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * Amount of victory points
    */
    'amount': number;
}

/**
* 200 ok object
*/
export class GetFwStats200Ok {
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * How many pilots fight for the given faction
    */
    'pilots': number;
    /**
    * The number of solar systems controlled by the given faction
    */
    'systemsControlled': number;
    'kills': GetFwStatsKills;
    'victoryPoints': GetFwStatsVictoryPoints;
}

/**
* Summary of kills against an enemy faction for the given faction
*/
export class GetFwStatsKills {
    /**
    * Yesterday's total number of kills against enemy factions
    */
    'yesterday': number;
    /**
    * Last week's total number of kills against enemy factions
    */
    'lastWeek': number;
    /**
    * Total number of kills against enemy factions since faction warfare began
    */
    'total': number;
}

/**
* Summary of victory points gained for the given faction
*/
export class GetFwStatsVictoryPoints {
    /**
    * Yesterday's victory points gained
    */
    'yesterday': number;
    /**
    * Last week's victory points gained
    */
    'lastWeek': number;
    /**
    * Total victory points gained since faction warfare began
    */
    'total': number;
}

/**
* 200 ok object
*/
export class GetFwSystems200Ok {
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * owner_faction_id integer
    */
    'ownerFactionId': number;
    /**
    * occupier_faction_id integer
    */
    'occupierFactionId': number;
    /**
    * victory_points integer
    */
    'victoryPoints': number;
    /**
    * victory_points_threshold integer
    */
    'victoryPointsThreshold': number;
    /**
    * contested boolean
    */
    'contested': boolean;
}

/**
* 200 ok object
*/
export class GetFwWars200Ok {
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * The faction ID of the enemy faction.
    */
    'againstId': number;
}

/**
* 200 ok object
*/
export class GetIncursions200Ok {
    /**
    * The type of this incursion
    */
    'type': string;
    /**
    * The state of this incursion
    */
    'state': GetIncursions200Ok.StateEnum;
    /**
    * Influence of this incursion as a float from 0 to 1
    */
    'influence': number;
    /**
    * Whether the final encounter has boss or not
    */
    'hasBoss': boolean;
    /**
    * The attacking faction's id
    */
    'factionId': number;
    /**
    * The constellation id in which this incursion takes place
    */
    'constellationId': number;
    /**
    * Staging solar system for this incursion
    */
    'stagingSolarSystemId': number;
    /**
    * A list of infested solar system ids that are a part of this incursion
    */
    'infestedSolarSystems': Array<number>;
}

export namespace GetIncursions200Ok {
    export enum StateEnum {
        Withdrawing = <any> 'withdrawing',
        Mobilizing = <any> 'mobilizing',
        Established = <any> 'established'
    }
}
/**
* 200 ok object
*/
export class GetIndustryFacilities200Ok {
    /**
    * ID of the facility
    */
    'facilityId': number;
    /**
    * Tax imposed by the facility
    */
    'tax': number;
    /**
    * Owner of the facility
    */
    'ownerId': number;
    /**
    * Type ID of the facility
    */
    'typeId': number;
    /**
    * Solar system ID where the facility is
    */
    'solarSystemId': number;
    /**
    * Region ID where the facility is
    */
    'regionId': number;
}

/**
* 200 ok object
*/
export class GetIndustrySystems200Ok {
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * cost_indices array
    */
    'costIndices': Array<GetIndustrySystemsCostIndice>;
}

/**
* cost_indice object
*/
export class GetIndustrySystemsCostIndice {
    /**
    * activity string
    */
    'activity': GetIndustrySystemsCostIndice.ActivityEnum;
    /**
    * cost_index number
    */
    'costIndex': number;
}

export namespace GetIndustrySystemsCostIndice {
    export enum ActivityEnum {
        Copying = <any> 'copying',
        Duplicating = <any> 'duplicating',
        Invention = <any> 'invention',
        Manufacturing = <any> 'manufacturing',
        None = <any> 'none',
        Reaction = <any> 'reaction',
        ResearchingMaterialEfficiency = <any> 'researching_material_efficiency',
        ResearchingTechnology = <any> 'researching_technology',
        ResearchingTimeEfficiency = <any> 'researching_time_efficiency',
        ReverseEngineering = <any> 'reverse_engineering'
    }
}
/**
* 200 ok object
*/
export class GetInsurancePrices200Ok {
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * A list of a available insurance levels for this ship type
    */
    'levels': Array<GetInsurancePricesLevel>;
}

/**
* level object
*/
export class GetInsurancePricesLevel {
    /**
    * cost number
    */
    'cost': number;
    /**
    * payout number
    */
    'payout': number;
    /**
    * Localized insurance level
    */
    'name': string;
}

/**
* attacker object
*/
export class GetKillmailsKillmailIdKillmailHashAttacker {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * Security status for the attacker 
    */
    'securityStatus': number;
    /**
    * Was the attacker the one to achieve the final blow 
    */
    'finalBlow': boolean;
    /**
    * damage_done integer
    */
    'damageDone': number;
    /**
    * What ship was the attacker flying 
    */
    'shipTypeId': number;
    /**
    * What weapon was used by the attacker for the kill 
    */
    'weaponTypeId': number;
}

/**
* item object
*/
export class GetKillmailsKillmailIdKillmailHashItem {
    /**
    * item_type_id integer
    */
    'itemTypeId': number;
    /**
    * quantity_destroyed integer
    */
    'quantityDestroyed': number;
    /**
    * quantity_dropped integer
    */
    'quantityDropped': number;
    /**
    * singleton integer
    */
    'singleton': number;
    /**
    * flag integer
    */
    'flag': number;
}

/**
* item object
*/
export class GetKillmailsKillmailIdKillmailHashItem1 {
    /**
    * item_type_id integer
    */
    'itemTypeId': number;
    /**
    * How many of the item were destroyed if any 
    */
    'quantityDestroyed': number;
    /**
    * How many of the item were dropped if any 
    */
    'quantityDropped': number;
    /**
    * singleton integer
    */
    'singleton': number;
    /**
    * Flag for the location of the item 
    */
    'flag': number;
    /**
    * items array
    */
    'items': Array<GetKillmailsKillmailIdKillmailHashItem>;
}

/**
* 200 ok object
*/
export class GetKillmailsKillmailIdKillmailHashOk {
    /**
    * ID of the killmail
    */
    'killmailId': number;
    /**
    * Time that the victim was killed and the killmail generated 
    */
    'killmailTime': Date;
    'victim': GetKillmailsKillmailIdKillmailHashVictim;
    /**
    * attackers array
    */
    'attackers': Array<GetKillmailsKillmailIdKillmailHashAttacker>;
    /**
    * Solar system that the kill took place in 
    */
    'solarSystemId': number;
    /**
    * Moon if the kill took place at one
    */
    'moonId': number;
    /**
    * War if the killmail is generated in relation to an official war 
    */
    'warId': number;
}

/**
* Coordinates of the victim in Cartesian space relative to the Sun 
*/
export class GetKillmailsKillmailIdKillmailHashPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* Unprocessable entity
*/
export class GetKillmailsKillmailIdKillmailHashUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error': string;
}

/**
* victim object
*/
export class GetKillmailsKillmailIdKillmailHashVictim {
    /**
    * character_id integer
    */
    'characterId': number;
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * How much total damage was taken by the victim 
    */
    'damageTaken': number;
    /**
    * The ship that the victim was piloting and was destroyed 
    */
    'shipTypeId': number;
    /**
    * items array
    */
    'items': Array<GetKillmailsKillmailIdKillmailHashItem1>;
    'position': GetKillmailsKillmailIdKillmailHashPosition;
}

/**
* 200 ok object
*/
export class GetLoyaltyStoresCorporationIdOffers200Ok {
    /**
    * offer_id integer
    */
    'offerId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * quantity integer
    */
    'quantity': number;
    /**
    * lp_cost integer
    */
    'lpCost': number;
    /**
    * isk_cost integer
    */
    'iskCost': number;
    /**
    * required_items array
    */
    'requiredItems': Array<GetLoyaltyStoresCorporationIdOffersRequiredItem>;
}

/**
* required_item object
*/
export class GetLoyaltyStoresCorporationIdOffersRequiredItem {
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * quantity integer
    */
    'quantity': number;
}

/**
* Not found
*/
export class GetMarketsGroupsMarketGroupIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetMarketsGroupsMarketGroupIdOk {
    /**
    * market_group_id integer
    */
    'marketGroupId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * description string
    */
    'description': string;
    /**
    * types array
    */
    'types': Array<number>;
    /**
    * parent_group_id integer
    */
    'parentGroupId': number;
}

/**
* 200 ok object
*/
export class GetMarketsPrices200Ok {
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * average_price number
    */
    'averagePrice': number;
    /**
    * adjusted_price number
    */
    'adjustedPrice': number;
}

/**
* 200 ok object
*/
export class GetMarketsRegionIdHistory200Ok {
    /**
    * The date of this historical statistic entry
    */
    'date': Date;
    /**
    * Total number of orders happened that day
    */
    'orderCount': number;
    /**
    * Total
    */
    'volume': number;
    /**
    * highest number
    */
    'highest': number;
    /**
    * average number
    */
    'average': number;
    /**
    * lowest number
    */
    'lowest': number;
}

/**
* Unprocessable entity
*/
export class GetMarketsRegionIdHistoryUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetMarketsRegionIdOrders200Ok {
    /**
    * order_id integer
    */
    'orderId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * volume_total integer
    */
    'volumeTotal': number;
    /**
    * volume_remain integer
    */
    'volumeRemain': number;
    /**
    * min_volume integer
    */
    'minVolume': number;
    /**
    * price number
    */
    'price': number;
    /**
    * is_buy_order boolean
    */
    'isBuyOrder': boolean;
    /**
    * duration integer
    */
    'duration': number;
    /**
    * issued string
    */
    'issued': Date;
    /**
    * range string
    */
    'range': GetMarketsRegionIdOrders200Ok.RangeEnum;
}

export namespace GetMarketsRegionIdOrders200Ok {
    export enum RangeEnum {
        Station = <any> 'station',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _10 = <any> '10',
        _20 = <any> '20',
        _30 = <any> '30',
        _40 = <any> '40'
    }
}
/**
* Unprocessable entity
*/
export class GetMarketsRegionIdOrdersUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetMarketsStructuresStructureId200Ok {
    /**
    * order_id integer
    */
    'orderId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * location_id integer
    */
    'locationId': number;
    /**
    * volume_total integer
    */
    'volumeTotal': number;
    /**
    * volume_remain integer
    */
    'volumeRemain': number;
    /**
    * min_volume integer
    */
    'minVolume': number;
    /**
    * price number
    */
    'price': number;
    /**
    * is_buy_order boolean
    */
    'isBuyOrder': boolean;
    /**
    * duration integer
    */
    'duration': number;
    /**
    * issued string
    */
    'issued': Date;
    /**
    * range string
    */
    'range': GetMarketsStructuresStructureId200Ok.RangeEnum;
}

export namespace GetMarketsStructuresStructureId200Ok {
    export enum RangeEnum {
        Station = <any> 'station',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _10 = <any> '10',
        _20 = <any> '20',
        _30 = <any> '30',
        _40 = <any> '40'
    }
}
/**
* 200 ok object
*/
export class GetOpportunitiesGroupsGroupIdOk {
    /**
    * group_id integer
    */
    'groupId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * description string
    */
    'description': string;
    /**
    * notification string
    */
    'notification': string;
    /**
    * Tasks need to complete for this group
    */
    'requiredTasks': Array<number>;
    /**
    * The groups that are connected to this group on the opportunities map
    */
    'connectedGroups': Array<number>;
}

/**
* 200 ok object
*/
export class GetOpportunitiesTasksTaskIdOk {
    /**
    * task_id integer
    */
    'taskId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * description string
    */
    'description': string;
    /**
    * notification string
    */
    'notification': string;
}

/**
* Not found
*/
export class GetRouteOriginDestinationNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetSearchOk {
    /**
    * agent array
    */
    'agent': Array<number>;
    /**
    * alliance array
    */
    'alliance': Array<number>;
    /**
    * character array
    */
    'character': Array<number>;
    /**
    * constellation array
    */
    'constellation': Array<number>;
    /**
    * corporation array
    */
    'corporation': Array<number>;
    /**
    * faction array
    */
    'faction': Array<number>;
    /**
    * inventory_type array
    */
    'inventoryType': Array<number>;
    /**
    * region array
    */
    'region': Array<number>;
    /**
    * solar_system array
    */
    'solarSystem': Array<number>;
    /**
    * station array
    */
    'station': Array<number>;
}

/**
* 200 ok object
*/
export class GetSovereigntyCampaigns200Ok {
    /**
    * Unique ID for this campaign.
    */
    'campaignId': number;
    /**
    * The structure item ID that is related to this campaign. 
    */
    'structureId': number;
    /**
    * The solar system the structure is located in. 
    */
    'solarSystemId': number;
    /**
    * The constellation in which the campaign will take place. 
    */
    'constellationId': number;
    /**
    * Type of event this campaign is for. tcu_defense, ihub_defense and station_defense are referred to as \"Defense Events\", station_freeport as \"Freeport Events\". 
    */
    'eventType': GetSovereigntyCampaigns200Ok.EventTypeEnum;
    /**
    * Time the event is scheduled to start. 
    */
    'startTime': Date;
    /**
    * Defending alliance, only present in Defense Events 
    */
    'defenderId': number;
    /**
    * Score for the defending alliance, only present in Defense Events. 
    */
    'defenderScore': number;
    /**
    * Score for all attacking parties, only present in Defense Events. 
    */
    'attackersScore': number;
    /**
    * Alliance participating and their respective scores, only present in Freeport Events. 
    */
    'participants': Array<GetSovereigntyCampaignsParticipant>;
}

export namespace GetSovereigntyCampaigns200Ok {
    export enum EventTypeEnum {
        TcuDefense = <any> 'tcu_defense',
        IhubDefense = <any> 'ihub_defense',
        StationDefense = <any> 'station_defense',
        StationFreeport = <any> 'station_freeport'
    }
}
/**
* participant object
*/
export class GetSovereigntyCampaignsParticipant {
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * score number
    */
    'score': number;
}

/**
* 200 ok object
*/
export class GetSovereigntyMap200Ok {
    /**
    * system_id integer
    */
    'systemId': number;
    /**
    * alliance_id integer
    */
    'allianceId': number;
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * faction_id integer
    */
    'factionId': number;
}

/**
* 200 ok object
*/
export class GetSovereigntyStructures200Ok {
    /**
    * The alliance that owns the structure. 
    */
    'allianceId': number;
    /**
    * Solar system in which the structure is located. 
    */
    'solarSystemId': number;
    /**
    * Unique item ID for this structure.
    */
    'structureId': number;
    /**
    * A reference to the type of structure this is. 
    */
    'structureTypeId': number;
    /**
    * The occupancy level for the next or current vulnerability window. This takes into account all development indexes and capital system bonuses. Also known as Activity Defense Multiplier from in the client. It increases the time that attackers must spend using their entosis links on the structure. 
    */
    'vulnerabilityOccupancyLevel': number;
    /**
    * The next time at which the structure will become vulnerable. Or the start time of the current window if current time is between this and vulnerableEndTime. 
    */
    'vulnerableStartTime': Date;
    /**
    * The time at which the next or current vulnerability window ends. At the end of a vulnerability window the next window is recalculated and locked in along with the vulnerabilityOccupancyLevel. If the structure is not in 100% entosis control of the defender, it will go in to 'overtime' and stay vulnerable for as long as that situation persists. Only once the defenders have 100% entosis control and has the vulnerableEndTime passed does the vulnerability interval expire and a new one is calculated. 
    */
    'vulnerableEndTime': Date;
}

/**
* 200 ok object
*/
export class GetStatusOk {
    /**
    * Server start timestamp
    */
    'startTime': Date;
    /**
    * Current online player count
    */
    'players': number;
    /**
    * Running version as string
    */
    'serverVersion': string;
    /**
    * If the server is in VIP mode
    */
    'vip': boolean;
}

/**
* 200 ok object
*/
export class GetUniverseBloodlines200Ok {
    /**
    * bloodline_id integer
    */
    'bloodlineId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * description string
    */
    'description': string;
    /**
    * race_id integer
    */
    'raceId': number;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * perception integer
    */
    'perception': number;
    /**
    * willpower integer
    */
    'willpower': number;
    /**
    * charisma integer
    */
    'charisma': number;
    /**
    * memory integer
    */
    'memory': number;
    /**
    * intelligence integer
    */
    'intelligence': number;
}

/**
* Not found
*/
export class GetUniverseCategoriesCategoryIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseCategoriesCategoryIdOk {
    /**
    * category_id integer
    */
    'categoryId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * published boolean
    */
    'published': boolean;
    /**
    * groups array
    */
    'groups': Array<number>;
}

/**
* Not found
*/
export class GetUniverseConstellationsConstellationIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseConstellationsConstellationIdOk {
    /**
    * constellation_id integer
    */
    'constellationId': number;
    /**
    * name string
    */
    'name': string;
    'position': GetUniverseConstellationsConstellationIdPosition;
    /**
    * The region this constellation is in
    */
    'regionId': number;
    /**
    * systems array
    */
    'systems': Array<number>;
}

/**
* position object
*/
export class GetUniverseConstellationsConstellationIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* 200 ok object
*/
export class GetUniverseFactions200Ok {
    /**
    * faction_id integer
    */
    'factionId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * description string
    */
    'description': string;
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * corporation_id integer
    */
    'corporationId': number;
    /**
    * militia_corporation_id integer
    */
    'militiaCorporationId': number;
    /**
    * size_factor number
    */
    'sizeFactor': number;
    /**
    * station_count integer
    */
    'stationCount': number;
    /**
    * station_system_count integer
    */
    'stationSystemCount': number;
    /**
    * is_unique boolean
    */
    'isUnique': boolean;
}

/**
* Not found
*/
export class GetUniverseGraphicsGraphicIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseGraphicsGraphicIdOk {
    /**
    * graphic_id integer
    */
    'graphicId': number;
    /**
    * graphic_file string
    */
    'graphicFile': string;
    /**
    * sof_race_name string
    */
    'sofRaceName': string;
    /**
    * sof_fation_name string
    */
    'sofFationName': string;
    /**
    * sof_dna string
    */
    'sofDna': string;
    /**
    * sof_hull_name string
    */
    'sofHullName': string;
    /**
    * collision_file string
    */
    'collisionFile': string;
    /**
    * icon_folder string
    */
    'iconFolder': string;
}

/**
* Not found
*/
export class GetUniverseGroupsGroupIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseGroupsGroupIdOk {
    /**
    * group_id integer
    */
    'groupId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * published boolean
    */
    'published': boolean;
    /**
    * category_id integer
    */
    'categoryId': number;
    /**
    * types array
    */
    'types': Array<number>;
}

/**
* Not found
*/
export class GetUniverseMoonsMoonIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseMoonsMoonIdOk {
    /**
    * moon_id integer
    */
    'moonId': number;
    /**
    * name string
    */
    'name': string;
    'position': GetUniverseMoonsMoonIdPosition;
    /**
    * The solar system this moon is in
    */
    'systemId': number;
}

/**
* position object
*/
export class GetUniverseMoonsMoonIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* Not found
*/
export class GetUniversePlanetsPlanetIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniversePlanetsPlanetIdOk {
    /**
    * planet_id integer
    */
    'planetId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * type_id integer
    */
    'typeId': number;
    'position': GetUniversePlanetsPlanetIdPosition;
    /**
    * The solar system this planet is in
    */
    'systemId': number;
}

/**
* position object
*/
export class GetUniversePlanetsPlanetIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* 200 ok object
*/
export class GetUniverseRaces200Ok {
    /**
    * race_id integer
    */
    'raceId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * description string
    */
    'description': string;
    /**
    * The alliance generally associated with this race
    */
    'allianceId': number;
}

/**
* Not found
*/
export class GetUniverseRegionsRegionIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseRegionsRegionIdOk {
    /**
    * region_id integer
    */
    'regionId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * description string
    */
    'description': string;
    /**
    * constellations array
    */
    'constellations': Array<number>;
}

/**
* Schematic not found
*/
export class GetUniverseSchematicsSchematicIdNotFound {
    /**
    * error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseSchematicsSchematicIdOk {
    /**
    * schematic_name string
    */
    'schematicName': string;
    /**
    * Time in seconds to process a run
    */
    'cycleTime': number;
}

/**
* destination object
*/
export class GetUniverseStargatesStargateIdDestination {
    /**
    * The solar system this stargate connects to
    */
    'systemId': number;
    /**
    * The stargate this stargate connects to
    */
    'stargateId': number;
}

/**
* Not found
*/
export class GetUniverseStargatesStargateIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseStargatesStargateIdOk {
    /**
    * stargate_id integer
    */
    'stargateId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * type_id integer
    */
    'typeId': number;
    'position': GetUniverseStargatesStargateIdPosition;
    /**
    * The solar system this stargate is in
    */
    'systemId': number;
    'destination': GetUniverseStargatesStargateIdDestination;
}

/**
* position object
*/
export class GetUniverseStargatesStargateIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* 200 ok object
*/
export class GetUniverseStarsStarIdOk {
    /**
    * name string
    */
    'name': string;
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * Age of star in years
    */
    'age': number;
    /**
    * luminosity number
    */
    'luminosity': number;
    /**
    * radius integer
    */
    'radius': number;
    /**
    * spectral_class string
    */
    'spectralClass': GetUniverseStarsStarIdOk.SpectralClassEnum;
    /**
    * temperature integer
    */
    'temperature': number;
}

export namespace GetUniverseStarsStarIdOk {
    export enum SpectralClassEnum {
        K2V = <any> 'K2 V',
        K4V = <any> 'K4 V',
        G2V = <any> 'G2 V',
        G8V = <any> 'G8 V',
        M7V = <any> 'M7 V',
        K7V = <any> 'K7 V',
        M2V = <any> 'M2 V',
        K5V = <any> 'K5 V',
        M3V = <any> 'M3 V',
        G0V = <any> 'G0 V',
        G7V = <any> 'G7 V',
        G3V = <any> 'G3 V',
        F9V = <any> 'F9 V',
        G5V = <any> 'G5 V',
        F6V = <any> 'F6 V',
        K8V = <any> 'K8 V',
        K9V = <any> 'K9 V',
        K6V = <any> 'K6 V',
        G9V = <any> 'G9 V',
        G6V = <any> 'G6 V',
        G4VI = <any> 'G4 VI',
        G4V = <any> 'G4 V',
        F8V = <any> 'F8 V',
        F2V = <any> 'F2 V',
        F1V = <any> 'F1 V',
        K3V = <any> 'K3 V',
        F0VI = <any> 'F0 VI',
        G1VI = <any> 'G1 VI',
        G0VI = <any> 'G0 VI',
        K1V = <any> 'K1 V',
        M4V = <any> 'M4 V',
        M1V = <any> 'M1 V',
        M6V = <any> 'M6 V',
        M0V = <any> 'M0 V',
        K2IV = <any> 'K2 IV',
        G2VI = <any> 'G2 VI',
        K0V = <any> 'K0 V',
        K5IV = <any> 'K5 IV',
        F5VI = <any> 'F5 VI',
        G6VI = <any> 'G6 VI',
        F6VI = <any> 'F6 VI',
        F2IV = <any> 'F2 IV',
        G3VI = <any> 'G3 VI',
        M8V = <any> 'M8 V',
        F1VI = <any> 'F1 VI',
        K1IV = <any> 'K1 IV',
        F7V = <any> 'F7 V',
        G5VI = <any> 'G5 VI',
        M5V = <any> 'M5 V',
        G7VI = <any> 'G7 VI',
        F5V = <any> 'F5 V',
        F4VI = <any> 'F4 VI',
        F8VI = <any> 'F8 VI',
        K3IV = <any> 'K3 IV',
        F4IV = <any> 'F4 IV',
        F0V = <any> 'F0 V',
        G7IV = <any> 'G7 IV',
        G8VI = <any> 'G8 VI',
        F2VI = <any> 'F2 VI',
        F4V = <any> 'F4 V',
        F7VI = <any> 'F7 VI',
        F3V = <any> 'F3 V',
        G1V = <any> 'G1 V',
        G9VI = <any> 'G9 VI',
        F3IV = <any> 'F3 IV',
        F9VI = <any> 'F9 VI',
        M9V = <any> 'M9 V',
        K0IV = <any> 'K0 IV',
        F1IV = <any> 'F1 IV',
        G4IV = <any> 'G4 IV',
        F3VI = <any> 'F3 VI',
        K4IV = <any> 'K4 IV',
        G5IV = <any> 'G5 IV',
        G3IV = <any> 'G3 IV',
        G1IV = <any> 'G1 IV',
        K7IV = <any> 'K7 IV',
        G0IV = <any> 'G0 IV',
        K6IV = <any> 'K6 IV',
        K9IV = <any> 'K9 IV',
        G2IV = <any> 'G2 IV',
        F9IV = <any> 'F9 IV',
        F0IV = <any> 'F0 IV',
        K8IV = <any> 'K8 IV',
        G8IV = <any> 'G8 IV',
        F6IV = <any> 'F6 IV',
        F5IV = <any> 'F5 IV',
        A0 = <any> 'A0',
        A0IV = <any> 'A0IV',
        A0IV2 = <any> 'A0IV2'
    }
}
/**
* Not found
*/
export class GetUniverseStationsStationIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseStationsStationIdOk {
    /**
    * station_id integer
    */
    'stationId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * ID of the corporation that controls this station
    */
    'owner': number;
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * race_id integer
    */
    'raceId': number;
    'position': GetUniverseStationsStationIdPosition;
    /**
    * The solar system this station is in
    */
    'systemId': number;
    /**
    * reprocessing_efficiency number
    */
    'reprocessingEfficiency': number;
    /**
    * reprocessing_stations_take number
    */
    'reprocessingStationsTake': number;
    /**
    * max_dockable_ship_volume number
    */
    'maxDockableShipVolume': number;
    /**
    * office_rental_cost number
    */
    'officeRentalCost': number;
    /**
    * services array
    */
    'services': Array<GetUniverseStationsStationIdOk.ServicesEnum>;
}

export namespace GetUniverseStationsStationIdOk {
    export enum ServicesEnum {
        BountyMissions = <any> 'bounty-missions',
        AssasinationMissions = <any> 'assasination-missions',
        CourierMissions = <any> 'courier-missions',
        Interbus = <any> 'interbus',
        ReprocessingPlant = <any> 'reprocessing-plant',
        Refinery = <any> 'refinery',
        Market = <any> 'market',
        BlackMarket = <any> 'black-market',
        StockExchange = <any> 'stock-exchange',
        Cloning = <any> 'cloning',
        Surgery = <any> 'surgery',
        DnaTherapy = <any> 'dna-therapy',
        RepairFacilities = <any> 'repair-facilities',
        Factory = <any> 'factory',
        Labratory = <any> 'labratory',
        Gambling = <any> 'gambling',
        Fitting = <any> 'fitting',
        Paintshop = <any> 'paintshop',
        News = <any> 'news',
        Storage = <any> 'storage',
        Insurance = <any> 'insurance',
        Docking = <any> 'docking',
        OfficeRental = <any> 'office-rental',
        JumpCloneFacility = <any> 'jump-clone-facility',
        LoyaltyPointStore = <any> 'loyalty-point-store',
        NavyOffices = <any> 'navy-offices',
        SecurityOffices = <any> 'security-offices'
    }
}
/**
* position object
*/
export class GetUniverseStationsStationIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* Not found
*/
export class GetUniverseStructuresStructureIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseStructuresStructureIdOk {
    /**
    * The full name of the structure
    */
    'name': string;
    /**
    * solar_system_id integer
    */
    'solarSystemId': number;
    /**
    * type_id integer
    */
    'typeId': number;
    'position': GetUniverseStructuresStructureIdPosition;
}

/**
* Coordinates of the structure in Cartesian space relative to the Sun, in metres. 
*/
export class GetUniverseStructuresStructureIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* 200 ok object
*/
export class GetUniverseSystemJumps200Ok {
    /**
    * system_id integer
    */
    'systemId': number;
    /**
    * ship_jumps integer
    */
    'shipJumps': number;
}

/**
* 200 ok object
*/
export class GetUniverseSystemKills200Ok {
    /**
    * system_id integer
    */
    'systemId': number;
    /**
    * Number of player ships killed in this system
    */
    'shipKills': number;
    /**
    * Number of NPC ships killed in this system
    */
    'npcKills': number;
    /**
    * Number of pods killed in this system
    */
    'podKills': number;
}

/**
* Not found
*/
export class GetUniverseSystemsSystemIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseSystemsSystemIdOk {
    /**
    * star_id integer
    */
    'starId': number;
    /**
    * system_id integer
    */
    'systemId': number;
    /**
    * name string
    */
    'name': string;
    'position': GetUniverseSystemsSystemIdPosition;
    /**
    * security_status number
    */
    'securityStatus': number;
    /**
    * security_class string
    */
    'securityClass': string;
    /**
    * The constellation this solar system is in
    */
    'constellationId': number;
    /**
    * planets array
    */
    'planets': Array<GetUniverseSystemsSystemIdPlanet>;
    /**
    * stargates array
    */
    'stargates': Array<number>;
    /**
    * stations array
    */
    'stations': Array<number>;
}

/**
* planet object
*/
export class GetUniverseSystemsSystemIdPlanet {
    /**
    * planet_id integer
    */
    'planetId': number;
    /**
    * moons array
    */
    'moons': Array<number>;
}

/**
* position object
*/
export class GetUniverseSystemsSystemIdPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* dogma_attribute object
*/
export class GetUniverseTypesTypeIdDogmaAttribute {
    /**
    * attribute_id integer
    */
    'attributeId': number;
    /**
    * value number
    */
    'value': number;
}

/**
* dogma_effect object
*/
export class GetUniverseTypesTypeIdDogmaEffect {
    /**
    * effect_id integer
    */
    'effectId': number;
    /**
    * is_default boolean
    */
    'isDefault': boolean;
}

/**
* Not found
*/
export class GetUniverseTypesTypeIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetUniverseTypesTypeIdOk {
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * name string
    */
    'name': string;
    /**
    * description string
    */
    'description': string;
    /**
    * published boolean
    */
    'published': boolean;
    /**
    * group_id integer
    */
    'groupId': number;
    /**
    * This only exists for types that can be put on the market
    */
    'marketGroupId': number;
    /**
    * radius number
    */
    'radius': number;
    /**
    * volume number
    */
    'volume': number;
    /**
    * packaged_volume number
    */
    'packagedVolume': number;
    /**
    * icon_id integer
    */
    'iconId': number;
    /**
    * capacity number
    */
    'capacity': number;
    /**
    * portion_size integer
    */
    'portionSize': number;
    /**
    * mass number
    */
    'mass': number;
    /**
    * graphic_id integer
    */
    'graphicId': number;
    /**
    * dogma_attributes array
    */
    'dogmaAttributes': Array<GetUniverseTypesTypeIdDogmaAttribute>;
    /**
    * dogma_effects array
    */
    'dogmaEffects': Array<GetUniverseTypesTypeIdDogmaEffect>;
}

/**
* The aggressor corporation or alliance that declared this war, only contains either corporation_id or alliance_id
*/
export class GetWarsWarIdAggressor {
    /**
    * Corporation ID if and only if the aggressor is a corporation
    */
    'corporationId': number;
    /**
    * Alliance ID if and only if the aggressor is an alliance
    */
    'allianceId': number;
    /**
    * The number of ships the aggressor has killed
    */
    'shipsKilled': number;
    /**
    * ISK value of ships the aggressor has destroyed
    */
    'iskDestroyed': number;
}

/**
* ally object
*/
export class GetWarsWarIdAlly {
    /**
    * Corporation ID if and only if this ally is a corporation
    */
    'corporationId': number;
    /**
    * Alliance ID if and only if this ally is an alliance
    */
    'allianceId': number;
}

/**
* The defending corporation or alliance that declared this war, only contains either corporation_id or alliance_id
*/
export class GetWarsWarIdDefender {
    /**
    * Corporation ID if and only if the defender is a corporation
    */
    'corporationId': number;
    /**
    * Alliance ID if and only if the defender is an alliance
    */
    'allianceId': number;
    /**
    * The number of ships the defender has killed
    */
    'shipsKilled': number;
    /**
    * ISK value of ships the defender has killed
    */
    'iskDestroyed': number;
}

/**
* 200 ok object
*/
export class GetWarsWarIdKillmails200Ok {
    /**
    * ID of this killmail
    */
    'killmailId': number;
    /**
    * A hash of this killmail
    */
    'killmailHash': string;
}

/**
* Unprocessable entity
*/
export class GetWarsWarIdKillmailsUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class GetWarsWarIdOk {
    /**
    * ID of the specified war
    */
    'id': number;
    /**
    * Time that the war was declared
    */
    'declared': Date;
    /**
    * Time when the war started and both sides could shoot each other
    */
    'started': Date;
    /**
    * Time the war was retracted but both sides could still shoot each other
    */
    'retracted': Date;
    /**
    * Time the war ended and shooting was no longer allowed
    */
    'finished': Date;
    /**
    * Was the war declared mutual by both parties
    */
    'mutual': boolean;
    /**
    * Is the war currently open for allies or not
    */
    'openForAllies': boolean;
    'aggressor': GetWarsWarIdAggressor;
    'defender': GetWarsWarIdDefender;
    /**
    * allied corporations or alliances, each object contains either corporation_id or alliance_id
    */
    'allies': Array<GetWarsWarIdAlly>;
}

/**
* Unprocessable entity
*/
export class GetWarsWarIdUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error': string;
}

/**
* Internal server error model
*/
export class InternalServerError {
    /**
    * Internal server error message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class PostCharactersAffiliation200Ok {
    /**
    * The character's ID
    */
    'characterId': number;
    /**
    * The character's corporation ID
    */
    'corporationId': number;
    /**
    * The character's alliance ID, if their corporation is in an alliance
    */
    'allianceId': number;
    /**
    * The character's faction ID, if their corporation is in a faction
    */
    'factionId': number;
}

/**
* Not found
*/
export class PostCharactersAffiliationNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 200 ok object
*/
export class PostCharactersCharacterIdAssetsLocations200Ok {
    /**
    * item_id integer
    */
    'itemId': number;
    'position': PostCharactersCharacterIdAssetsLocationsPosition;
}

/**
* position object
*/
export class PostCharactersCharacterIdAssetsLocationsPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* 200 ok object
*/
export class PostCharactersCharacterIdAssetsNames200Ok {
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * name string
    */
    'name': string;
}

/**
* 201 created object
*/
export class PostCharactersCharacterIdFittingsCreated {
    /**
    * fitting_id integer
    */
    'fittingId': number;
}

/**
* fitting object
*/
export class PostCharactersCharacterIdFittingsFitting {
    /**
    * name string
    */
    'name': string;
    /**
    * description string
    */
    'description': string;
    /**
    * ship_type_id integer
    */
    'shipTypeId': number;
    /**
    * items array
    */
    'items': Array<PostCharactersCharacterIdFittingsItem>;
}

/**
* item object
*/
export class PostCharactersCharacterIdFittingsItem {
    /**
    * type_id integer
    */
    'typeId': number;
    /**
    * flag integer
    */
    'flag': number;
    /**
    * quantity integer
    */
    'quantity': number;
}

/**
* Bad request
*/
export class PostCharactersCharacterIdMailBadRequest {
    /**
    * Bad request message
    */
    'error': string;
}

/**
* label object
*/
export class PostCharactersCharacterIdMailLabelsLabel {
    /**
    * name string
    */
    'name': string;
    /**
    * Hexadecimal string representing label color, in RGB format
    */
    'color': PostCharactersCharacterIdMailLabelsLabel.ColorEnum;
}

export namespace PostCharactersCharacterIdMailLabelsLabel {
    export enum ColorEnum {
        _0000fe = <any> '#0000fe',
        _006634 = <any> '#006634',
        _0099ff = <any> '#0099ff',
        _00ff33 = <any> '#00ff33',
        _01ffff = <any> '#01ffff',
        _349800 = <any> '#349800',
        _660066 = <any> '#660066',
        _666666 = <any> '#666666',
        _999999 = <any> '#999999',
        _99ffff = <any> '#99ffff',
        _9a0000 = <any> '#9a0000',
        Ccff9a = <any> '#ccff9a',
        E6e6e6 = <any> '#e6e6e6',
        Fe0000 = <any> '#fe0000',
        Ff6600 = <any> '#ff6600',
        Ffff01 = <any> '#ffff01',
        Ffffcd = <any> '#ffffcd',
        Ffffff = <any> '#ffffff'
    }
}
/**
* mail object
*/
export class PostCharactersCharacterIdMailMail {
    /**
    * recipients array
    */
    'recipients': Array<PostCharactersCharacterIdMailRecipient>;
    /**
    * subject string
    */
    'subject': string;
    /**
    * body string
    */
    'body': string;
    /**
    * approved_cost integer
    */
    'approvedCost': number;
}

/**
* recipient object
*/
export class PostCharactersCharacterIdMailRecipient {
    /**
    * recipient_type string
    */
    'recipientType': PostCharactersCharacterIdMailRecipient.RecipientTypeEnum;
    /**
    * recipient_id integer
    */
    'recipientId': number;
}

export namespace PostCharactersCharacterIdMailRecipient {
    export enum RecipientTypeEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        MailingList = <any> 'mailing_list'
    }
}
/**
* 200 ok object
*/
export class PostCorporationsCorporationIdAssetsLocations200Ok {
    /**
    * item_id integer
    */
    'itemId': number;
    'position': PostCorporationsCorporationIdAssetsLocationsPosition;
}

/**
* position object
*/
export class PostCorporationsCorporationIdAssetsLocationsPosition {
    /**
    * x number
    */
    'x': number;
    /**
    * y number
    */
    'y': number;
    /**
    * z number
    */
    'z': number;
}

/**
* 200 ok object
*/
export class PostCorporationsCorporationIdAssetsNames200Ok {
    /**
    * item_id integer
    */
    'itemId': number;
    /**
    * name string
    */
    'name': string;
}

/**
* invitation object
*/
export class PostFleetsFleetIdMembersInvitation {
    /**
    * The character you want to invite
    */
    'characterId': number;
    /**
    * If a character is invited with the `fleet_commander` role, neither `wing_id` or `squad_id` should be specified. If a character is invited with the `wing_commander` role, only `wing_id` should be specified. If a character is invited with the `squad_commander` role, both `wing_id` and `squad_id` should be specified. If a character is invited with the `squad_member` role, `wing_id` and `squad_id` should either both be specified or not specified at all. If they aren’t specified, the invited character will join any squad with available positions.
    */
    'role': PostFleetsFleetIdMembersInvitation.RoleEnum;
    /**
    * wing_id integer
    */
    'wingId': number;
    /**
    * squad_id integer
    */
    'squadId': number;
}

export namespace PostFleetsFleetIdMembersInvitation {
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        WingCommander = <any> 'wing_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member'
    }
}
/**
* Not found
*/
export class PostFleetsFleetIdMembersNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 422 unprocessable entity object
*/
export class PostFleetsFleetIdMembersUnprocessableEntity {
    /**
    * error message
    */
    'error': string;
}

/**
* 201 created object
*/
export class PostFleetsFleetIdWingsCreated {
    /**
    * The wing_id of the newly created wing
    */
    'wingId': number;
}

/**
* Not found
*/
export class PostFleetsFleetIdWingsNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 201 created object
*/
export class PostFleetsFleetIdWingsWingIdSquadsCreated {
    /**
    * The squad_id of the newly created squad
    */
    'squadId': number;
}

/**
* Not found
*/
export class PostFleetsFleetIdWingsWingIdSquadsNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* new_mail object
*/
export class PostUiOpenwindowNewmailNewMail {
    /**
    * subject string
    */
    'subject': string;
    /**
    * body string
    */
    'body': string;
    /**
    * recipients array
    */
    'recipients': Array<number>;
    /**
    * Corporations, alliances and mailing lists are all types of mailing groups. You may only send to one mailing group, at a time, so you may fill out either this field or the to_corp_or_alliance_ids field
    */
    'toMailingListId': number;
    /**
    * to_corp_or_alliance_id integer
    */
    'toCorpOrAllianceId': number;
}

/**
* Unprocessable entity
*/
export class PostUiOpenwindowNewmailUnprocessableEntity {
    /**
    * Unprocessable entity message
    */
    'error': string;
}

/**
* agent object
*/
export class PostUniverseIdsAgent {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
}

/**
* alliance object
*/
export class PostUniverseIdsAlliance {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
}

/**
* character object
*/
export class PostUniverseIdsCharacter {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
}

/**
* constellation object
*/
export class PostUniverseIdsConstellation {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
}

/**
* corporation object
*/
export class PostUniverseIdsCorporation {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
}

/**
* faction object
*/
export class PostUniverseIdsFaction {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
}

/**
* inventory_type object
*/
export class PostUniverseIdsInventoryType {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
}

/**
* 200 ok object
*/
export class PostUniverseIdsOk {
    /**
    * agents array
    */
    'agents': Array<PostUniverseIdsAgent>;
    /**
    * alliances array
    */
    'alliances': Array<PostUniverseIdsAlliance>;
    /**
    * characters array
    */
    'characters': Array<PostUniverseIdsCharacter>;
    /**
    * constellations array
    */
    'constellations': Array<PostUniverseIdsConstellation>;
    /**
    * corporations array
    */
    'corporations': Array<PostUniverseIdsCorporation>;
    /**
    * factions array
    */
    'factions': Array<PostUniverseIdsFaction>;
    /**
    * inventory_types array
    */
    'inventoryTypes': Array<PostUniverseIdsInventoryType>;
    /**
    * regions array
    */
    'regions': Array<PostUniverseIdsRegion>;
    /**
    * systems array
    */
    'systems': Array<PostUniverseIdsSystem>;
    /**
    * stations array
    */
    'stations': Array<PostUniverseIdsStation>;
}

/**
* region object
*/
export class PostUniverseIdsRegion {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
}

/**
* Service unavailable
*/
export class PostUniverseIdsServiceUnavailable {
    /**
    * Service unavailable message
    */
    'error': string;
}

/**
* station object
*/
export class PostUniverseIdsStation {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
}

/**
* system object
*/
export class PostUniverseIdsSystem {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
}

/**
* 200 ok object
*/
export class PostUniverseNames200Ok {
    /**
    * id integer
    */
    'id': number;
    /**
    * name string
    */
    'name': string;
    /**
    * category string
    */
    'category': PostUniverseNames200Ok.CategoryEnum;
}

export namespace PostUniverseNames200Ok {
    export enum CategoryEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Constellation = <any> 'constellation',
        Corporation = <any> 'corporation',
        InventoryType = <any> 'inventory_type',
        Region = <any> 'region',
        SolarSystem = <any> 'solar_system',
        Station = <any> 'station'
    }
}
/**
* Not found
*/
export class PostUniverseNamesNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* response object
*/
export class PutCharactersCharacterIdCalendarEventIdResponse {
    /**
    * response string
    */
    'response': PutCharactersCharacterIdCalendarEventIdResponse.ResponseEnum;
}

export namespace PutCharactersCharacterIdCalendarEventIdResponse {
    export enum ResponseEnum {
        Accepted = <any> 'accepted',
        Declined = <any> 'declined',
        Tentative = <any> 'tentative'
    }
}
/**
* Bad request
*/
export class PutCharactersCharacterIdMailMailIdBadRequest {
    /**
    * Bad request message
    */
    'error': string;
}

/**
* contents object
*/
export class PutCharactersCharacterIdMailMailIdContents {
    /**
    * Whether the mail is flagged as read
    */
    'read': boolean;
    /**
    * Labels to assign to the mail. Pre-existing labels are unassigned.
    */
    'labels': Array<number>;
}

/**
* new_schedule object
*/
export class PutCorporationsCorporationIdStructuresStructureIdNewSchedule {
    /**
    * Day of the week, zero-indexed to Monday
    */
    'day': number;
    /**
    * Hour of the day evetime, zero-indexed to midnight
    */
    'hour': number;
}

/**
* Bad request
*/
export class PutFleetsFleetIdBadRequest {
    /**
    * Bad request message
    */
    'error': string;
}

/**
* movement object
*/
export class PutFleetsFleetIdMembersMemberIdMovement {
    /**
    * If a character is moved to the `fleet_commander` role, neither `wing_id` or `squad_id` should be specified. If a character is moved to the `wing_commander` role, only `wing_id` should be specified. If a character is moved to the `squad_commander` role, both `wing_id` and `squad_id` should be specified. If a character is moved to the `squad_member` role, both `wing_id` and `squad_id` should be specified.
    */
    'role': PutFleetsFleetIdMembersMemberIdMovement.RoleEnum;
    /**
    * wing_id integer
    */
    'wingId': number;
    /**
    * squad_id integer
    */
    'squadId': number;
}

export namespace PutFleetsFleetIdMembersMemberIdMovement {
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        WingCommander = <any> 'wing_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member'
    }
}
/**
* Not found
*/
export class PutFleetsFleetIdMembersMemberIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* 422 unprocessable entity object
*/
export class PutFleetsFleetIdMembersMemberIdUnprocessableEntity {
    /**
    * error message
    */
    'error': string;
}

/**
* new_settings object
*/
export class PutFleetsFleetIdNewSettings {
    /**
    * New fleet MOTD in CCP flavoured HTML
    */
    'motd': string;
    /**
    * Should free-move be enabled in the fleet
    */
    'isFreeMove': boolean;
}

/**
* Not found
*/
export class PutFleetsFleetIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* naming object
*/
export class PutFleetsFleetIdSquadsSquadIdNaming {
    /**
    * name string
    */
    'name': string;
}

/**
* Not found
*/
export class PutFleetsFleetIdSquadsSquadIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}

/**
* naming object
*/
export class PutFleetsFleetIdWingsWingIdNaming {
    /**
    * name string
    */
    'name': string;
}

/**
* Not found
*/
export class PutFleetsFleetIdWingsWingIdNotFound {
    /**
    * Not found message
    */
    'error': string;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum AllianceApiApiKeys {
}

export class AllianceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AllianceApiApiKeys, value: string) {
        this.authentications[AllianceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * List all alliances
     * List all active player alliances  --- Alternate route: &#x60;/dev/alliances/&#x60;  Alternate route: &#x60;/legacy/alliances/&#x60;  Alternate route: &#x60;/v1/alliances/&#x60;  --- This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getAlliances (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/alliances/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get alliance information
     * Public information about an alliance  --- Alternate route: &#x60;/dev/alliances/{alliance_id}/&#x60;  Alternate route: &#x60;/v3/alliances/{alliance_id}/&#x60;  --- This route is cached for up to 3600 seconds
     * @param allianceId An EVE alliance ID
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getAlliancesAllianceId (allianceId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetAlliancesAllianceIdOk;  }> {
        const localVarPath = this.basePath + '/alliances/{alliance_id}/'
            .replace('{' + 'alliance_id' + '}', String(allianceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'allianceId' is not null or undefined
        if (allianceId === null || allianceId === undefined) {
            throw new Error('Required parameter allianceId was null or undefined when calling getAlliancesAllianceId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetAlliancesAllianceIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List alliance&#39;s corporations
     * List all current member corporations of an alliance  --- Alternate route: &#x60;/dev/alliances/{alliance_id}/corporations/&#x60;  Alternate route: &#x60;/legacy/alliances/{alliance_id}/corporations/&#x60;  Alternate route: &#x60;/v1/alliances/{alliance_id}/corporations/&#x60;  --- This route is cached for up to 3600 seconds
     * @param allianceId An EVE alliance ID
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getAlliancesAllianceIdCorporations (allianceId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/alliances/{alliance_id}/corporations/'
            .replace('{' + 'alliance_id' + '}', String(allianceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'allianceId' is not null or undefined
        if (allianceId === null || allianceId === undefined) {
            throw new Error('Required parameter allianceId was null or undefined when calling getAlliancesAllianceIdCorporations.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get alliance icon
     * Get the icon urls for a alliance  --- Alternate route: &#x60;/dev/alliances/{alliance_id}/icons/&#x60;  Alternate route: &#x60;/legacy/alliances/{alliance_id}/icons/&#x60;  Alternate route: &#x60;/v1/alliances/{alliance_id}/icons/&#x60;  --- This route is cached for up to 3600 seconds
     * @param allianceId An EVE alliance ID
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getAlliancesAllianceIdIcons (allianceId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetAlliancesAllianceIdIconsOk;  }> {
        const localVarPath = this.basePath + '/alliances/{alliance_id}/icons/'
            .replace('{' + 'alliance_id' + '}', String(allianceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'allianceId' is not null or undefined
        if (allianceId === null || allianceId === undefined) {
            throw new Error('Required parameter allianceId was null or undefined when calling getAlliancesAllianceIdIcons.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetAlliancesAllianceIdIconsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get alliance names
     * Resolve a set of alliance IDs to alliance names  --- Alternate route: &#x60;/dev/alliances/names/&#x60;  Alternate route: &#x60;/v2/alliances/names/&#x60;  --- This route is cached for up to 3600 seconds
     * @param allianceIds A comma separated list of alliance IDs
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getAlliancesNames (allianceIds: Array<number>, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetAlliancesNames200Ok>;  }> {
        const localVarPath = this.basePath + '/alliances/names/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'allianceIds' is not null or undefined
        if (allianceIds === null || allianceIds === undefined) {
            throw new Error('Required parameter allianceIds was null or undefined when calling getAlliancesNames.');
        }

        if (allianceIds !== undefined) {
            queryParameters['alliance_ids'] = allianceIds;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetAlliancesNames200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AssetsApiApiKeys {
}

export class AssetsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AssetsApiApiKeys, value: string) {
        this.authentications[AssetsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get character assets
     * Return a list of the characters assets  --- Alternate route: &#x60;/dev/characters/{character_id}/assets/&#x60;  Alternate route: &#x60;/v3/characters/{character_id}/assets/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdAssets (characterId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdAssets200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/assets/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdAssets.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdAssets200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation assets
     * Return a list of the corporation assets  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/assets/&#x60;  Alternate route: &#x60;/v2/corporations/{corporation_id}/assets/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdAssets (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdAssets200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/assets/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdAssets.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdAssets200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character asset locations
     * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: &#x60;/dev/characters/{character_id}/assets/locations/&#x60;  Alternate route: &#x60;/v2/characters/{character_id}/assets/locations/&#x60; 
     * @param characterId An EVE character ID
     * @param itemIds A list of item ids
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postCharactersCharacterIdAssetsLocations (characterId: number, itemIds: Array<number>, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<PostCharactersCharacterIdAssetsLocations200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/assets/locations/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdAssetsLocations.');
        }

        // verify required parameter 'itemIds' is not null or undefined
        if (itemIds === null || itemIds === undefined) {
            throw new Error('Required parameter itemIds was null or undefined when calling postCharactersCharacterIdAssetsLocations.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: itemIds,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PostCharactersCharacterIdAssetsLocations200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character asset names
     * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: &#x60;/dev/characters/{character_id}/assets/names/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/assets/names/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/assets/names/&#x60; 
     * @param characterId An EVE character ID
     * @param itemIds A list of item ids
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postCharactersCharacterIdAssetsNames (characterId: number, itemIds: Array<number>, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<PostCharactersCharacterIdAssetsNames200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/assets/names/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdAssetsNames.');
        }

        // verify required parameter 'itemIds' is not null or undefined
        if (itemIds === null || itemIds === undefined) {
            throw new Error('Required parameter itemIds was null or undefined when calling postCharactersCharacterIdAssetsNames.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: itemIds,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PostCharactersCharacterIdAssetsNames200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation asset locations
     * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/assets/locations/&#x60;  Alternate route: &#x60;/v2/corporations/{corporation_id}/assets/locations/&#x60;   --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param itemIds A list of item ids
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postCorporationsCorporationIdAssetsLocations (corporationId: number, itemIds: Array<number>, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<PostCorporationsCorporationIdAssetsLocations200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/assets/locations/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling postCorporationsCorporationIdAssetsLocations.');
        }

        // verify required parameter 'itemIds' is not null or undefined
        if (itemIds === null || itemIds === undefined) {
            throw new Error('Required parameter itemIds was null or undefined when calling postCorporationsCorporationIdAssetsLocations.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: itemIds,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PostCorporationsCorporationIdAssetsLocations200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get coporation asset names
     * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships.  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/assets/names/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/assets/names/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/assets/names/&#x60;   --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param itemIds A list of item ids
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postCorporationsCorporationIdAssetsNames (corporationId: number, itemIds: Array<number>, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<PostCorporationsCorporationIdAssetsNames200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/assets/names/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling postCorporationsCorporationIdAssetsNames.');
        }

        // verify required parameter 'itemIds' is not null or undefined
        if (itemIds === null || itemIds === undefined) {
            throw new Error('Required parameter itemIds was null or undefined when calling postCorporationsCorporationIdAssetsNames.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: itemIds,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PostCorporationsCorporationIdAssetsNames200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BookmarksApiApiKeys {
}

export class BookmarksApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: BookmarksApiApiKeys, value: string) {
        this.authentications[BookmarksApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * List bookmarks
     * A list of your character&#39;s personal bookmarks  --- Alternate route: &#x60;/dev/characters/{character_id}/bookmarks/&#x60;  Alternate route: &#x60;/v2/characters/{character_id}/bookmarks/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdBookmarks (characterId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBookmarks200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/bookmarks/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdBookmarks.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBookmarks200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List bookmark folders
     * A list of your character&#39;s personal bookmark folders  --- Alternate route: &#x60;/dev/characters/{character_id}/bookmarks/folders/&#x60;  Alternate route: &#x60;/v2/characters/{character_id}/bookmarks/folders/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdBookmarksFolders (characterId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBookmarksFolders200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/bookmarks/folders/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdBookmarksFolders.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBookmarksFolders200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List corporation bookmarks
     * A list of your corporation&#39;s bookmarks  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/bookmarks/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/bookmarks/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/bookmarks/&#x60;  --- This route is cached for up to 3600 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdBookmarks (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdBookmarks200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/bookmarks/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdBookmarks.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdBookmarks200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List corporation bookmark folders
     * A list of your corporation&#39;s bookmark folders  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/bookmarks/folders/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/bookmarks/folders/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/bookmarks/folders/&#x60;  --- This route is cached for up to 3600 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdBookmarksFolders (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdBookmarksFolders200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/bookmarks/folders/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdBookmarksFolders.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdBookmarksFolders200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CalendarApiApiKeys {
}

export class CalendarApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CalendarApiApiKeys, value: string) {
        this.authentications[CalendarApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * List calendar event summaries
     * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event.  --- Alternate route: &#x60;/dev/characters/{character_id}/calendar/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/calendar/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/calendar/&#x60;  --- This route is cached for up to 5 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param fromEvent The event ID to retrieve events from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdCalendar (characterId: number, datasource?: string, fromEvent?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCalendar200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/calendar/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdCalendar.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (fromEvent !== undefined) {
            queryParameters['from_event'] = fromEvent;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCalendar200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an event
     * Get all the information for a specific event  --- Alternate route: &#x60;/dev/characters/{character_id}/calendar/{event_id}/&#x60;  Alternate route: &#x60;/v3/characters/{character_id}/calendar/{event_id}/&#x60;  --- This route is cached for up to 5 seconds
     * @param characterId An EVE character ID
     * @param eventId The id of the event requested
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdCalendarEventId (characterId: number, eventId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdCalendarEventIdOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/calendar/{event_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'event_id' + '}', String(eventId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdCalendarEventId.');
        }

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getCharactersCharacterIdCalendarEventId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdCalendarEventIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get attendees
     * Get all invited attendees for a given event  --- Alternate route: &#x60;/dev/characters/{character_id}/calendar/{event_id}/attendees/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/calendar/{event_id}/attendees/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/calendar/{event_id}/attendees/&#x60;  --- This route is cached for up to 600 seconds
     * @param characterId An EVE character ID
     * @param eventId The id of the event requested
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdCalendarEventIdAttendees (characterId: number, eventId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCalendarEventIdAttendees200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/calendar/{event_id}/attendees/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'event_id' + '}', String(eventId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdCalendarEventIdAttendees.');
        }

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getCharactersCharacterIdCalendarEventIdAttendees.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCalendarEventIdAttendees200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Respond to an event
     * Set your response status to an event  --- Alternate route: &#x60;/dev/characters/{character_id}/calendar/{event_id}/&#x60;  Alternate route: &#x60;/v3/characters/{character_id}/calendar/{event_id}/&#x60; 
     * @param characterId An EVE character ID
     * @param eventId The ID of the event requested
     * @param response The response value to set, overriding current value.
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public putCharactersCharacterIdCalendarEventId (characterId: number, eventId: number, response: PutCharactersCharacterIdCalendarEventIdResponse, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/calendar/{event_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'event_id' + '}', String(eventId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling putCharactersCharacterIdCalendarEventId.');
        }

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling putCharactersCharacterIdCalendarEventId.');
        }

        // verify required parameter 'response' is not null or undefined
        if (response === null || response === undefined) {
            throw new Error('Required parameter response was null or undefined when calling putCharactersCharacterIdCalendarEventId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: response,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CharacterApiApiKeys {
}

export class CharacterApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CharacterApiApiKeys, value: string) {
        this.authentications[CharacterApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get character&#39;s public information
     * Public information about a character  --- Alternate route: &#x60;/dev/characters/{character_id}/&#x60;  Alternate route: &#x60;/v4/characters/{character_id}/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterId (characterId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get agents research
     * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints &#x3D; remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: &#x60;/dev/characters/{character_id}/agents_research/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/agents_research/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/agents_research/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdAgentsResearch (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdAgentsResearch200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/agents_research/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdAgentsResearch.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdAgentsResearch200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get blueprints
     * Return a list of blueprints the character owns  --- Alternate route: &#x60;/dev/characters/{character_id}/blueprints/&#x60;  Alternate route: &#x60;/v2/characters/{character_id}/blueprints/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdBlueprints (characterId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBlueprints200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/blueprints/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdBlueprints.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdBlueprints200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get chat channels
     * Return chat channels that a character is the owner or operator of  --- Alternate route: &#x60;/dev/characters/{character_id}/chat_channels/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/chat_channels/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/chat_channels/&#x60;  --- This route is cached for up to 300 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdChatChannels (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdChatChannels200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/chat_channels/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdChatChannels.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdChatChannels200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation history
     * Get a list of all the corporations a character has been a member of  --- Alternate route: &#x60;/dev/characters/{character_id}/corporationhistory/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/corporationhistory/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/corporationhistory/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdCorporationhistory (characterId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCorporationhistory200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/corporationhistory/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdCorporationhistory.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdCorporationhistory200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get jump fatigue
     * Return a character&#39;s jump activation and fatigue information  --- Alternate route: &#x60;/dev/characters/{character_id}/fatigue/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/fatigue/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/fatigue/&#x60;  --- This route is cached for up to 300 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdFatigue (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdFatigueOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fatigue/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdFatigue.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdFatigueOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get medals
     * Return a list of medals the character has  --- Alternate route: &#x60;/dev/characters/{character_id}/medals/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/medals/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/medals/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdMedals (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMedals200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/medals/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMedals.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMedals200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character notifications
     * Return character notifications  --- Alternate route: &#x60;/dev/characters/{character_id}/notifications/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/notifications/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/notifications/&#x60;  --- This route is cached for up to 600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdNotifications (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdNotifications200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/notifications/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdNotifications.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdNotifications200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get new contact notifications
     * Return notifications about having been added to someone&#39;s contact list  --- Alternate route: &#x60;/dev/characters/{character_id}/notifications/contacts/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/notifications/contacts/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/notifications/contacts/&#x60;  --- This route is cached for up to 600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdNotificationsContacts (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdNotificationsContacts200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/notifications/contacts/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdNotificationsContacts.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdNotificationsContacts200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character portraits
     * Get portrait urls for a character  --- Alternate route: &#x60;/dev/characters/{character_id}/portrait/&#x60;  Alternate route: &#x60;/v2/characters/{character_id}/portrait/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdPortrait (characterId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdPortraitOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/portrait/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdPortrait.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdPortraitOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character corporation roles
     * Returns a character&#39;s corporation roles  --- Alternate route: &#x60;/dev/characters/{character_id}/roles/&#x60;  Alternate route: &#x60;/v2/characters/{character_id}/roles/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdRoles (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdRolesOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/roles/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdRoles.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdRolesOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get standings
     * Return character standings from agents, NPC corporations, and factions  --- Alternate route: &#x60;/dev/characters/{character_id}/standings/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/standings/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/standings/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdStandings (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdStandings200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/standings/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdStandings.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdStandings200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Yearly aggregate stats
     * Returns aggregate yearly stats for a character  --- Alternate route: &#x60;/dev/characters/{character_id}/stats/&#x60;  Alternate route: &#x60;/v2/characters/{character_id}/stats/&#x60;  --- This route is cached for up to 86400 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdStats (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdStats200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/stats/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdStats.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdStats200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character corporation titles
     * Returns a character&#39;s titles  --- Alternate route: &#x60;/dev/characters/{character_id}/titles/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/titles/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/titles/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdTitles (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdTitles200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/titles/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdTitles.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdTitles200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character names
     * Resolve a set of character IDs to character names  --- Alternate route: &#x60;/dev/characters/names/&#x60;  Alternate route: &#x60;/legacy/characters/names/&#x60;  Alternate route: &#x60;/v1/characters/names/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterIds A comma separated list of character IDs
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersNames (characterIds: Array<number>, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersNames200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/names/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterIds' is not null or undefined
        if (characterIds === null || characterIds === undefined) {
            throw new Error('Required parameter characterIds was null or undefined when calling getCharactersNames.');
        }

        if (characterIds !== undefined) {
            queryParameters['character_ids'] = characterIds;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersNames200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Character affiliation
     * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: &#x60;/dev/characters/affiliation/&#x60;  Alternate route: &#x60;/legacy/characters/affiliation/&#x60;  Alternate route: &#x60;/v1/characters/affiliation/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned.
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postCharactersAffiliation (characters: Array<number>, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<PostCharactersAffiliation200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/affiliation/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characters' is not null or undefined
        if (characters === null || characters === undefined) {
            throw new Error('Required parameter characters was null or undefined when calling postCharactersAffiliation.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: characters,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PostCharactersAffiliation200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculate a CSPA charge cost
     * Takes a source character ID in the url and a set of target character ID&#39;s in the body, returns a CSPA charge cost  --- Alternate route: &#x60;/dev/characters/{character_id}/cspa/&#x60;  Alternate route: &#x60;/v4/characters/{character_id}/cspa/&#x60; 
     * @param characterId An EVE character ID
     * @param characters The target characters to calculate the charge for
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postCharactersCharacterIdCspa (characterId: number, characters: Array<number>, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/cspa/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdCspa.');
        }

        // verify required parameter 'characters' is not null or undefined
        if (characters === null || characters === undefined) {
            throw new Error('Required parameter characters was null or undefined when calling postCharactersCharacterIdCspa.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: characters,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ClonesApiApiKeys {
}

export class ClonesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ClonesApiApiKeys, value: string) {
        this.authentications[ClonesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get clones
     * A list of the character&#39;s clones  --- Alternate route: &#x60;/dev/characters/{character_id}/clones/&#x60;  Alternate route: &#x60;/v3/characters/{character_id}/clones/&#x60;  --- This route is cached for up to 120 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdClones (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdClonesOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/clones/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdClones.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdClonesOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get active implants
     * Return implants on the active clone of a character  --- Alternate route: &#x60;/dev/characters/{character_id}/implants/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/implants/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/implants/&#x60;  --- This route is cached for up to 300 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdImplants (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/implants/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdImplants.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContactsApiApiKeys {
}

export class ContactsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ContactsApiApiKeys, value: string) {
        this.authentications[ContactsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Delete contacts
     * Bulk delete contacts  --- Alternate route: &#x60;/dev/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/v2/characters/{character_id}/contacts/&#x60; 
     * @param characterId An EVE character ID
     * @param contactIds A list of contacts to delete
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public deleteCharactersCharacterIdContacts (characterId: number, contactIds: Array<number>, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdContacts.');
        }

        // verify required parameter 'contactIds' is not null or undefined
        if (contactIds === null || contactIds === undefined) {
            throw new Error('Required parameter contactIds was null or undefined when calling deleteCharactersCharacterIdContacts.');
        }

        if (contactIds !== undefined) {
            queryParameters['contact_ids'] = contactIds;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get alliance contacts
     * Return contacts of an alliance  --- Alternate route: &#x60;/dev/alliances/{alliance_id}/contacts/&#x60;  Alternate route: &#x60;/legacy/alliances/{alliance_id}/contacts/&#x60;  Alternate route: &#x60;/v1/alliances/{alliance_id}/contacts/&#x60;  --- This route is cached for up to 300 seconds
     * @param allianceId An EVE alliance ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getAlliancesAllianceIdContacts (allianceId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetAlliancesAllianceIdContacts200Ok>;  }> {
        const localVarPath = this.basePath + '/alliances/{alliance_id}/contacts/'
            .replace('{' + 'alliance_id' + '}', String(allianceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'allianceId' is not null or undefined
        if (allianceId === null || allianceId === undefined) {
            throw new Error('Required parameter allianceId was null or undefined when calling getAlliancesAllianceIdContacts.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetAlliancesAllianceIdContacts200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get contacts
     * Return contacts of a character  --- Alternate route: &#x60;/dev/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/contacts/&#x60;  --- This route is cached for up to 300 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdContacts (characterId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContacts200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdContacts.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContacts200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get contact labels
     * Return custom labels for contacts the character defined  --- Alternate route: &#x60;/dev/characters/{character_id}/contacts/labels/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/contacts/labels/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/contacts/labels/&#x60;  --- This route is cached for up to 300 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdContactsLabels (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContactsLabels200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/labels/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdContactsLabels.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContactsLabels200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation contacts
     * Return contacts of a corporation  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/contacts/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/contacts/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/contacts/&#x60;  --- This route is cached for up to 300 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdContacts (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContacts200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/contacts/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContacts.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContacts200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add contacts
     * Bulk add contacts with same settings  --- Alternate route: &#x60;/dev/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/contacts/&#x60; 
     * @param characterId An EVE character ID
     * @param contactIds A list of contacts to add
     * @param standing Standing for the new contact
     * @param datasource The server name you would like data from
     * @param labelId Add a custom label to the new contact
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param watched Whether the new contact should be watched, note this is only effective on characters
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postCharactersCharacterIdContacts (characterId: number, contactIds: Array<number>, standing: number, datasource?: string, labelId?: number, token?: string, userAgent?: string, watched?: boolean, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdContacts.');
        }

        // verify required parameter 'contactIds' is not null or undefined
        if (contactIds === null || contactIds === undefined) {
            throw new Error('Required parameter contactIds was null or undefined when calling postCharactersCharacterIdContacts.');
        }

        // verify required parameter 'standing' is not null or undefined
        if (standing === null || standing === undefined) {
            throw new Error('Required parameter standing was null or undefined when calling postCharactersCharacterIdContacts.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (labelId !== undefined) {
            queryParameters['label_id'] = labelId;
        }

        if (standing !== undefined) {
            queryParameters['standing'] = standing;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        if (watched !== undefined) {
            queryParameters['watched'] = watched;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: contactIds,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit contacts
     * Bulk edit contacts with same settings  --- Alternate route: &#x60;/dev/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/contacts/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/contacts/&#x60; 
     * @param characterId An EVE character ID
     * @param contactIds A list of contacts to edit
     * @param standing Standing for the contact
     * @param datasource The server name you would like data from
     * @param labelId Add a custom label to the contact, use 0 for clearing label
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param watched Whether the contact should be watched, note this is only effective on characters
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public putCharactersCharacterIdContacts (characterId: number, contactIds: Array<number>, standing: number, datasource?: string, labelId?: number, token?: string, userAgent?: string, watched?: boolean, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contacts/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling putCharactersCharacterIdContacts.');
        }

        // verify required parameter 'contactIds' is not null or undefined
        if (contactIds === null || contactIds === undefined) {
            throw new Error('Required parameter contactIds was null or undefined when calling putCharactersCharacterIdContacts.');
        }

        // verify required parameter 'standing' is not null or undefined
        if (standing === null || standing === undefined) {
            throw new Error('Required parameter standing was null or undefined when calling putCharactersCharacterIdContacts.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (labelId !== undefined) {
            queryParameters['label_id'] = labelId;
        }

        if (standing !== undefined) {
            queryParameters['standing'] = standing;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        if (watched !== undefined) {
            queryParameters['watched'] = watched;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: contactIds,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContractsApiApiKeys {
}

export class ContractsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ContractsApiApiKeys, value: string) {
        this.authentications[ContractsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get contracts
     * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \&quot;in_progress\&quot;.  --- Alternate route: &#x60;/dev/characters/{character_id}/contracts/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/contracts/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/contracts/&#x60;  --- This route is cached for up to 300 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdContracts (characterId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContracts200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contracts/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdContracts.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContracts200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get contract bids
     * Lists bids on a particular auction contract  --- Alternate route: &#x60;/dev/characters/{character_id}/contracts/{contract_id}/bids/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/contracts/{contract_id}/bids/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/contracts/{contract_id}/bids/&#x60;  --- This route is cached for up to 300 seconds
     * @param characterId An EVE character ID
     * @param contractId ID of a contract
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdContractsContractIdBids (characterId: number, contractId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContractsContractIdBids200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contracts/{contract_id}/bids/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'contract_id' + '}', String(contractId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdContractsContractIdBids.');
        }

        // verify required parameter 'contractId' is not null or undefined
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getCharactersCharacterIdContractsContractIdBids.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContractsContractIdBids200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get contract items
     * Lists items of a particular contract  --- Alternate route: &#x60;/dev/characters/{character_id}/contracts/{contract_id}/items/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/contracts/{contract_id}/items/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/contracts/{contract_id}/items/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param contractId ID of a contract
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdContractsContractIdItems (characterId: number, contractId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContractsContractIdItems200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/contracts/{contract_id}/items/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'contract_id' + '}', String(contractId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdContractsContractIdItems.');
        }

        // verify required parameter 'contractId' is not null or undefined
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getCharactersCharacterIdContractsContractIdItems.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdContractsContractIdItems200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get coporation contracts
     * Returns contracts available to a coporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \&quot;in_progress\&quot;.  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/contracts/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/contracts/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/contracts/&#x60;  --- This route is cached for up to 300 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdContracts (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContracts200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/contracts/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContracts.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContracts200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation contract bids
     * Lists bids on a particular auction contract  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/&#x60;  --- This route is cached for up to 3600 seconds
     * @param contractId ID of a contract
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdContractsContractIdBids (contractId: number, corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContractsContractIdBids200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/contracts/{contract_id}/bids/'
            .replace('{' + 'contract_id' + '}', String(contractId))
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'contractId' is not null or undefined
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getCorporationsCorporationIdContractsContractIdBids.');
        }

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContractsContractIdBids.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContractsContractIdBids200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation contract items
     * Lists items of a particular contract  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/contracts/{contract_id}/items/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/contracts/{contract_id}/items/&#x60;  --- This route is cached for up to 3600 seconds
     * @param contractId ID of a contract
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdContractsContractIdItems (contractId: number, corporationId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContractsContractIdItems200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/contracts/{contract_id}/items/'
            .replace('{' + 'contract_id' + '}', String(contractId))
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'contractId' is not null or undefined
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getCorporationsCorporationIdContractsContractIdItems.');
        }

        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContractsContractIdItems.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContractsContractIdItems200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CorporationApiApiKeys {
}

export class CorporationApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CorporationApiApiKeys, value: string) {
        this.authentications[CorporationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get corporation information
     * Public information about a corporation  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/&#x60;  Alternate route: &#x60;/v4/corporations/{corporation_id}/&#x60;  --- This route is cached for up to 3600 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationId (corporationId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdOk;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get alliance history
     * Get a list of all the alliances a corporation has been a member of  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/alliancehistory/&#x60;  Alternate route: &#x60;/v2/corporations/{corporation_id}/alliancehistory/&#x60;  --- This route is cached for up to 3600 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdAlliancehistory (corporationId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdAlliancehistory200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/alliancehistory/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdAlliancehistory.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdAlliancehistory200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation blueprints
     * Returns a list of blueprints the corporation owns  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/blueprints/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/blueprints/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/blueprints/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdBlueprints (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdBlueprints200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/blueprints/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdBlueprints.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdBlueprints200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all corporation ALSC logs
     * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/containers/logs/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/containers/logs/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/containers/logs/&#x60;  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdContainersLogs (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContainersLogs200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/containers/logs/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContainersLogs.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdContainersLogs200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation divisions
     * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/divisions/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/divisions/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/divisions/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdDivisions (corporationId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdDivisionsOk;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/divisions/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdDivisions.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdDivisionsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation facilities
     * Return a corporation&#39;s facilities  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/facilities/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/facilities/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/facilities/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdFacilities (corporationId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdFacilities200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/facilities/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdFacilities.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdFacilities200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation icon
     * Get the icon urls for a corporation  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/icons/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/icons/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/icons/&#x60;  --- This route is cached for up to 3600 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdIcons (corporationId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdIconsOk;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/icons/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdIcons.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdIconsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation medals
     * Returns a corporation&#39;s medals  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/medals/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/medals/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/medals/&#x60;  --- This route is cached for up to 3600 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdMedals (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMedals200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/medals/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMedals.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMedals200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation issued medals
     * Returns medals issued by a corporation  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/medals/issued/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/medals/issued/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/medals/issued/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdMedalsIssued (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMedalsIssued200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/medals/issued/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMedalsIssued.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMedalsIssued200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation members
     * Return the current member list of a corporation, the token&#39;s character need to be a member of the corporation.  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/members/&#x60;  Alternate route: &#x60;/v3/corporations/{corporation_id}/members/&#x60;  --- This route is cached for up to 3600 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdMembers (corporationId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/members/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMembers.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation member limit
     * Return a corporation&#39;s member limit, not including CEO himself  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/members/limit/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/members/limit/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/members/limit/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdMembersLimit (corporationId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/members/limit/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMembersLimit.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation&#39;s members&#39; titles
     * Returns a corporation&#39;s members&#39; titles  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/members/titles/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/members/titles/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/members/titles/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdMembersTitles (corporationId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMembersTitles200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/members/titles/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMembersTitles.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMembersTitles200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Track corporation members
     * Returns additional information about a corporation&#39;s members which helps tracking their activities  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/membertracking/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/membertracking/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/membertracking/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdMembertracking (corporationId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMembertracking200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/membertracking/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMembertracking.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdMembertracking200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation outposts
     * Get a list of corporation outpost IDs Note: This endpoint will be removed once outposts are migrated to Citadels as talked about in this blog: https://community.eveonline.com/news/dev-blogs/the-next-steps-in-structure-transition/  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/outposts/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/outposts/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/outposts/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdOutposts (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/outposts/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdOutposts.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation outpost details
     * Get details about a given outpost. Note: This endpoint will be removed once outposts are migrated to Citadels as talked about in this blog: https://community.eveonline.com/news/dev-blogs/the-next-steps-in-structure-transition/  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/outposts/{outpost_id}/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/outposts/{outpost_id}/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/outposts/{outpost_id}/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param outpostId A station (outpost) ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdOutpostsOutpostId (corporationId: number, outpostId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdOutpostsOutpostIdOk;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/outposts/{outpost_id}/'
            .replace('{' + 'corporation_id' + '}', String(corporationId))
            .replace('{' + 'outpost_id' + '}', String(outpostId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdOutpostsOutpostId.');
        }

        // verify required parameter 'outpostId' is not null or undefined
        if (outpostId === null || outpostId === undefined) {
            throw new Error('Required parameter outpostId was null or undefined when calling getCorporationsCorporationIdOutpostsOutpostId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdOutpostsOutpostIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation member roles
     * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/roles/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/roles/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/roles/&#x60;  --- This route is cached for up to 3600 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdRoles (corporationId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdRoles200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/roles/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdRoles.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdRoles200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation member roles history
     * Return how roles have changed for a coporation&#39;s members, up to a month  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/roles/history/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/roles/history/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/roles/history/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdRolesHistory (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdRolesHistory200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/roles/history/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdRolesHistory.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdRolesHistory200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation members
     * Return the current member list of a corporation, the token&#39;s character need to be a member of the corporation.  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/shareholders/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/shareholders/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/shareholders/&#x60;  --- This route is cached for up to 3600 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdShareholders (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdShareholders200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/shareholders/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdShareholders.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdShareholders200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation standings
     * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/standings/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/standings/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/standings/&#x60;  --- This route is cached for up to 3600 seconds
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdStandings (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdStandings200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/standings/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdStandings.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdStandings200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation starbases (POSes)
     * Returns list of corporation starbases (POSes)  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/starbases/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/starbases/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/starbases/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdStarbases (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdStarbases200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/starbases/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdStarbases.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdStarbases200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get starbase (POS) detail
     * Returns various settings and fuels of a starbase (POS)  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/starbases/{starbase_id}/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/starbases/{starbase_id}/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/starbases/{starbase_id}/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param starbaseId An EVE starbase (POS) ID
     * @param systemId The solar system this starbase (POS) is located in,
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdStarbasesStarbaseId (corporationId: number, starbaseId: number, systemId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdStarbasesStarbaseIdOk;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/starbases/{starbase_id}/'
            .replace('{' + 'corporation_id' + '}', String(corporationId))
            .replace('{' + 'starbase_id' + '}', String(starbaseId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdStarbasesStarbaseId.');
        }

        // verify required parameter 'starbaseId' is not null or undefined
        if (starbaseId === null || starbaseId === undefined) {
            throw new Error('Required parameter starbaseId was null or undefined when calling getCorporationsCorporationIdStarbasesStarbaseId.');
        }

        // verify required parameter 'systemId' is not null or undefined
        if (systemId === null || systemId === undefined) {
            throw new Error('Required parameter systemId was null or undefined when calling getCorporationsCorporationIdStarbasesStarbaseId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (systemId !== undefined) {
            queryParameters['system_id'] = systemId;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdStarbasesStarbaseIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation structures
     * Get a list of corporation structures  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/structures/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/structures/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/structures/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): StationManager 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdStructures (corporationId: number, datasource?: string, language?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdStructures200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/structures/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdStructures.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdStructures200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation titles
     * Returns a corporation&#39;s titles  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/titles/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/titles/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/titles/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdTitles (corporationId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdTitles200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/titles/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdTitles.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdTitles200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation names
     * Resolve a set of corporation IDs to corporation names  --- Alternate route: &#x60;/dev/corporations/names/&#x60;  Alternate route: &#x60;/v2/corporations/names/&#x60;  --- This route is cached for up to 3600 seconds
     * @param corporationIds A comma separated list of corporation IDs
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsNames (corporationIds: Array<number>, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsNames200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/names/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationIds' is not null or undefined
        if (corporationIds === null || corporationIds === undefined) {
            throw new Error('Required parameter corporationIds was null or undefined when calling getCorporationsNames.');
        }

        if (corporationIds !== undefined) {
            queryParameters['corporation_ids'] = corporationIds;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsNames200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get npc corporations
     * Get a list of npc corporations  --- Alternate route: &#x60;/dev/corporations/npccorps/&#x60;  Alternate route: &#x60;/legacy/corporations/npccorps/&#x60;  Alternate route: &#x60;/v1/corporations/npccorps/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsNpccorps (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/corporations/npccorps/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update structure vulnerability schedule
     * Update the vulnerability window schedule of a corporation structure  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/structures/{structure_id}/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/structures/{structure_id}/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/structures/{structure_id}/&#x60; 
     * @param corporationId An EVE corporation ID
     * @param newSchedule New vulnerability window schedule for the structure
     * @param structureId A structure ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public putCorporationsCorporationIdStructuresStructureId (corporationId: number, newSchedule: Array<PutCorporationsCorporationIdStructuresStructureIdNewSchedule>, structureId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/structures/{structure_id}/'
            .replace('{' + 'corporation_id' + '}', String(corporationId))
            .replace('{' + 'structure_id' + '}', String(structureId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling putCorporationsCorporationIdStructuresStructureId.');
        }

        // verify required parameter 'newSchedule' is not null or undefined
        if (newSchedule === null || newSchedule === undefined) {
            throw new Error('Required parameter newSchedule was null or undefined when calling putCorporationsCorporationIdStructuresStructureId.');
        }

        // verify required parameter 'structureId' is not null or undefined
        if (structureId === null || structureId === undefined) {
            throw new Error('Required parameter structureId was null or undefined when calling putCorporationsCorporationIdStructuresStructureId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newSchedule,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DogmaApiApiKeys {
}

export class DogmaApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DogmaApiApiKeys, value: string) {
        this.authentications[DogmaApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get attributes
     * Get a list of dogma attribute ids  --- Alternate route: &#x60;/dev/dogma/attributes/&#x60;  Alternate route: &#x60;/legacy/dogma/attributes/&#x60;  Alternate route: &#x60;/v1/dogma/attributes/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getDogmaAttributes (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/dogma/attributes/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get attribute information
     * Get information on a dogma attribute  --- Alternate route: &#x60;/dev/dogma/attributes/{attribute_id}/&#x60;  Alternate route: &#x60;/legacy/dogma/attributes/{attribute_id}/&#x60;  Alternate route: &#x60;/v1/dogma/attributes/{attribute_id}/&#x60;  --- This route expires daily at 11:05
     * @param attributeId A dogma attribute ID
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getDogmaAttributesAttributeId (attributeId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetDogmaAttributesAttributeIdOk;  }> {
        const localVarPath = this.basePath + '/dogma/attributes/{attribute_id}/'
            .replace('{' + 'attribute_id' + '}', String(attributeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'attributeId' is not null or undefined
        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling getDogmaAttributesAttributeId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetDogmaAttributesAttributeIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get effects
     * Get a list of dogma effect ids  --- Alternate route: &#x60;/dev/dogma/effects/&#x60;  Alternate route: &#x60;/legacy/dogma/effects/&#x60;  Alternate route: &#x60;/v1/dogma/effects/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getDogmaEffects (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/dogma/effects/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get effect information
     * Get information on a dogma effect  --- Alternate route: &#x60;/dev/dogma/effects/{effect_id}/&#x60;  Alternate route: &#x60;/v2/dogma/effects/{effect_id}/&#x60;  --- This route expires daily at 11:05
     * @param effectId A dogma effect ID
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getDogmaEffectsEffectId (effectId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetDogmaEffectsEffectIdOk;  }> {
        const localVarPath = this.basePath + '/dogma/effects/{effect_id}/'
            .replace('{' + 'effect_id' + '}', String(effectId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'effectId' is not null or undefined
        if (effectId === null || effectId === undefined) {
            throw new Error('Required parameter effectId was null or undefined when calling getDogmaEffectsEffectId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetDogmaEffectsEffectIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FactionWarfareApiApiKeys {
}

export class FactionWarfareApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: FactionWarfareApiApiKeys, value: string) {
        this.authentications[FactionWarfareApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Overview of a character involved in faction warfare
     * Statistical overview of a character involved in faction warfare  --- Alternate route: &#x60;/dev/characters/{character_id}/fw/stats/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/fw/stats/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/fw/stats/&#x60;  --- This route expires daily at 11:05
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdFwStats (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdFwStatsOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fw/stats/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdFwStats.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdFwStatsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Overview of a corporation involved in faction warfare
     * Statistics about a corporation involved in faction warfare  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/fw/stats/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/fw/stats/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/fw/stats/&#x60;  --- This route expires daily at 11:05
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdFwStats (corporationId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdFwStatsOk;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/fw/stats/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdFwStats.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCorporationsCorporationIdFwStatsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List of the top factions in faction warfare
     * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday.  --- Alternate route: &#x60;/dev/fw/leaderboards/&#x60;  Alternate route: &#x60;/legacy/fw/leaderboards/&#x60;  Alternate route: &#x60;/v1/fw/leaderboards/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getFwLeaderboards (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetFwLeaderboardsOk;  }> {
        const localVarPath = this.basePath + '/fw/leaderboards/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFwLeaderboardsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List of the top pilots in faction warfare
     * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday.  --- Alternate route: &#x60;/dev/fw/leaderboards/characters/&#x60;  Alternate route: &#x60;/legacy/fw/leaderboards/characters/&#x60;  Alternate route: &#x60;/v1/fw/leaderboards/characters/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getFwLeaderboardsCharacters (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetFwLeaderboardsCharactersOk;  }> {
        const localVarPath = this.basePath + '/fw/leaderboards/characters/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFwLeaderboardsCharactersOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List of the top corporations in faction warfare
     * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday.  --- Alternate route: &#x60;/dev/fw/leaderboards/corporations/&#x60;  Alternate route: &#x60;/legacy/fw/leaderboards/corporations/&#x60;  Alternate route: &#x60;/v1/fw/leaderboards/corporations/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getFwLeaderboardsCorporations (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetFwLeaderboardsCorporationsOk;  }> {
        const localVarPath = this.basePath + '/fw/leaderboards/corporations/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFwLeaderboardsCorporationsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * An overview of statistics about factions involved in faction warfare
     * Statistical overviews of factions involved in faction warfare  --- Alternate route: &#x60;/dev/fw/stats/&#x60;  Alternate route: &#x60;/legacy/fw/stats/&#x60;  Alternate route: &#x60;/v1/fw/stats/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getFwStats (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetFwStats200Ok>;  }> {
        const localVarPath = this.basePath + '/fw/stats/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetFwStats200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Ownership of faction warfare systems
     * An overview of the current ownership of faction warfare solar systems  --- Alternate route: &#x60;/dev/fw/systems/&#x60;  Alternate route: &#x60;/legacy/fw/systems/&#x60;  Alternate route: &#x60;/v1/fw/systems/&#x60;  --- This route is cached for up to 1800 seconds
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getFwSystems (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetFwSystems200Ok>;  }> {
        const localVarPath = this.basePath + '/fw/systems/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetFwSystems200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Data about which NPC factions are at war
     * Data about which NPC factions are at war  --- Alternate route: &#x60;/dev/fw/wars/&#x60;  Alternate route: &#x60;/legacy/fw/wars/&#x60;  Alternate route: &#x60;/v1/fw/wars/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getFwWars (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetFwWars200Ok>;  }> {
        const localVarPath = this.basePath + '/fw/wars/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetFwWars200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FittingsApiApiKeys {
}

export class FittingsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: FittingsApiApiKeys, value: string) {
        this.authentications[FittingsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Delete fitting
     * Delete a fitting from a character  --- Alternate route: &#x60;/dev/characters/{character_id}/fittings/{fitting_id}/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/fittings/{fitting_id}/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/fittings/{fitting_id}/&#x60; 
     * @param characterId An EVE character ID
     * @param fittingId ID for a fitting of this character
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public deleteCharactersCharacterIdFittingsFittingId (characterId: number, fittingId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fittings/{fitting_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'fitting_id' + '}', String(fittingId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdFittingsFittingId.');
        }

        // verify required parameter 'fittingId' is not null or undefined
        if (fittingId === null || fittingId === undefined) {
            throw new Error('Required parameter fittingId was null or undefined when calling deleteCharactersCharacterIdFittingsFittingId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get fittings
     * Return fittings of a character  --- Alternate route: &#x60;/dev/characters/{character_id}/fittings/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/fittings/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/fittings/&#x60;  --- This route is cached for up to 300 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdFittings (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdFittings200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fittings/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdFittings.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdFittings200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create fitting
     * Save a new fitting for a character  --- Alternate route: &#x60;/dev/characters/{character_id}/fittings/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/fittings/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/fittings/&#x60; 
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param fitting Details about the new fitting
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postCharactersCharacterIdFittings (characterId: number, datasource?: string, fitting?: PostCharactersCharacterIdFittingsFitting, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: PostCharactersCharacterIdFittingsCreated;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fittings/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdFittings.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: fitting,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostCharactersCharacterIdFittingsCreated;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FleetsApiApiKeys {
}

export class FleetsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: FleetsApiApiKeys, value: string) {
        this.authentications[FleetsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Kick fleet member
     * Kick a fleet member  --- Alternate route: &#x60;/dev/fleets/{fleet_id}/members/{member_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/members/{member_id}/&#x60;  Alternate route: &#x60;/v1/fleets/{fleet_id}/members/{member_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param memberId The character ID of a member in this fleet
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public deleteFleetsFleetIdMembersMemberId (fleetId: number, memberId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/members/{member_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'member_id' + '}', String(memberId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling deleteFleetsFleetIdMembersMemberId.');
        }

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling deleteFleetsFleetIdMembersMemberId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete fleet squad
     * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: &#x60;/dev/fleets/{fleet_id}/squads/{squad_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/squads/{squad_id}/&#x60;  Alternate route: &#x60;/v1/fleets/{fleet_id}/squads/{squad_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param squadId The squad to delete
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public deleteFleetsFleetIdSquadsSquadId (fleetId: number, squadId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/squads/{squad_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'squad_id' + '}', String(squadId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling deleteFleetsFleetIdSquadsSquadId.');
        }

        // verify required parameter 'squadId' is not null or undefined
        if (squadId === null || squadId === undefined) {
            throw new Error('Required parameter squadId was null or undefined when calling deleteFleetsFleetIdSquadsSquadId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete fleet wing
     * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: &#x60;/dev/fleets/{fleet_id}/wings/{wing_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/wings/{wing_id}/&#x60;  Alternate route: &#x60;/v1/fleets/{fleet_id}/wings/{wing_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param wingId The wing to delete
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public deleteFleetsFleetIdWingsWingId (fleetId: number, wingId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/{wing_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'wing_id' + '}', String(wingId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling deleteFleetsFleetIdWingsWingId.');
        }

        // verify required parameter 'wingId' is not null or undefined
        if (wingId === null || wingId === undefined) {
            throw new Error('Required parameter wingId was null or undefined when calling deleteFleetsFleetIdWingsWingId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character fleet info
     * Return the fleet ID the character is in, if any.  --- Alternate route: &#x60;/dev/characters/{character_id}/fleet/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/fleet/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/fleet/&#x60;  --- This route is cached for up to 60 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdFleet (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdFleetOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/fleet/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdFleet.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdFleetOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get fleet information
     * Return details about a fleet  --- Alternate route: &#x60;/dev/fleets/{fleet_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/&#x60;  Alternate route: &#x60;/v1/fleets/{fleet_id}/&#x60;  --- This route is cached for up to 5 seconds
     * @param fleetId ID for a fleet
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getFleetsFleetId (fleetId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetFleetsFleetIdOk;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling getFleetsFleetId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetFleetsFleetIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get fleet members
     * Return information about fleet members  --- Alternate route: &#x60;/dev/fleets/{fleet_id}/members/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/members/&#x60;  Alternate route: &#x60;/v1/fleets/{fleet_id}/members/&#x60;  --- This route is cached for up to 5 seconds
     * @param fleetId ID for a fleet
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getFleetsFleetIdMembers (fleetId: number, datasource?: string, language?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetFleetsFleetIdMembers200Ok>;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/members/'
            .replace('{' + 'fleet_id' + '}', String(fleetId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling getFleetsFleetIdMembers.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetFleetsFleetIdMembers200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get fleet wings
     * Return information about wings in a fleet  --- Alternate route: &#x60;/dev/fleets/{fleet_id}/wings/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/wings/&#x60;  Alternate route: &#x60;/v1/fleets/{fleet_id}/wings/&#x60;  --- This route is cached for up to 5 seconds
     * @param fleetId ID for a fleet
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getFleetsFleetIdWings (fleetId: number, datasource?: string, language?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetFleetsFleetIdWings200Ok>;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/'
            .replace('{' + 'fleet_id' + '}', String(fleetId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling getFleetsFleetIdWings.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetFleetsFleetIdWings200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create fleet invitation
     * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: &#x60;/dev/fleets/{fleet_id}/members/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/members/&#x60;  Alternate route: &#x60;/v1/fleets/{fleet_id}/members/&#x60; 
     * @param fleetId ID for a fleet
     * @param invitation Details of the invitation
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postFleetsFleetIdMembers (fleetId: number, invitation: PostFleetsFleetIdMembersInvitation, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/members/'
            .replace('{' + 'fleet_id' + '}', String(fleetId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling postFleetsFleetIdMembers.');
        }

        // verify required parameter 'invitation' is not null or undefined
        if (invitation === null || invitation === undefined) {
            throw new Error('Required parameter invitation was null or undefined when calling postFleetsFleetIdMembers.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: invitation,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create fleet wing
     * Create a new wing in a fleet  --- Alternate route: &#x60;/dev/fleets/{fleet_id}/wings/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/wings/&#x60;  Alternate route: &#x60;/v1/fleets/{fleet_id}/wings/&#x60; 
     * @param fleetId ID for a fleet
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postFleetsFleetIdWings (fleetId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: PostFleetsFleetIdWingsCreated;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/'
            .replace('{' + 'fleet_id' + '}', String(fleetId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling postFleetsFleetIdWings.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostFleetsFleetIdWingsCreated;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create fleet squad
     * Create a new squad in a fleet  --- Alternate route: &#x60;/dev/fleets/{fleet_id}/wings/{wing_id}/squads/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/&#x60;  Alternate route: &#x60;/v1/fleets/{fleet_id}/wings/{wing_id}/squads/&#x60; 
     * @param fleetId ID for a fleet
     * @param wingId The wing_id to create squad in
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postFleetsFleetIdWingsWingIdSquads (fleetId: number, wingId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: PostFleetsFleetIdWingsWingIdSquadsCreated;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/{wing_id}/squads/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'wing_id' + '}', String(wingId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling postFleetsFleetIdWingsWingIdSquads.');
        }

        // verify required parameter 'wingId' is not null or undefined
        if (wingId === null || wingId === undefined) {
            throw new Error('Required parameter wingId was null or undefined when calling postFleetsFleetIdWingsWingIdSquads.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostFleetsFleetIdWingsWingIdSquadsCreated;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update fleet
     * Update settings about a fleet  --- Alternate route: &#x60;/dev/fleets/{fleet_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/&#x60;  Alternate route: &#x60;/v1/fleets/{fleet_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param newSettings What to update for this fleet
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public putFleetsFleetId (fleetId: number, newSettings: PutFleetsFleetIdNewSettings, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling putFleetsFleetId.');
        }

        // verify required parameter 'newSettings' is not null or undefined
        if (newSettings === null || newSettings === undefined) {
            throw new Error('Required parameter newSettings was null or undefined when calling putFleetsFleetId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newSettings,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Move fleet member
     * Move a fleet member around  --- Alternate route: &#x60;/dev/fleets/{fleet_id}/members/{member_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/members/{member_id}/&#x60;  Alternate route: &#x60;/v1/fleets/{fleet_id}/members/{member_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param memberId The character ID of a member in this fleet
     * @param movement Details of the invitation
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public putFleetsFleetIdMembersMemberId (fleetId: number, memberId: number, movement: PutFleetsFleetIdMembersMemberIdMovement, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/members/{member_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'member_id' + '}', String(memberId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling putFleetsFleetIdMembersMemberId.');
        }

        // verify required parameter 'memberId' is not null or undefined
        if (memberId === null || memberId === undefined) {
            throw new Error('Required parameter memberId was null or undefined when calling putFleetsFleetIdMembersMemberId.');
        }

        // verify required parameter 'movement' is not null or undefined
        if (movement === null || movement === undefined) {
            throw new Error('Required parameter movement was null or undefined when calling putFleetsFleetIdMembersMemberId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: movement,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Rename fleet squad
     * Rename a fleet squad  --- Alternate route: &#x60;/dev/fleets/{fleet_id}/squads/{squad_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/squads/{squad_id}/&#x60;  Alternate route: &#x60;/v1/fleets/{fleet_id}/squads/{squad_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param naming New name of the squad
     * @param squadId The squad to rename
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public putFleetsFleetIdSquadsSquadId (fleetId: number, naming: PutFleetsFleetIdSquadsSquadIdNaming, squadId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/squads/{squad_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'squad_id' + '}', String(squadId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling putFleetsFleetIdSquadsSquadId.');
        }

        // verify required parameter 'naming' is not null or undefined
        if (naming === null || naming === undefined) {
            throw new Error('Required parameter naming was null or undefined when calling putFleetsFleetIdSquadsSquadId.');
        }

        // verify required parameter 'squadId' is not null or undefined
        if (squadId === null || squadId === undefined) {
            throw new Error('Required parameter squadId was null or undefined when calling putFleetsFleetIdSquadsSquadId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: naming,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Rename fleet wing
     * Rename a fleet wing  --- Alternate route: &#x60;/dev/fleets/{fleet_id}/wings/{wing_id}/&#x60;  Alternate route: &#x60;/legacy/fleets/{fleet_id}/wings/{wing_id}/&#x60;  Alternate route: &#x60;/v1/fleets/{fleet_id}/wings/{wing_id}/&#x60; 
     * @param fleetId ID for a fleet
     * @param naming New name of the wing
     * @param wingId The wing to rename
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public putFleetsFleetIdWingsWingId (fleetId: number, naming: PutFleetsFleetIdWingsWingIdNaming, wingId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fleets/{fleet_id}/wings/{wing_id}/'
            .replace('{' + 'fleet_id' + '}', String(fleetId))
            .replace('{' + 'wing_id' + '}', String(wingId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fleetId' is not null or undefined
        if (fleetId === null || fleetId === undefined) {
            throw new Error('Required parameter fleetId was null or undefined when calling putFleetsFleetIdWingsWingId.');
        }

        // verify required parameter 'naming' is not null or undefined
        if (naming === null || naming === undefined) {
            throw new Error('Required parameter naming was null or undefined when calling putFleetsFleetIdWingsWingId.');
        }

        // verify required parameter 'wingId' is not null or undefined
        if (wingId === null || wingId === undefined) {
            throw new Error('Required parameter wingId was null or undefined when calling putFleetsFleetIdWingsWingId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: naming,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IncursionsApiApiKeys {
}

export class IncursionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: IncursionsApiApiKeys, value: string) {
        this.authentications[IncursionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * List incursions
     * Return a list of current incursions  --- Alternate route: &#x60;/dev/incursions/&#x60;  Alternate route: &#x60;/legacy/incursions/&#x60;  Alternate route: &#x60;/v1/incursions/&#x60;  --- This route is cached for up to 300 seconds
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getIncursions (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetIncursions200Ok>;  }> {
        const localVarPath = this.basePath + '/incursions/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetIncursions200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IndustryApiApiKeys {
}

export class IndustryApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: IndustryApiApiKeys, value: string) {
        this.authentications[IndustryApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * List character industry jobs
     * List industry jobs placed by a character  --- Alternate route: &#x60;/dev/characters/{character_id}/industry/jobs/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/industry/jobs/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/industry/jobs/&#x60;  --- This route is cached for up to 300 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param includeCompleted Whether retrieve completed character industry jobs as well
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdIndustryJobs (characterId: number, datasource?: string, includeCompleted?: boolean, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdIndustryJobs200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/industry/jobs/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdIndustryJobs.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (includeCompleted !== undefined) {
            queryParameters['include_completed'] = includeCompleted;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdIndustryJobs200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Character mining ledger
     * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: &#x60;/dev/characters/{character_id}/mining/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mining/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/mining/&#x60;  --- This route is cached for up to 600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdMining (characterId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMining200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mining/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMining.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMining200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Moon extraction timers
     * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: &#x60;/dev/corporation/{corporation_id}/mining/extractions/&#x60;  Alternate route: &#x60;/legacy/corporation/{corporation_id}/mining/extractions/&#x60;  Alternate route: &#x60;/v1/corporation/{corporation_id}/mining/extractions/&#x60;  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Structure_manager 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationCorporationIdMiningExtractions (corporationId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationCorporationIdMiningExtractions200Ok>;  }> {
        const localVarPath = this.basePath + '/corporation/{corporation_id}/mining/extractions/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationCorporationIdMiningExtractions.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationCorporationIdMiningExtractions200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Corporation mining observers
     * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: &#x60;/dev/corporation/{corporation_id}/mining/observers/&#x60;  Alternate route: &#x60;/legacy/corporation/{corporation_id}/mining/observers/&#x60;  Alternate route: &#x60;/v1/corporation/{corporation_id}/mining/observers/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationCorporationIdMiningObservers (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationCorporationIdMiningObservers200Ok>;  }> {
        const localVarPath = this.basePath + '/corporation/{corporation_id}/mining/observers/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationCorporationIdMiningObservers.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationCorporationIdMiningObservers200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Observed corporation mining
     * Paginated record of all mining seen by an observer   --- Alternate route: &#x60;/dev/corporation/{corporation_id}/mining/observers/{observer_id}/&#x60;  Alternate route: &#x60;/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/&#x60;  Alternate route: &#x60;/v1/corporation/{corporation_id}/mining/observers/{observer_id}/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
     * @param corporationId An EVE corporation ID
     * @param observerId A mining observer id
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationCorporationIdMiningObserversObserverId (corporationId: number, observerId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationCorporationIdMiningObserversObserverId200Ok>;  }> {
        const localVarPath = this.basePath + '/corporation/{corporation_id}/mining/observers/{observer_id}/'
            .replace('{' + 'corporation_id' + '}', String(corporationId))
            .replace('{' + 'observer_id' + '}', String(observerId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationCorporationIdMiningObserversObserverId.');
        }

        // verify required parameter 'observerId' is not null or undefined
        if (observerId === null || observerId === undefined) {
            throw new Error('Required parameter observerId was null or undefined when calling getCorporationCorporationIdMiningObserversObserverId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationCorporationIdMiningObserversObserverId200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List corporation industry jobs
     * List industry jobs run by a corporation  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/industry/jobs/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/industry/jobs/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/industry/jobs/&#x60;  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): FactoryManager 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param includeCompleted Whether retrieve completed industry jobs as well
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdIndustryJobs (corporationId: number, datasource?: string, includeCompleted?: boolean, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdIndustryJobs200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/industry/jobs/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdIndustryJobs.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (includeCompleted !== undefined) {
            queryParameters['include_completed'] = includeCompleted;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdIndustryJobs200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List industry facilities
     * Return a list of industry facilities  --- Alternate route: &#x60;/dev/industry/facilities/&#x60;  Alternate route: &#x60;/legacy/industry/facilities/&#x60;  Alternate route: &#x60;/v1/industry/facilities/&#x60;  --- This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getIndustryFacilities (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetIndustryFacilities200Ok>;  }> {
        const localVarPath = this.basePath + '/industry/facilities/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetIndustryFacilities200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List solar system cost indices
     * Return cost indices for solar systems  --- Alternate route: &#x60;/dev/industry/systems/&#x60;  Alternate route: &#x60;/legacy/industry/systems/&#x60;  Alternate route: &#x60;/v1/industry/systems/&#x60;  --- This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getIndustrySystems (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetIndustrySystems200Ok>;  }> {
        const localVarPath = this.basePath + '/industry/systems/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetIndustrySystems200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InsuranceApiApiKeys {
}

export class InsuranceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InsuranceApiApiKeys, value: string) {
        this.authentications[InsuranceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * List insurance levels
     * Return available insurance levels for all ship types  --- Alternate route: &#x60;/dev/insurance/prices/&#x60;  Alternate route: &#x60;/legacy/insurance/prices/&#x60;  Alternate route: &#x60;/v1/insurance/prices/&#x60;  --- This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getInsurancePrices (datasource?: string, language?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetInsurancePrices200Ok>;  }> {
        const localVarPath = this.basePath + '/insurance/prices/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetInsurancePrices200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum KillmailsApiApiKeys {
}

export class KillmailsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: KillmailsApiApiKeys, value: string) {
        this.authentications[KillmailsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get character kills and losses
     * Return a list of character&#39;s recent kills and losses  --- Alternate route: &#x60;/dev/characters/{character_id}/killmails/recent/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/killmails/recent/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/killmails/recent/&#x60;  --- This route is cached for up to 120 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param maxCount How many killmails to return at maximum
     * @param maxKillId Only return killmails with ID smaller than this. 
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdKillmailsRecent (characterId: number, datasource?: string, maxCount?: number, maxKillId?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdKillmailsRecent200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/killmails/recent/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdKillmailsRecent.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (maxCount !== undefined) {
            queryParameters['max_count'] = maxCount;
        }

        if (maxKillId !== undefined) {
            queryParameters['max_kill_id'] = maxKillId;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdKillmailsRecent200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation kills and losses
     * Get a list of corporation&#39;s recent kills and losses  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/killmails/recent/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/killmails/recent/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/killmails/recent/&#x60;  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param maxKillId Only return killmails with ID smaller than this
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdKillmailsRecent (corporationId: number, datasource?: string, maxKillId?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdKillmailsRecent200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/killmails/recent/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdKillmailsRecent.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (maxKillId !== undefined) {
            queryParameters['max_kill_id'] = maxKillId;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdKillmailsRecent200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single killmail
     * Return a single killmail from its ID and hash  --- Alternate route: &#x60;/dev/killmails/{killmail_id}/{killmail_hash}/&#x60;  Alternate route: &#x60;/legacy/killmails/{killmail_id}/{killmail_hash}/&#x60;  Alternate route: &#x60;/v1/killmails/{killmail_id}/{killmail_hash}/&#x60;  --- This route is cached for up to 3600 seconds
     * @param killmailHash The killmail hash for verification
     * @param killmailId The killmail ID to be queried
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getKillmailsKillmailIdKillmailHash (killmailHash: string, killmailId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetKillmailsKillmailIdKillmailHashOk;  }> {
        const localVarPath = this.basePath + '/killmails/{killmail_id}/{killmail_hash}/'
            .replace('{' + 'killmail_hash' + '}', String(killmailHash))
            .replace('{' + 'killmail_id' + '}', String(killmailId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'killmailHash' is not null or undefined
        if (killmailHash === null || killmailHash === undefined) {
            throw new Error('Required parameter killmailHash was null or undefined when calling getKillmailsKillmailIdKillmailHash.');
        }

        // verify required parameter 'killmailId' is not null or undefined
        if (killmailId === null || killmailId === undefined) {
            throw new Error('Required parameter killmailId was null or undefined when calling getKillmailsKillmailIdKillmailHash.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetKillmailsKillmailIdKillmailHashOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LocationApiApiKeys {
}

export class LocationApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LocationApiApiKeys, value: string) {
        this.authentications[LocationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get character location
     * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable.  --- Alternate route: &#x60;/dev/characters/{character_id}/location/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/location/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/location/&#x60;  --- This route is cached for up to 5 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdLocation (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdLocationOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/location/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdLocation.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdLocationOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character online
     * Checks if the character is currently online  --- Alternate route: &#x60;/dev/characters/{character_id}/online/&#x60;  Alternate route: &#x60;/v2/characters/{character_id}/online/&#x60;  --- This route is cached for up to 60 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdOnline (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdOnlineOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/online/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdOnline.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdOnlineOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get current ship
     * Get the current ship type, name and id  --- Alternate route: &#x60;/dev/characters/{character_id}/ship/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/ship/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/ship/&#x60;  --- This route is cached for up to 5 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdShip (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdShipOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/ship/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdShip.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdShipOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LoyaltyApiApiKeys {
}

export class LoyaltyApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LoyaltyApiApiKeys, value: string) {
        this.authentications[LoyaltyApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get loyalty points
     * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: &#x60;/dev/characters/{character_id}/loyalty/points/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/loyalty/points/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/loyalty/points/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdLoyaltyPoints (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdLoyaltyPoints200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/loyalty/points/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdLoyaltyPoints.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdLoyaltyPoints200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List loyalty store offers
     * Return a list of offers from a specific corporation&#39;s loyalty store  --- Alternate route: &#x60;/dev/loyalty/stores/{corporation_id}/offers/&#x60;  Alternate route: &#x60;/legacy/loyalty/stores/{corporation_id}/offers/&#x60;  Alternate route: &#x60;/v1/loyalty/stores/{corporation_id}/offers/&#x60;  --- This route expires daily at 11:05
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getLoyaltyStoresCorporationIdOffers (corporationId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetLoyaltyStoresCorporationIdOffers200Ok>;  }> {
        const localVarPath = this.basePath + '/loyalty/stores/{corporation_id}/offers/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getLoyaltyStoresCorporationIdOffers.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetLoyaltyStoresCorporationIdOffers200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MailApiApiKeys {
}

export class MailApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MailApiApiKeys, value: string) {
        this.authentications[MailApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Delete a mail label
     * Delete a mail label  --- Alternate route: &#x60;/dev/characters/{character_id}/mail/labels/{label_id}/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/labels/{label_id}/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/mail/labels/{label_id}/&#x60; 
     * @param characterId An EVE character ID
     * @param labelId An EVE label id
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public deleteCharactersCharacterIdMailLabelsLabelId (characterId: number, labelId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/labels/{label_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'label_id' + '}', String(labelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdMailLabelsLabelId.');
        }

        // verify required parameter 'labelId' is not null or undefined
        if (labelId === null || labelId === undefined) {
            throw new Error('Required parameter labelId was null or undefined when calling deleteCharactersCharacterIdMailLabelsLabelId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a mail
     * Delete a mail  --- Alternate route: &#x60;/dev/characters/{character_id}/mail/{mail_id}/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/{mail_id}/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/mail/{mail_id}/&#x60; 
     * @param characterId An EVE character ID
     * @param mailId An EVE mail ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public deleteCharactersCharacterIdMailMailId (characterId: number, mailId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/{mail_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'mail_id' + '}', String(mailId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdMailMailId.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling deleteCharactersCharacterIdMailMailId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return mail headers
     * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards.  --- Alternate route: &#x60;/dev/characters/{character_id}/mail/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/mail/&#x60;  --- This route is cached for up to 30 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param labels Fetch only mails that match one or more of the given labels
     * @param lastMailId List only mail with an ID lower than the given ID, if present
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdMail (characterId: number, datasource?: string, labels?: Array<number>, lastMailId?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMail200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMail.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (labels !== undefined) {
            queryParameters['labels'] = labels;
        }

        if (lastMailId !== undefined) {
            queryParameters['last_mail_id'] = lastMailId;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMail200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get mail labels and unread counts
     * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: &#x60;/dev/characters/{character_id}/mail/labels/&#x60;  Alternate route: &#x60;/v3/characters/{character_id}/mail/labels/&#x60;  --- This route is cached for up to 30 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdMailLabels (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdMailLabelsOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/labels/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMailLabels.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdMailLabelsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return mailing list subscriptions
     * Return all mailing lists that the character is subscribed to  --- Alternate route: &#x60;/dev/characters/{character_id}/mail/lists/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/lists/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/mail/lists/&#x60;  --- This route is cached for up to 120 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdMailLists (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMailLists200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/lists/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMailLists.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdMailLists200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a mail
     * Return the contents of an EVE mail  --- Alternate route: &#x60;/dev/characters/{character_id}/mail/{mail_id}/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/{mail_id}/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/mail/{mail_id}/&#x60;  --- This route is cached for up to 30 seconds
     * @param characterId An EVE character ID
     * @param mailId An EVE mail ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdMailMailId (characterId: number, mailId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdMailMailIdOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/{mail_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'mail_id' + '}', String(mailId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdMailMailId.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling getCharactersCharacterIdMailMailId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdMailMailIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send a new mail
     * Create and send a new mail  --- Alternate route: &#x60;/dev/characters/{character_id}/mail/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/mail/&#x60; 
     * @param characterId An EVE character ID
     * @param mail The mail to send
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postCharactersCharacterIdMail (characterId: number, mail: PostCharactersCharacterIdMailMail, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdMail.');
        }

        // verify required parameter 'mail' is not null or undefined
        if (mail === null || mail === undefined) {
            throw new Error('Required parameter mail was null or undefined when calling postCharactersCharacterIdMail.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: mail,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a mail label
     * Create a mail label  --- Alternate route: &#x60;/dev/characters/{character_id}/mail/labels/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/labels/&#x60;  Alternate route: &#x60;/v2/characters/{character_id}/mail/labels/&#x60; 
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param label Label to create
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postCharactersCharacterIdMailLabels (characterId: number, datasource?: string, label?: PostCharactersCharacterIdMailLabelsLabel, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/labels/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling postCharactersCharacterIdMailLabels.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: label,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update metadata about a mail
     * Update metadata about a mail  --- Alternate route: &#x60;/dev/characters/{character_id}/mail/{mail_id}/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/mail/{mail_id}/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/mail/{mail_id}/&#x60; 
     * @param characterId An EVE character ID
     * @param contents Data used to update the mail
     * @param mailId An EVE mail ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public putCharactersCharacterIdMailMailId (characterId: number, contents: PutCharactersCharacterIdMailMailIdContents, mailId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/mail/{mail_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'mail_id' + '}', String(mailId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling putCharactersCharacterIdMailMailId.');
        }

        // verify required parameter 'contents' is not null or undefined
        if (contents === null || contents === undefined) {
            throw new Error('Required parameter contents was null or undefined when calling putCharactersCharacterIdMailMailId.');
        }

        // verify required parameter 'mailId' is not null or undefined
        if (mailId === null || mailId === undefined) {
            throw new Error('Required parameter mailId was null or undefined when calling putCharactersCharacterIdMailMailId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: contents,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MarketApiApiKeys {
}

export class MarketApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MarketApiApiKeys, value: string) {
        this.authentications[MarketApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * List orders from a character
     * List market orders placed by a character  --- Alternate route: &#x60;/dev/characters/{character_id}/orders/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/orders/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/orders/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdOrders (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdOrders200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/orders/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdOrders.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdOrders200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List orders from a corporation
     * List market orders placed on behalf of a corporation  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/orders/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/orders/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/orders/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdOrders (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdOrders200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/orders/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdOrders.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdOrders200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get item groups
     * Get a list of item groups  --- Alternate route: &#x60;/dev/markets/groups/&#x60;  Alternate route: &#x60;/legacy/markets/groups/&#x60;  Alternate route: &#x60;/v1/markets/groups/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getMarketsGroups (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/markets/groups/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get item group information
     * Get information on an item group  --- Alternate route: &#x60;/dev/markets/groups/{market_group_id}/&#x60;  Alternate route: &#x60;/legacy/markets/groups/{market_group_id}/&#x60;  Alternate route: &#x60;/v1/markets/groups/{market_group_id}/&#x60;  --- This route expires daily at 11:05
     * @param marketGroupId An Eve item group ID
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getMarketsGroupsMarketGroupId (marketGroupId: number, datasource?: string, language?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetMarketsGroupsMarketGroupIdOk;  }> {
        const localVarPath = this.basePath + '/markets/groups/{market_group_id}/'
            .replace('{' + 'market_group_id' + '}', String(marketGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'marketGroupId' is not null or undefined
        if (marketGroupId === null || marketGroupId === undefined) {
            throw new Error('Required parameter marketGroupId was null or undefined when calling getMarketsGroupsMarketGroupId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetMarketsGroupsMarketGroupIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List market prices
     * Return a list of prices  --- Alternate route: &#x60;/dev/markets/prices/&#x60;  Alternate route: &#x60;/legacy/markets/prices/&#x60;  Alternate route: &#x60;/v1/markets/prices/&#x60;  --- This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getMarketsPrices (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetMarketsPrices200Ok>;  }> {
        const localVarPath = this.basePath + '/markets/prices/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetMarketsPrices200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List historical market statistics in a region
     * Return a list of historical market statistics for the specified type in a region  --- Alternate route: &#x60;/dev/markets/{region_id}/history/&#x60;  Alternate route: &#x60;/legacy/markets/{region_id}/history/&#x60;  Alternate route: &#x60;/v1/markets/{region_id}/history/&#x60;  --- This route is cached for up to 3600 seconds
     * @param regionId Return statistics in this region
     * @param typeId Return statistics for this type
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getMarketsRegionIdHistory (regionId: number, typeId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetMarketsRegionIdHistory200Ok>;  }> {
        const localVarPath = this.basePath + '/markets/{region_id}/history/'
            .replace('{' + 'region_id' + '}', String(regionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling getMarketsRegionIdHistory.');
        }

        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling getMarketsRegionIdHistory.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (typeId !== undefined) {
            queryParameters['type_id'] = typeId;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetMarketsRegionIdHistory200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List orders in a region
     * Return a list of orders in a region  --- Alternate route: &#x60;/dev/markets/{region_id}/orders/&#x60;  Alternate route: &#x60;/legacy/markets/{region_id}/orders/&#x60;  Alternate route: &#x60;/v1/markets/{region_id}/orders/&#x60;  --- This route is cached for up to 300 seconds
     * @param orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders.
     * @param regionId Return orders in this region
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param typeId Return orders only for this type
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getMarketsRegionIdOrders (orderType: string, regionId: number, datasource?: string, page?: number, typeId?: number, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetMarketsRegionIdOrders200Ok>;  }> {
        const localVarPath = this.basePath + '/markets/{region_id}/orders/'
            .replace('{' + 'region_id' + '}', String(regionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderType' is not null or undefined
        if (orderType === null || orderType === undefined) {
            throw new Error('Required parameter orderType was null or undefined when calling getMarketsRegionIdOrders.');
        }

        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling getMarketsRegionIdOrders.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (orderType !== undefined) {
            queryParameters['order_type'] = orderType;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (typeId !== undefined) {
            queryParameters['type_id'] = typeId;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetMarketsRegionIdOrders200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List type IDs relevant to a market
     * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: &#x60;/dev/markets/{region_id}/types/&#x60;  Alternate route: &#x60;/legacy/markets/{region_id}/types/&#x60;  Alternate route: &#x60;/v1/markets/{region_id}/types/&#x60;  --- This route is cached for up to 600 seconds
     * @param regionId Return statistics in this region
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getMarketsRegionIdTypes (regionId: number, datasource?: string, page?: number, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/markets/{region_id}/types/'
            .replace('{' + 'region_id' + '}', String(regionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling getMarketsRegionIdTypes.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List orders in a structure
     * Return all orders in a structure  --- Alternate route: &#x60;/dev/markets/structures/{structure_id}/&#x60;  Alternate route: &#x60;/legacy/markets/structures/{structure_id}/&#x60;  Alternate route: &#x60;/v1/markets/structures/{structure_id}/&#x60;  --- This route is cached for up to 300 seconds
     * @param structureId Return orders in this structure
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getMarketsStructuresStructureId (structureId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetMarketsStructuresStructureId200Ok>;  }> {
        const localVarPath = this.basePath + '/markets/structures/{structure_id}/'
            .replace('{' + 'structure_id' + '}', String(structureId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'structureId' is not null or undefined
        if (structureId === null || structureId === undefined) {
            throw new Error('Required parameter structureId was null or undefined when calling getMarketsStructuresStructureId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetMarketsStructuresStructureId200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OpportunitiesApiApiKeys {
}

export class OpportunitiesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: OpportunitiesApiApiKeys, value: string) {
        this.authentications[OpportunitiesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get a character&#39;s completed tasks
     * Return a list of tasks finished by a character  --- Alternate route: &#x60;/dev/characters/{character_id}/opportunities/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/opportunities/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/opportunities/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdOpportunities (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdOpportunities200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/opportunities/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdOpportunities.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdOpportunities200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get opportunities groups
     * Return a list of opportunities groups  --- Alternate route: &#x60;/dev/opportunities/groups/&#x60;  Alternate route: &#x60;/legacy/opportunities/groups/&#x60;  Alternate route: &#x60;/v1/opportunities/groups/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getOpportunitiesGroups (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/opportunities/groups/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get opportunities group
     * Return information of an opportunities group  --- Alternate route: &#x60;/dev/opportunities/groups/{group_id}/&#x60;  Alternate route: &#x60;/legacy/opportunities/groups/{group_id}/&#x60;  Alternate route: &#x60;/v1/opportunities/groups/{group_id}/&#x60;  --- This route expires daily at 11:05
     * @param groupId ID of an opportunities group
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getOpportunitiesGroupsGroupId (groupId: number, datasource?: string, language?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetOpportunitiesGroupsGroupIdOk;  }> {
        const localVarPath = this.basePath + '/opportunities/groups/{group_id}/'
            .replace('{' + 'group_id' + '}', String(groupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getOpportunitiesGroupsGroupId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetOpportunitiesGroupsGroupIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get opportunities tasks
     * Return a list of opportunities tasks  --- Alternate route: &#x60;/dev/opportunities/tasks/&#x60;  Alternate route: &#x60;/legacy/opportunities/tasks/&#x60;  Alternate route: &#x60;/v1/opportunities/tasks/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getOpportunitiesTasks (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/opportunities/tasks/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get opportunities task
     * Return information of an opportunities task  --- Alternate route: &#x60;/dev/opportunities/tasks/{task_id}/&#x60;  Alternate route: &#x60;/legacy/opportunities/tasks/{task_id}/&#x60;  Alternate route: &#x60;/v1/opportunities/tasks/{task_id}/&#x60;  --- This route expires daily at 11:05
     * @param taskId ID of an opportunities task
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getOpportunitiesTasksTaskId (taskId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetOpportunitiesTasksTaskIdOk;  }> {
        const localVarPath = this.basePath + '/opportunities/tasks/{task_id}/'
            .replace('{' + 'task_id' + '}', String(taskId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'taskId' is not null or undefined
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling getOpportunitiesTasksTaskId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetOpportunitiesTasksTaskIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PlanetaryInteractionApiApiKeys {
}

export class PlanetaryInteractionApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PlanetaryInteractionApiApiKeys, value: string) {
        this.authentications[PlanetaryInteractionApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get colonies
     * Returns a list of all planetary colonies owned by a character.  --- Alternate route: &#x60;/dev/characters/{character_id}/planets/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/planets/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/planets/&#x60;  --- This route is cached for up to 600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdPlanets (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdPlanets200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/planets/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdPlanets.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdPlanets200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get colony layout
     * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: &#x60;/dev/characters/{character_id}/planets/{planet_id}/&#x60;  Alternate route: &#x60;/v3/characters/{character_id}/planets/{planet_id}/&#x60;  --- This route is cached for up to 600 seconds
     * @param characterId An EVE character ID
     * @param planetId Planet id of the target planet
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdPlanetsPlanetId (characterId: number, planetId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdPlanetsPlanetIdOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/planets/{planet_id}/'
            .replace('{' + 'character_id' + '}', String(characterId))
            .replace('{' + 'planet_id' + '}', String(planetId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdPlanetsPlanetId.');
        }

        // verify required parameter 'planetId' is not null or undefined
        if (planetId === null || planetId === undefined) {
            throw new Error('Required parameter planetId was null or undefined when calling getCharactersCharacterIdPlanetsPlanetId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdPlanetsPlanetIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List corporation customs offices
     * List customs offices owned by a corporation  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/customs_offices/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/customs_offices/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/customs_offices/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdCustomsOffices (corporationId: number, datasource?: string, page?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdCustomsOffices200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/customs_offices/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdCustomsOffices.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdCustomsOffices200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get schematic information
     * Get information on a planetary factory schematic  --- Alternate route: &#x60;/dev/universe/schematics/{schematic_id}/&#x60;  Alternate route: &#x60;/legacy/universe/schematics/{schematic_id}/&#x60;  Alternate route: &#x60;/v1/universe/schematics/{schematic_id}/&#x60;  --- This route is cached for up to 3600 seconds
     * @param schematicId A PI schematic ID
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseSchematicsSchematicId (schematicId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseSchematicsSchematicIdOk;  }> {
        const localVarPath = this.basePath + '/universe/schematics/{schematic_id}/'
            .replace('{' + 'schematic_id' + '}', String(schematicId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'schematicId' is not null or undefined
        if (schematicId === null || schematicId === undefined) {
            throw new Error('Required parameter schematicId was null or undefined when calling getUniverseSchematicsSchematicId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseSchematicsSchematicIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RoutesApiApiKeys {
}

export class RoutesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: RoutesApiApiKeys, value: string) {
        this.authentications[RoutesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get route
     * Get the systems between origin and destination  --- Alternate route: &#x60;/dev/route/{origin}/{destination}/&#x60;  Alternate route: &#x60;/legacy/route/{origin}/{destination}/&#x60;  Alternate route: &#x60;/v1/route/{origin}/{destination}/&#x60;  --- This route is cached for up to 86400 seconds
     * @param destination destination solar system ID
     * @param origin origin solar system ID
     * @param avoid avoid solar system ID(s)
     * @param connections connected solar system pairs
     * @param datasource The server name you would like data from
     * @param flag route security preference
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getRouteOriginDestination (destination: number, origin: number, avoid?: Array<number>, connections?: Array<Array<number>>, datasource?: string, flag?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/route/{origin}/{destination}/'
            .replace('{' + 'destination' + '}', String(destination))
            .replace('{' + 'origin' + '}', String(origin));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'destination' is not null or undefined
        if (destination === null || destination === undefined) {
            throw new Error('Required parameter destination was null or undefined when calling getRouteOriginDestination.');
        }

        // verify required parameter 'origin' is not null or undefined
        if (origin === null || origin === undefined) {
            throw new Error('Required parameter origin was null or undefined when calling getRouteOriginDestination.');
        }

        if (avoid !== undefined) {
            queryParameters['avoid'] = avoid;
        }

        if (connections !== undefined) {
            queryParameters['connections'] = connections;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (flag !== undefined) {
            queryParameters['flag'] = flag;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SearchApiApiKeys {
}

export class SearchApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SearchApiApiKeys, value: string) {
        this.authentications[SearchApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Search on a string
     * Search for entities that match a given sub-string.  --- Alternate route: &#x60;/dev/characters/{character_id}/search/&#x60;  Alternate route: &#x60;/v3/characters/{character_id}/search/&#x60;  --- This route is cached for up to 3600 seconds
     * @param categories Type of entities to search for
     * @param characterId An EVE character ID
     * @param search The string to search on
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param strict Whether the search should be a strict match
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdSearch (categories: Array<string>, characterId: number, search: string, datasource?: string, language?: string, strict?: boolean, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdSearchOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/search/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'categories' is not null or undefined
        if (categories === null || categories === undefined) {
            throw new Error('Required parameter categories was null or undefined when calling getCharactersCharacterIdSearch.');
        }

        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdSearch.');
        }

        // verify required parameter 'search' is not null or undefined
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling getCharactersCharacterIdSearch.');
        }

        if (categories !== undefined) {
            queryParameters['categories'] = categories;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (strict !== undefined) {
            queryParameters['strict'] = strict;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdSearchOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search on a string
     * Search for entities that match a given sub-string.  --- Alternate route: &#x60;/dev/search/&#x60;  Alternate route: &#x60;/v2/search/&#x60;  --- This route is cached for up to 3600 seconds
     * @param categories Type of entities to search for
     * @param search The string to search on
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param strict Whether the search should be a strict match
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getSearch (categories: Array<string>, search: string, datasource?: string, language?: string, strict?: boolean, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetSearchOk;  }> {
        const localVarPath = this.basePath + '/search/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'categories' is not null or undefined
        if (categories === null || categories === undefined) {
            throw new Error('Required parameter categories was null or undefined when calling getSearch.');
        }

        // verify required parameter 'search' is not null or undefined
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling getSearch.');
        }

        if (categories !== undefined) {
            queryParameters['categories'] = categories;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (strict !== undefined) {
            queryParameters['strict'] = strict;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSearchOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SkillsApiApiKeys {
}

export class SkillsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SkillsApiApiKeys, value: string) {
        this.authentications[SkillsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get character attributes
     * Return attributes of a character  --- Alternate route: &#x60;/dev/characters/{character_id}/attributes/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/attributes/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/attributes/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdAttributes (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdAttributesOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/attributes/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdAttributes.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdAttributesOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character&#39;s skill queue
     * List the configured skill queue for the given character  --- Alternate route: &#x60;/dev/characters/{character_id}/skillqueue/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/skillqueue/&#x60;  Alternate route: &#x60;/v2/characters/{character_id}/skillqueue/&#x60;  --- This route is cached for up to 120 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdSkillqueue (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdSkillqueue200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/skillqueue/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdSkillqueue.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdSkillqueue200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character skills
     * List all trained skills for the given character  --- Alternate route: &#x60;/dev/characters/{character_id}/skills/&#x60;  Alternate route: &#x60;/v4/characters/{character_id}/skills/&#x60;  --- This route is cached for up to 120 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdSkills (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdSkillsOk;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/skills/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdSkills.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetCharactersCharacterIdSkillsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SovereigntyApiApiKeys {
}

export class SovereigntyApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SovereigntyApiApiKeys, value: string) {
        this.authentications[SovereigntyApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * List sovereignty campaigns
     * Shows sovereignty data for campaigns.  --- Alternate route: &#x60;/dev/sovereignty/campaigns/&#x60;  Alternate route: &#x60;/legacy/sovereignty/campaigns/&#x60;  Alternate route: &#x60;/v1/sovereignty/campaigns/&#x60;  --- This route is cached for up to 5 seconds
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getSovereigntyCampaigns (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyCampaigns200Ok>;  }> {
        const localVarPath = this.basePath + '/sovereignty/campaigns/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyCampaigns200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List sovereignty of systems
     * Shows sovereignty information for solar systems  --- Alternate route: &#x60;/dev/sovereignty/map/&#x60;  Alternate route: &#x60;/legacy/sovereignty/map/&#x60;  Alternate route: &#x60;/v1/sovereignty/map/&#x60;  --- This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getSovereigntyMap (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyMap200Ok>;  }> {
        const localVarPath = this.basePath + '/sovereignty/map/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyMap200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List sovereignty structures
     * Shows sovereignty data for structures.  --- Alternate route: &#x60;/dev/sovereignty/structures/&#x60;  Alternate route: &#x60;/legacy/sovereignty/structures/&#x60;  Alternate route: &#x60;/v1/sovereignty/structures/&#x60;  --- This route is cached for up to 120 seconds
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getSovereigntyStructures (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyStructures200Ok>;  }> {
        const localVarPath = this.basePath + '/sovereignty/structures/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetSovereigntyStructures200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StatusApiApiKeys {
}

export class StatusApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StatusApiApiKeys, value: string) {
        this.authentications[StatusApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Retrieve the uptime and player counts
     * EVE Server status  --- Alternate route: &#x60;/dev/status/&#x60;  Alternate route: &#x60;/legacy/status/&#x60;  Alternate route: &#x60;/v1/status/&#x60;  --- This route is cached for up to 30 seconds
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getStatus (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetStatusOk;  }> {
        const localVarPath = this.basePath + '/status/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetStatusOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UniverseApiApiKeys {
}

export class UniverseApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UniverseApiApiKeys, value: string) {
        this.authentications[UniverseApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get bloodlines
     * Get a list of bloodlines  --- Alternate route: &#x60;/dev/universe/bloodlines/&#x60;  Alternate route: &#x60;/legacy/universe/bloodlines/&#x60;  Alternate route: &#x60;/v1/universe/bloodlines/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseBloodlines (datasource?: string, language?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetUniverseBloodlines200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/bloodlines/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetUniverseBloodlines200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get item categories
     * Get a list of item categories  --- Alternate route: &#x60;/dev/universe/categories/&#x60;  Alternate route: &#x60;/legacy/universe/categories/&#x60;  Alternate route: &#x60;/v1/universe/categories/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseCategories (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/categories/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get item category information
     * Get information of an item category  --- Alternate route: &#x60;/dev/universe/categories/{category_id}/&#x60;  Alternate route: &#x60;/legacy/universe/categories/{category_id}/&#x60;  Alternate route: &#x60;/v1/universe/categories/{category_id}/&#x60;  --- This route expires daily at 11:05
     * @param categoryId An Eve item category ID
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseCategoriesCategoryId (categoryId: number, datasource?: string, language?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseCategoriesCategoryIdOk;  }> {
        const localVarPath = this.basePath + '/universe/categories/{category_id}/'
            .replace('{' + 'category_id' + '}', String(categoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling getUniverseCategoriesCategoryId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseCategoriesCategoryIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get constellations
     * Get a list of constellations  --- Alternate route: &#x60;/dev/universe/constellations/&#x60;  Alternate route: &#x60;/legacy/universe/constellations/&#x60;  Alternate route: &#x60;/v1/universe/constellations/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseConstellations (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/constellations/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get constellation information
     * Get information on a constellation  --- Alternate route: &#x60;/dev/universe/constellations/{constellation_id}/&#x60;  Alternate route: &#x60;/legacy/universe/constellations/{constellation_id}/&#x60;  Alternate route: &#x60;/v1/universe/constellations/{constellation_id}/&#x60;  --- This route expires daily at 11:05
     * @param constellationId constellation_id integer
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseConstellationsConstellationId (constellationId: number, datasource?: string, language?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseConstellationsConstellationIdOk;  }> {
        const localVarPath = this.basePath + '/universe/constellations/{constellation_id}/'
            .replace('{' + 'constellation_id' + '}', String(constellationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'constellationId' is not null or undefined
        if (constellationId === null || constellationId === undefined) {
            throw new Error('Required parameter constellationId was null or undefined when calling getUniverseConstellationsConstellationId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseConstellationsConstellationIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get factions
     * Get a list of factions  --- Alternate route: &#x60;/dev/universe/factions/&#x60;  Alternate route: &#x60;/v2/universe/factions/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseFactions (datasource?: string, language?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetUniverseFactions200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/factions/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetUniverseFactions200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get graphics
     * Get a list of graphics  --- Alternate route: &#x60;/dev/universe/graphics/&#x60;  Alternate route: &#x60;/legacy/universe/graphics/&#x60;  Alternate route: &#x60;/v1/universe/graphics/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseGraphics (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/graphics/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get graphic information
     * Get information on a graphic  --- Alternate route: &#x60;/dev/universe/graphics/{graphic_id}/&#x60;  Alternate route: &#x60;/legacy/universe/graphics/{graphic_id}/&#x60;  Alternate route: &#x60;/v1/universe/graphics/{graphic_id}/&#x60;  --- This route expires daily at 11:05
     * @param graphicId graphic_id integer
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseGraphicsGraphicId (graphicId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseGraphicsGraphicIdOk;  }> {
        const localVarPath = this.basePath + '/universe/graphics/{graphic_id}/'
            .replace('{' + 'graphic_id' + '}', String(graphicId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'graphicId' is not null or undefined
        if (graphicId === null || graphicId === undefined) {
            throw new Error('Required parameter graphicId was null or undefined when calling getUniverseGraphicsGraphicId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseGraphicsGraphicIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get item groups
     * Get a list of item groups  --- Alternate route: &#x60;/dev/universe/groups/&#x60;  Alternate route: &#x60;/legacy/universe/groups/&#x60;  Alternate route: &#x60;/v1/universe/groups/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseGroups (datasource?: string, page?: number, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/groups/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get item group information
     * Get information on an item group  --- Alternate route: &#x60;/dev/universe/groups/{group_id}/&#x60;  Alternate route: &#x60;/legacy/universe/groups/{group_id}/&#x60;  Alternate route: &#x60;/v1/universe/groups/{group_id}/&#x60;  --- This route expires daily at 11:05
     * @param groupId An Eve item group ID
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseGroupsGroupId (groupId: number, datasource?: string, language?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseGroupsGroupIdOk;  }> {
        const localVarPath = this.basePath + '/universe/groups/{group_id}/'
            .replace('{' + 'group_id' + '}', String(groupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getUniverseGroupsGroupId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseGroupsGroupIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get moon information
     * Get information on a moon  --- Alternate route: &#x60;/dev/universe/moons/{moon_id}/&#x60;  Alternate route: &#x60;/legacy/universe/moons/{moon_id}/&#x60;  Alternate route: &#x60;/v1/universe/moons/{moon_id}/&#x60;  --- This route expires daily at 11:05
     * @param moonId moon_id integer
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseMoonsMoonId (moonId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseMoonsMoonIdOk;  }> {
        const localVarPath = this.basePath + '/universe/moons/{moon_id}/'
            .replace('{' + 'moon_id' + '}', String(moonId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'moonId' is not null or undefined
        if (moonId === null || moonId === undefined) {
            throw new Error('Required parameter moonId was null or undefined when calling getUniverseMoonsMoonId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseMoonsMoonIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get planet information
     * Get information on a planet  --- Alternate route: &#x60;/dev/universe/planets/{planet_id}/&#x60;  Alternate route: &#x60;/legacy/universe/planets/{planet_id}/&#x60;  Alternate route: &#x60;/v1/universe/planets/{planet_id}/&#x60;  --- This route expires daily at 11:05
     * @param planetId planet_id integer
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniversePlanetsPlanetId (planetId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniversePlanetsPlanetIdOk;  }> {
        const localVarPath = this.basePath + '/universe/planets/{planet_id}/'
            .replace('{' + 'planet_id' + '}', String(planetId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'planetId' is not null or undefined
        if (planetId === null || planetId === undefined) {
            throw new Error('Required parameter planetId was null or undefined when calling getUniversePlanetsPlanetId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniversePlanetsPlanetIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character races
     * Get a list of character races  --- Alternate route: &#x60;/dev/universe/races/&#x60;  Alternate route: &#x60;/legacy/universe/races/&#x60;  Alternate route: &#x60;/v1/universe/races/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseRaces (datasource?: string, language?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetUniverseRaces200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/races/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetUniverseRaces200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get regions
     * Get a list of regions  --- Alternate route: &#x60;/dev/universe/regions/&#x60;  Alternate route: &#x60;/legacy/universe/regions/&#x60;  Alternate route: &#x60;/v1/universe/regions/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseRegions (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/regions/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get region information
     * Get information on a region  --- Alternate route: &#x60;/dev/universe/regions/{region_id}/&#x60;  Alternate route: &#x60;/legacy/universe/regions/{region_id}/&#x60;  Alternate route: &#x60;/v1/universe/regions/{region_id}/&#x60;  --- This route expires daily at 11:05
     * @param regionId region_id integer
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseRegionsRegionId (regionId: number, datasource?: string, language?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseRegionsRegionIdOk;  }> {
        const localVarPath = this.basePath + '/universe/regions/{region_id}/'
            .replace('{' + 'region_id' + '}', String(regionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling getUniverseRegionsRegionId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseRegionsRegionIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get stargate information
     * Get information on a stargate  --- Alternate route: &#x60;/dev/universe/stargates/{stargate_id}/&#x60;  Alternate route: &#x60;/legacy/universe/stargates/{stargate_id}/&#x60;  Alternate route: &#x60;/v1/universe/stargates/{stargate_id}/&#x60;  --- This route expires daily at 11:05
     * @param stargateId stargate_id integer
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseStargatesStargateId (stargateId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseStargatesStargateIdOk;  }> {
        const localVarPath = this.basePath + '/universe/stargates/{stargate_id}/'
            .replace('{' + 'stargate_id' + '}', String(stargateId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stargateId' is not null or undefined
        if (stargateId === null || stargateId === undefined) {
            throw new Error('Required parameter stargateId was null or undefined when calling getUniverseStargatesStargateId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseStargatesStargateIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get star information
     * Get information on a star  --- Alternate route: &#x60;/dev/universe/stars/{star_id}/&#x60;  Alternate route: &#x60;/legacy/universe/stars/{star_id}/&#x60;  Alternate route: &#x60;/v1/universe/stars/{star_id}/&#x60;  --- This route expires daily at 11:05
     * @param starId star_id integer
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseStarsStarId (starId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseStarsStarIdOk;  }> {
        const localVarPath = this.basePath + '/universe/stars/{star_id}/'
            .replace('{' + 'star_id' + '}', String(starId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'starId' is not null or undefined
        if (starId === null || starId === undefined) {
            throw new Error('Required parameter starId was null or undefined when calling getUniverseStarsStarId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseStarsStarIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get station information
     * Get information on a station  --- Alternate route: &#x60;/dev/universe/stations/{station_id}/&#x60;  Alternate route: &#x60;/v2/universe/stations/{station_id}/&#x60;  --- This route is cached for up to 300 seconds
     * @param stationId station_id integer
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseStationsStationId (stationId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseStationsStationIdOk;  }> {
        const localVarPath = this.basePath + '/universe/stations/{station_id}/'
            .replace('{' + 'station_id' + '}', String(stationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stationId' is not null or undefined
        if (stationId === null || stationId === undefined) {
            throw new Error('Required parameter stationId was null or undefined when calling getUniverseStationsStationId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseStationsStationIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all public structures
     * List all public structures  --- Alternate route: &#x60;/dev/universe/structures/&#x60;  Alternate route: &#x60;/legacy/universe/structures/&#x60;  Alternate route: &#x60;/v1/universe/structures/&#x60;  --- This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseStructures (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/structures/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get structure information
     * Returns information on requested structure, if you are on the ACL. Otherwise, returns \&quot;Forbidden\&quot; for all inputs.  --- Alternate route: &#x60;/dev/universe/structures/{structure_id}/&#x60;  Alternate route: &#x60;/legacy/universe/structures/{structure_id}/&#x60;  Alternate route: &#x60;/v1/universe/structures/{structure_id}/&#x60;  --- This route is cached for up to 3600 seconds
     * @param structureId An Eve structure ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseStructuresStructureId (structureId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseStructuresStructureIdOk;  }> {
        const localVarPath = this.basePath + '/universe/structures/{structure_id}/'
            .replace('{' + 'structure_id' + '}', String(structureId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'structureId' is not null or undefined
        if (structureId === null || structureId === undefined) {
            throw new Error('Required parameter structureId was null or undefined when calling getUniverseStructuresStructureId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseStructuresStructureIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get system jumps
     * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: &#x60;/dev/universe/system_jumps/&#x60;  Alternate route: &#x60;/legacy/universe/system_jumps/&#x60;  Alternate route: &#x60;/v1/universe/system_jumps/&#x60;  --- This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseSystemJumps (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetUniverseSystemJumps200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/system_jumps/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetUniverseSystemJumps200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get system kills
     * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: &#x60;/dev/universe/system_kills/&#x60;  Alternate route: &#x60;/v2/universe/system_kills/&#x60;  --- This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseSystemKills (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetUniverseSystemKills200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/system_kills/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetUniverseSystemKills200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get solar systems
     * Get a list of solar systems  --- Alternate route: &#x60;/dev/universe/systems/&#x60;  Alternate route: &#x60;/legacy/universe/systems/&#x60;  Alternate route: &#x60;/v1/universe/systems/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseSystems (datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/systems/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get solar system information
     * Get information on a solar system  --- Alternate route: &#x60;/dev/universe/systems/{system_id}/&#x60;  Alternate route: &#x60;/v3/universe/systems/{system_id}/&#x60;  --- This route expires daily at 11:05
     * @param systemId system_id integer
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseSystemsSystemId (systemId: number, datasource?: string, language?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseSystemsSystemIdOk;  }> {
        const localVarPath = this.basePath + '/universe/systems/{system_id}/'
            .replace('{' + 'system_id' + '}', String(systemId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'systemId' is not null or undefined
        if (systemId === null || systemId === undefined) {
            throw new Error('Required parameter systemId was null or undefined when calling getUniverseSystemsSystemId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseSystemsSystemIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get types
     * Get a list of type ids  --- Alternate route: &#x60;/dev/universe/types/&#x60;  Alternate route: &#x60;/legacy/universe/types/&#x60;  Alternate route: &#x60;/v1/universe/types/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseTypes (datasource?: string, page?: number, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/universe/types/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get type information
     * Get information on a type  --- Alternate route: &#x60;/dev/universe/types/{type_id}/&#x60;  Alternate route: &#x60;/v3/universe/types/{type_id}/&#x60;  --- This route expires daily at 11:05
     * @param typeId An Eve item type ID
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getUniverseTypesTypeId (typeId: number, datasource?: string, language?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetUniverseTypesTypeIdOk;  }> {
        const localVarPath = this.basePath + '/universe/types/{type_id}/'
            .replace('{' + 'type_id' + '}', String(typeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling getUniverseTypesTypeId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetUniverseTypesTypeIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Bulk names to IDs
     * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours.  --- Alternate route: &#x60;/dev/universe/ids/&#x60;  Alternate route: &#x60;/legacy/universe/ids/&#x60;  Alternate route: &#x60;/v1/universe/ids/&#x60; 
     * @param names The names to resolve
     * @param datasource The server name you would like data from
     * @param language Language to use in the response
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postUniverseIds (names: Array<string>, datasource?: string, language?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: PostUniverseIdsOk;  }> {
        const localVarPath = this.basePath + '/universe/ids/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'names' is not null or undefined
        if (names === null || names === undefined) {
            throw new Error('Required parameter names was null or undefined when calling postUniverseIds.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (language !== undefined) {
            queryParameters['language'] = language;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: names,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostUniverseIdsOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get names and categories for a set of ID&#39;s
     * Resolve a set of IDs to names and categories. Supported ID&#39;s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types.  --- Alternate route: &#x60;/dev/universe/names/&#x60;  Alternate route: &#x60;/v2/universe/names/&#x60; 
     * @param ids The ids to resolve
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postUniverseNames (ids: Array<number>, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<PostUniverseNames200Ok>;  }> {
        const localVarPath = this.basePath + '/universe/names/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ids' is not null or undefined
        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling postUniverseNames.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ids,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PostUniverseNames200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserInterfaceApiApiKeys {
}

export class UserInterfaceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UserInterfaceApiApiKeys, value: string) {
        this.authentications[UserInterfaceApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Set Autopilot Waypoint
     * Set a solar system as autopilot waypoint  --- Alternate route: &#x60;/dev/ui/autopilot/waypoint/&#x60;  Alternate route: &#x60;/v2/ui/autopilot/waypoint/&#x60; 
     * @param addToBeginning Whether this solar system should be added to the beginning of all waypoints
     * @param clearOtherWaypoints Whether clean other waypoints beforing adding this one
     * @param destinationId The destination to travel to, can be solar system, station or structure&#39;s id
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postUiAutopilotWaypoint (addToBeginning: boolean, clearOtherWaypoints: boolean, destinationId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/autopilot/waypoint/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'addToBeginning' is not null or undefined
        if (addToBeginning === null || addToBeginning === undefined) {
            throw new Error('Required parameter addToBeginning was null or undefined when calling postUiAutopilotWaypoint.');
        }

        // verify required parameter 'clearOtherWaypoints' is not null or undefined
        if (clearOtherWaypoints === null || clearOtherWaypoints === undefined) {
            throw new Error('Required parameter clearOtherWaypoints was null or undefined when calling postUiAutopilotWaypoint.');
        }

        // verify required parameter 'destinationId' is not null or undefined
        if (destinationId === null || destinationId === undefined) {
            throw new Error('Required parameter destinationId was null or undefined when calling postUiAutopilotWaypoint.');
        }

        if (addToBeginning !== undefined) {
            queryParameters['add_to_beginning'] = addToBeginning;
        }

        if (clearOtherWaypoints !== undefined) {
            queryParameters['clear_other_waypoints'] = clearOtherWaypoints;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (destinationId !== undefined) {
            queryParameters['destination_id'] = destinationId;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Open Contract Window
     * Open the contract window inside the client  --- Alternate route: &#x60;/dev/ui/openwindow/contract/&#x60;  Alternate route: &#x60;/legacy/ui/openwindow/contract/&#x60;  Alternate route: &#x60;/v1/ui/openwindow/contract/&#x60; 
     * @param contractId The contract to open
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postUiOpenwindowContract (contractId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/openwindow/contract/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'contractId' is not null or undefined
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling postUiOpenwindowContract.');
        }

        if (contractId !== undefined) {
            queryParameters['contract_id'] = contractId;
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Open Information Window
     * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: &#x60;/dev/ui/openwindow/information/&#x60;  Alternate route: &#x60;/legacy/ui/openwindow/information/&#x60;  Alternate route: &#x60;/v1/ui/openwindow/information/&#x60; 
     * @param targetId The target to open
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postUiOpenwindowInformation (targetId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/openwindow/information/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'targetId' is not null or undefined
        if (targetId === null || targetId === undefined) {
            throw new Error('Required parameter targetId was null or undefined when calling postUiOpenwindowInformation.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (targetId !== undefined) {
            queryParameters['target_id'] = targetId;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Open Market Details
     * Open the market details window for a specific typeID inside the client  --- Alternate route: &#x60;/dev/ui/openwindow/marketdetails/&#x60;  Alternate route: &#x60;/legacy/ui/openwindow/marketdetails/&#x60;  Alternate route: &#x60;/v1/ui/openwindow/marketdetails/&#x60; 
     * @param typeId The item type to open in market window
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postUiOpenwindowMarketdetails (typeId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/openwindow/marketdetails/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling postUiOpenwindowMarketdetails.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (typeId !== undefined) {
            queryParameters['type_id'] = typeId;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Open New Mail Window
     * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: &#x60;/dev/ui/openwindow/newmail/&#x60;  Alternate route: &#x60;/legacy/ui/openwindow/newmail/&#x60;  Alternate route: &#x60;/v1/ui/openwindow/newmail/&#x60; 
     * @param newMail The details of mail to create
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public postUiOpenwindowNewmail (newMail: PostUiOpenwindowNewmailNewMail, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ui/openwindow/newmail/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newMail' is not null or undefined
        if (newMail === null || newMail === undefined) {
            throw new Error('Required parameter newMail was null or undefined when calling postUiOpenwindowNewmail.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newMail,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WalletApiApiKeys {
}

export class WalletApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: WalletApiApiKeys, value: string) {
        this.authentications[WalletApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * Get a character&#39;s wallet balance
     * Returns a character&#39;s wallet balance  --- Alternate route: &#x60;/dev/characters/{character_id}/wallet/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/wallet/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/wallet/&#x60;  --- This route is cached for up to 120 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdWallet (characterId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/wallet/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdWallet.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: number;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get character wallet journal
     * Retrieve character wallet journal  --- Alternate route: &#x60;/dev/characters/{character_id}/wallet/journal/&#x60;  Alternate route: &#x60;/v3/characters/{character_id}/wallet/journal/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param fromId Only show journal entries happened before the transaction referenced by this id
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdWalletJournal (characterId: number, datasource?: string, fromId?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdWalletJournal200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/wallet/journal/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdWalletJournal.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (fromId !== undefined) {
            queryParameters['from_id'] = fromId;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdWalletJournal200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get wallet transactions
     * Get wallet transactions of a character  --- Alternate route: &#x60;/dev/characters/{character_id}/wallet/transactions/&#x60;  Alternate route: &#x60;/legacy/characters/{character_id}/wallet/transactions/&#x60;  Alternate route: &#x60;/v1/characters/{character_id}/wallet/transactions/&#x60;  --- This route is cached for up to 3600 seconds
     * @param characterId An EVE character ID
     * @param datasource The server name you would like data from
     * @param fromId Only show transactions happened before the one referenced by this id
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCharactersCharacterIdWalletTransactions (characterId: number, datasource?: string, fromId?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdWalletTransactions200Ok>;  }> {
        const localVarPath = this.basePath + '/characters/{character_id}/wallet/transactions/'
            .replace('{' + 'character_id' + '}', String(characterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'characterId' is not null or undefined
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharactersCharacterIdWalletTransactions.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (fromId !== undefined) {
            queryParameters['from_id'] = fromId;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCharactersCharacterIdWalletTransactions200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a corporation&#39;s wallet balance
     * Get a corporation&#39;s wallets  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/wallets/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/wallets/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/wallets/&#x60;  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
     * @param corporationId An EVE corporation ID
     * @param datasource The server name you would like data from
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdWallets (corporationId: number, datasource?: string, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdWallets200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/wallets/'
            .replace('{' + 'corporation_id' + '}', String(corporationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdWallets.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdWallets200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation wallet journal
     * Retrieve corporation wallet journal  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/wallets/{division}/journal/&#x60;  Alternate route: &#x60;/v2/corporations/{corporation_id}/wallets/{division}/journal/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
     * @param corporationId An EVE corporation ID
     * @param division Wallet key of the division to fetch journals from
     * @param datasource The server name you would like data from
     * @param fromId Only show journal entries happened before the transaction referenced by this id
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdWalletsDivisionJournal (corporationId: number, division: number, datasource?: string, fromId?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdWalletsDivisionJournal200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/wallets/{division}/journal/'
            .replace('{' + 'corporation_id' + '}', String(corporationId))
            .replace('{' + 'division' + '}', String(division));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdWalletsDivisionJournal.');
        }

        // verify required parameter 'division' is not null or undefined
        if (division === null || division === undefined) {
            throw new Error('Required parameter division was null or undefined when calling getCorporationsCorporationIdWalletsDivisionJournal.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (fromId !== undefined) {
            queryParameters['from_id'] = fromId;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdWalletsDivisionJournal200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get corporation wallet transactions
     * Get wallet transactions of a corporation  --- Alternate route: &#x60;/dev/corporations/{corporation_id}/wallets/{division}/transactions/&#x60;  Alternate route: &#x60;/legacy/corporations/{corporation_id}/wallets/{division}/transactions/&#x60;  Alternate route: &#x60;/v1/corporations/{corporation_id}/wallets/{division}/transactions/&#x60;  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
     * @param corporationId An EVE corporation ID
     * @param division Wallet key of the division to fetch journals from
     * @param datasource The server name you would like data from
     * @param fromId Only show journal entries happened before the transaction referenced by this id
     * @param token Access token to use if unable to set a header
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getCorporationsCorporationIdWalletsDivisionTransactions (corporationId: number, division: number, datasource?: string, fromId?: number, token?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdWalletsDivisionTransactions200Ok>;  }> {
        const localVarPath = this.basePath + '/corporations/{corporation_id}/wallets/{division}/transactions/'
            .replace('{' + 'corporation_id' + '}', String(corporationId))
            .replace('{' + 'division' + '}', String(division));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'corporationId' is not null or undefined
        if (corporationId === null || corporationId === undefined) {
            throw new Error('Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdWalletsDivisionTransactions.');
        }

        // verify required parameter 'division' is not null or undefined
        if (division === null || division === undefined) {
            throw new Error('Required parameter division was null or undefined when calling getCorporationsCorporationIdWalletsDivisionTransactions.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (fromId !== undefined) {
            queryParameters['from_id'] = fromId;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.evesso.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetCorporationsCorporationIdWalletsDivisionTransactions200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WarsApiApiKeys {
}

export class WarsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'evesso': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: WarsApiApiKeys, value: string) {
        this.authentications[WarsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.evesso.accessToken = token;
    }
    /**
     * List wars
     * Return a list of wars  --- Alternate route: &#x60;/dev/wars/&#x60;  Alternate route: &#x60;/legacy/wars/&#x60;  Alternate route: &#x60;/v1/wars/&#x60;  --- This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param maxWarId Only return wars with ID smaller than this.
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getWars (datasource?: string, maxWarId?: number, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<number>;  }> {
        const localVarPath = this.basePath + '/wars/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (maxWarId !== undefined) {
            queryParameters['max_war_id'] = maxWarId;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get war information
     * Return details about a war  --- Alternate route: &#x60;/dev/wars/{war_id}/&#x60;  Alternate route: &#x60;/legacy/wars/{war_id}/&#x60;  Alternate route: &#x60;/v1/wars/{war_id}/&#x60;  --- This route is cached for up to 3600 seconds
     * @param warId ID for a war
     * @param datasource The server name you would like data from
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getWarsWarId (warId: number, datasource?: string, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: GetWarsWarIdOk;  }> {
        const localVarPath = this.basePath + '/wars/{war_id}/'
            .replace('{' + 'war_id' + '}', String(warId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'warId' is not null or undefined
        if (warId === null || warId === undefined) {
            throw new Error('Required parameter warId was null or undefined when calling getWarsWarId.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetWarsWarIdOk;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List kills for a war
     * Return a list of kills related to a war  --- Alternate route: &#x60;/dev/wars/{war_id}/killmails/&#x60;  Alternate route: &#x60;/legacy/wars/{war_id}/killmails/&#x60;  Alternate route: &#x60;/v1/wars/{war_id}/killmails/&#x60;  --- This route is cached for up to 3600 seconds
     * @param warId A valid war ID
     * @param datasource The server name you would like data from
     * @param page Which page of results to return
     * @param userAgent Client identifier, takes precedence over headers
     * @param xUserAgent Client identifier, takes precedence over User-Agent
     */
    public getWarsWarIdKillmails (warId: number, datasource?: string, page?: number, userAgent?: string, xUserAgent?: string) : Promise<{ response: http.ClientResponse; body: Array<GetWarsWarIdKillmails200Ok>;  }> {
        const localVarPath = this.basePath + '/wars/{war_id}/killmails/'
            .replace('{' + 'war_id' + '}', String(warId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'warId' is not null or undefined
        if (warId === null || warId === undefined) {
            throw new Error('Required parameter warId was null or undefined when calling getWarsWarIdKillmails.');
        }

        if (datasource !== undefined) {
            queryParameters['datasource'] = datasource;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (userAgent !== undefined) {
            queryParameters['user_agent'] = userAgent;
        }

        headerParams['X-User-Agent'] = xUserAgent;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<GetWarsWarIdKillmails200Ok>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
